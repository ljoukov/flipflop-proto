// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: AppStoreProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum AppStorePurchaseTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case autoRenewableSubscription // = 1
  case nonConsumable // = 2
  case consumable // = 3
  case nonRenewingSubscription // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .autoRenewableSubscription
    case 2: self = .nonConsumable
    case 3: self = .consumable
    case 4: self = .nonRenewingSubscription
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .autoRenewableSubscription: return 1
    case .nonConsumable: return 2
    case .consumable: return 3
    case .nonRenewingSubscription: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppStorePurchaseTypeProto] = [
    .unspecified,
    .autoRenewableSubscription,
    .nonConsumable,
    .consumable,
    .nonRenewingSubscription,
  ]

}

enum AppStoreInAppOwnershipTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case purchased // = 1
  case familyShared // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .purchased
    case 2: self = .familyShared
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .purchased: return 1
    case .familyShared: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppStoreInAppOwnershipTypeProto] = [
    .unspecified,
    .purchased,
    .familyShared,
  ]

}

enum AppStoreRevocationReasonProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case refundedForOtherReason // = 1
  case refundedDueToIssue // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .refundedForOtherReason
    case 2: self = .refundedDueToIssue
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .refundedForOtherReason: return 1
    case .refundedDueToIssue: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppStoreRevocationReasonProto] = [
    .unspecified,
    .refundedForOtherReason,
    .refundedDueToIssue,
  ]

}

enum AppStoreOfferTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case introductoryOffer // = 1
  case promotionalOffer // = 2
  case subscriptionOfferCode // = 3
  case winBackOffer // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .introductoryOffer
    case 2: self = .promotionalOffer
    case 3: self = .subscriptionOfferCode
    case 4: self = .winBackOffer
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .introductoryOffer: return 1
    case .promotionalOffer: return 2
    case .subscriptionOfferCode: return 3
    case .winBackOffer: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppStoreOfferTypeProto] = [
    .unspecified,
    .introductoryOffer,
    .promotionalOffer,
    .subscriptionOfferCode,
    .winBackOffer,
  ]

}

enum AppStoreEnvironmentProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case sandbox // = 1
  case production // = 2
  case xcode // = 3
  case localTesting // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .sandbox
    case 2: self = .production
    case 3: self = .xcode
    case 4: self = .localTesting
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .sandbox: return 1
    case .production: return 2
    case .xcode: return 3
    case .localTesting: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppStoreEnvironmentProto] = [
    .unspecified,
    .sandbox,
    .production,
    .xcode,
    .localTesting,
  ]

}

enum AppStoreTransactionReasonProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case purchase // = 1
  case renewal // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .purchase
    case 2: self = .renewal
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .purchase: return 1
    case .renewal: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppStoreTransactionReasonProto] = [
    .unspecified,
    .purchase,
    .renewal,
  ]

}

enum AppStoreOfferDiscountTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unspecified // = 0
  case freeTrial // = 1
  case payAsYouGo // = 2
  case payUpFront // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .freeTrial
    case 2: self = .payAsYouGo
    case 3: self = .payUpFront
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .freeTrial: return 1
    case .payAsYouGo: return 2
    case .payUpFront: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AppStoreOfferDiscountTypeProto] = [
    .unspecified,
    .freeTrial,
    .payAsYouGo,
    .payUpFront,
  ]

}

struct AppStoreTransactionProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var originalTransactionID: String {
    get {return _storage._originalTransactionID}
    set {_uniqueStorage()._originalTransactionID = newValue}
  }

  var transactionID: String {
    get {return _storage._transactionID}
    set {_uniqueStorage()._transactionID = newValue}
  }

  var webOrderLineItemID: String {
    get {return _storage._webOrderLineItemID}
    set {_uniqueStorage()._webOrderLineItemID = newValue}
  }

  var bundleID: String {
    get {return _storage._bundleID}
    set {_uniqueStorage()._bundleID = newValue}
  }

  var productID: String {
    get {return _storage._productID}
    set {_uniqueStorage()._productID = newValue}
  }

  var subscriptionGroupIdentifier: String {
    get {return _storage._subscriptionGroupIdentifier}
    set {_uniqueStorage()._subscriptionGroupIdentifier = newValue}
  }

  var purchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._purchaseDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._purchaseDate = newValue}
  }
  /// Returns true if `purchaseDate` has been explicitly set.
  var hasPurchaseDate: Bool {return _storage._purchaseDate != nil}
  /// Clears the value of `purchaseDate`. Subsequent reads from it will return its default value.
  mutating func clearPurchaseDate() {_uniqueStorage()._purchaseDate = nil}

  var originalPurchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._originalPurchaseDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._originalPurchaseDate = newValue}
  }
  /// Returns true if `originalPurchaseDate` has been explicitly set.
  var hasOriginalPurchaseDate: Bool {return _storage._originalPurchaseDate != nil}
  /// Clears the value of `originalPurchaseDate`. Subsequent reads from it will return its default value.
  mutating func clearOriginalPurchaseDate() {_uniqueStorage()._originalPurchaseDate = nil}

  /// an auto-renewable subscription expires or renews.
  var expiresDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._expiresDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._expiresDate = newValue}
  }
  /// Returns true if `expiresDate` has been explicitly set.
  var hasExpiresDate: Bool {return _storage._expiresDate != nil}
  /// Clears the value of `expiresDate`. Subsequent reads from it will return its default value.
  mutating func clearExpiresDate() {_uniqueStorage()._expiresDate = nil}

  /// The number of consumable products purchased.
  var quantity: Int32 {
    get {return _storage._quantity}
    set {_uniqueStorage()._quantity = newValue}
  }

  var type: AppStorePurchaseTypeProto {
    get {return _storage._type}
    set {_uniqueStorage()._type = newValue}
  }

  /// The UUID that an app optionally generates to map a customer’s in-app
  /// purchase with its resulting App Store transaction.
  var appAccountToken: String {
    get {return _storage._appAccountToken}
    set {_uniqueStorage()._appAccountToken = newValue}
  }

  /// A string that describes whether the transaction was purchased by the user,
  /// or is available to them through Family Sharing.
  var inAppOwnershipType: AppStoreInAppOwnershipTypeProto {
    get {return _storage._inAppOwnershipType}
    set {_uniqueStorage()._inAppOwnershipType = newValue}
  }

  /// The time when the App Store signed the JSON Web Signature data.
  var signedDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._signedDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._signedDate = newValue}
  }
  /// Returns true if `signedDate` has been explicitly set.
  var hasSignedDate: Bool {return _storage._signedDate != nil}
  /// Clears the value of `signedDate`. Subsequent reads from it will return its default value.
  mutating func clearSignedDate() {_uniqueStorage()._signedDate = nil}

  /// The reason that the App Store refunded the transaction or revoked it from
  /// family sharing.
  var revocationReason: AppStoreRevocationReasonProto {
    get {return _storage._revocationReason}
    set {_uniqueStorage()._revocationReason = newValue}
  }

  /// The time when Apple Support refunded a transaction.
  var revocationDate: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._revocationDate ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._revocationDate = newValue}
  }
  /// Returns true if `revocationDate` has been explicitly set.
  var hasRevocationDate: Bool {return _storage._revocationDate != nil}
  /// Clears the value of `revocationDate`. Subsequent reads from it will return its default value.
  mutating func clearRevocationDate() {_uniqueStorage()._revocationDate = nil}

  /// The Boolean value that indicates whether the user upgraded to another
  /// subscription.
  var isUpgraded: Bool {
    get {return _storage._isUpgraded}
    set {_uniqueStorage()._isUpgraded = newValue}
  }

  /// A value that represents the promotional offer type.
  var offerType: AppStoreOfferTypeProto {
    get {return _storage._offerType}
    set {_uniqueStorage()._offerType = newValue}
  }

  /// The identifier that contains the promo code or the promotional offer
  /// identifier.
  var offerIdentifier: String {
    get {return _storage._offerIdentifier}
    set {_uniqueStorage()._offerIdentifier = newValue}
  }

  /// The server environment, either sandbox or production.
  var environment: AppStoreEnvironmentProto {
    get {return _storage._environment}
    set {_uniqueStorage()._environment = newValue}
  }

  /// The three-letter code that represents the country or region associated with
  /// the App Store storefront for the purchase.
  var storefront: String {
    get {return _storage._storefront}
    set {_uniqueStorage()._storefront = newValue}
  }

  /// An Apple-defined value that uniquely identifies the App Store storefront
  /// associated with the purchase.
  var storefrontID: String {
    get {return _storage._storefrontID}
    set {_uniqueStorage()._storefrontID = newValue}
  }

  /// The reason for the purchase transaction, which indicates whether it’s a
  /// customer’s purchase or a renewal for an auto-renewable subscription that
  /// the system initiates.
  var transactionReason: AppStoreTransactionReasonProto {
    get {return _storage._transactionReason}
    set {_uniqueStorage()._transactionReason = newValue}
  }

  /// The three-letter ISO 4217 currency code for the price of the product.
  var currency: String {
    get {return _storage._currency}
    set {_uniqueStorage()._currency = newValue}
  }

  /// The price, in milliunits, of the in-app purchase or subscription offer that
  /// you configured in App Store Connect.
  var price: Int64 {
    get {return _storage._price}
    set {_uniqueStorage()._price = newValue}
  }

  /// The payment mode you configure for an introductory offer, promotional
  /// offer, or offer code on an auto-renewable subscription.
  var offerDiscountType: AppStoreOfferDiscountTypeProto {
    get {return _storage._offerDiscountType}
    set {_uniqueStorage()._offerDiscountType = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension AppStorePurchaseTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_STORE_PURCHASE_TYPE_PROTO_UNSPECIFIED"),
    1: .same(proto: "APP_STORE_PURCHASE_TYPE_PROTO_AUTO_RENEWABLE_SUBSCRIPTION"),
    2: .same(proto: "APP_STORE_PURCHASE_TYPE_PROTO_NON_CONSUMABLE"),
    3: .same(proto: "APP_STORE_PURCHASE_TYPE_PROTO_CONSUMABLE"),
    4: .same(proto: "APP_STORE_PURCHASE_TYPE_PROTO_NON_RENEWING_SUBSCRIPTION"),
  ]
}

extension AppStoreInAppOwnershipTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_STORE_IN_APP_OWNERSHIP_TYPE_PROTO_UNSPECIFIED"),
    1: .same(proto: "APP_STORE_IN_APP_OWNERSHIP_TYPE_PROTO_PURCHASED"),
    2: .same(proto: "APP_STORE_IN_APP_OWNERSHIP_TYPE_PROTO_FAMILY_SHARED"),
  ]
}

extension AppStoreRevocationReasonProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_STORE_REVOCATION_REASON_PROTO_UNSPECIFIED"),
    1: .same(proto: "APP_STORE_REVOCATION_REASON_PROTO_REFUNDED_FOR_OTHER_REASON"),
    2: .same(proto: "APP_STORE_REVOCATION_REASON_PROTO_REFUNDED_DUE_TO_ISSUE"),
  ]
}

extension AppStoreOfferTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_STORE_OFFER_TYPE_PROTO_UNSPECIFIED"),
    1: .same(proto: "APP_STORE_OFFER_TYPE_PROTO_INTRODUCTORY_OFFER"),
    2: .same(proto: "APP_STORE_OFFER_TYPE_PROTO_PROMOTIONAL_OFFER"),
    3: .same(proto: "APP_STORE_OFFER_TYPE_PROTO_SUBSCRIPTION_OFFER_CODE"),
    4: .same(proto: "APP_STORE_OFFER_TYPE_PROTO_WIN_BACK_OFFER"),
  ]
}

extension AppStoreEnvironmentProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_STORE_ENVIRONMENT_PROTO_UNSPECIFIED"),
    1: .same(proto: "APP_STORE_ENVIRONMENT_PROTO_SANDBOX"),
    2: .same(proto: "APP_STORE_ENVIRONMENT_PROTO_PRODUCTION"),
    3: .same(proto: "APP_STORE_ENVIRONMENT_PROTO_XCODE"),
    4: .same(proto: "APP_STORE_ENVIRONMENT_PROTO_LOCAL_TESTING"),
  ]
}

extension AppStoreTransactionReasonProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_STORE_TRANSACTION_REASON_PROTO_UNSPECIFIED"),
    1: .same(proto: "APP_STORE_TRANSACTION_REASON_PROTO_PURCHASE"),
    2: .same(proto: "APP_STORE_TRANSACTION_REASON_PROTO_RENEWAL"),
  ]
}

extension AppStoreOfferDiscountTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_STORE_OFFER_DISCOUNT_TYPE_PROTO_UNSPECIFIED"),
    1: .same(proto: "APP_STORE_OFFER_DISCOUNT_TYPE_PROTO_FREE_TRIAL"),
    2: .same(proto: "APP_STORE_OFFER_DISCOUNT_TYPE_PROTO_PAY_AS_YOU_GO"),
    3: .same(proto: "APP_STORE_OFFER_DISCOUNT_TYPE_PROTO_PAY_UP_FRONT"),
  ]
}

extension AppStoreTransactionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AppStoreTransactionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "original_transaction_id"),
    2: .standard(proto: "transaction_id"),
    3: .standard(proto: "web_order_line_item_id"),
    4: .standard(proto: "bundle_id"),
    5: .standard(proto: "product_id"),
    6: .standard(proto: "subscription_group_identifier"),
    7: .standard(proto: "purchase_date"),
    8: .standard(proto: "original_purchase_date"),
    9: .standard(proto: "expires_date"),
    10: .same(proto: "quantity"),
    11: .same(proto: "type"),
    12: .standard(proto: "app_account_token"),
    13: .standard(proto: "in_app_ownership_type"),
    14: .standard(proto: "signed_date"),
    15: .standard(proto: "revocation_reason"),
    16: .standard(proto: "revocation_date"),
    17: .standard(proto: "is_upgraded"),
    18: .standard(proto: "offer_type"),
    19: .standard(proto: "offer_identifier"),
    20: .same(proto: "environment"),
    21: .same(proto: "storefront"),
    22: .standard(proto: "storefront_id"),
    23: .standard(proto: "transaction_reason"),
    24: .same(proto: "currency"),
    25: .same(proto: "price"),
    26: .standard(proto: "offer_discount_type"),
  ]

  fileprivate class _StorageClass {
    var _originalTransactionID: String = String()
    var _transactionID: String = String()
    var _webOrderLineItemID: String = String()
    var _bundleID: String = String()
    var _productID: String = String()
    var _subscriptionGroupIdentifier: String = String()
    var _purchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _originalPurchaseDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _expiresDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _quantity: Int32 = 0
    var _type: AppStorePurchaseTypeProto = .unspecified
    var _appAccountToken: String = String()
    var _inAppOwnershipType: AppStoreInAppOwnershipTypeProto = .unspecified
    var _signedDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _revocationReason: AppStoreRevocationReasonProto = .unspecified
    var _revocationDate: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isUpgraded: Bool = false
    var _offerType: AppStoreOfferTypeProto = .unspecified
    var _offerIdentifier: String = String()
    var _environment: AppStoreEnvironmentProto = .unspecified
    var _storefront: String = String()
    var _storefrontID: String = String()
    var _transactionReason: AppStoreTransactionReasonProto = .unspecified
    var _currency: String = String()
    var _price: Int64 = 0
    var _offerDiscountType: AppStoreOfferDiscountTypeProto = .unspecified

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _originalTransactionID = source._originalTransactionID
      _transactionID = source._transactionID
      _webOrderLineItemID = source._webOrderLineItemID
      _bundleID = source._bundleID
      _productID = source._productID
      _subscriptionGroupIdentifier = source._subscriptionGroupIdentifier
      _purchaseDate = source._purchaseDate
      _originalPurchaseDate = source._originalPurchaseDate
      _expiresDate = source._expiresDate
      _quantity = source._quantity
      _type = source._type
      _appAccountToken = source._appAccountToken
      _inAppOwnershipType = source._inAppOwnershipType
      _signedDate = source._signedDate
      _revocationReason = source._revocationReason
      _revocationDate = source._revocationDate
      _isUpgraded = source._isUpgraded
      _offerType = source._offerType
      _offerIdentifier = source._offerIdentifier
      _environment = source._environment
      _storefront = source._storefront
      _storefrontID = source._storefrontID
      _transactionReason = source._transactionReason
      _currency = source._currency
      _price = source._price
      _offerDiscountType = source._offerDiscountType
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._originalTransactionID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._transactionID) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._webOrderLineItemID) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._bundleID) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._productID) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._subscriptionGroupIdentifier) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._purchaseDate) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._originalPurchaseDate) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._expiresDate) }()
        case 10: try { try decoder.decodeSingularInt32Field(value: &_storage._quantity) }()
        case 11: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._appAccountToken) }()
        case 13: try { try decoder.decodeSingularEnumField(value: &_storage._inAppOwnershipType) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._signedDate) }()
        case 15: try { try decoder.decodeSingularEnumField(value: &_storage._revocationReason) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._revocationDate) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._isUpgraded) }()
        case 18: try { try decoder.decodeSingularEnumField(value: &_storage._offerType) }()
        case 19: try { try decoder.decodeSingularStringField(value: &_storage._offerIdentifier) }()
        case 20: try { try decoder.decodeSingularEnumField(value: &_storage._environment) }()
        case 21: try { try decoder.decodeSingularStringField(value: &_storage._storefront) }()
        case 22: try { try decoder.decodeSingularStringField(value: &_storage._storefrontID) }()
        case 23: try { try decoder.decodeSingularEnumField(value: &_storage._transactionReason) }()
        case 24: try { try decoder.decodeSingularStringField(value: &_storage._currency) }()
        case 25: try { try decoder.decodeSingularInt64Field(value: &_storage._price) }()
        case 26: try { try decoder.decodeSingularEnumField(value: &_storage._offerDiscountType) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._originalTransactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._originalTransactionID, fieldNumber: 1)
      }
      if !_storage._transactionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._transactionID, fieldNumber: 2)
      }
      if !_storage._webOrderLineItemID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._webOrderLineItemID, fieldNumber: 3)
      }
      if !_storage._bundleID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._bundleID, fieldNumber: 4)
      }
      if !_storage._productID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._productID, fieldNumber: 5)
      }
      if !_storage._subscriptionGroupIdentifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subscriptionGroupIdentifier, fieldNumber: 6)
      }
      try { if let v = _storage._purchaseDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._originalPurchaseDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._expiresDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      if _storage._quantity != 0 {
        try visitor.visitSingularInt32Field(value: _storage._quantity, fieldNumber: 10)
      }
      if _storage._type != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._type, fieldNumber: 11)
      }
      if !_storage._appAccountToken.isEmpty {
        try visitor.visitSingularStringField(value: _storage._appAccountToken, fieldNumber: 12)
      }
      if _storage._inAppOwnershipType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._inAppOwnershipType, fieldNumber: 13)
      }
      try { if let v = _storage._signedDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if _storage._revocationReason != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._revocationReason, fieldNumber: 15)
      }
      try { if let v = _storage._revocationDate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._isUpgraded != false {
        try visitor.visitSingularBoolField(value: _storage._isUpgraded, fieldNumber: 17)
      }
      if _storage._offerType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._offerType, fieldNumber: 18)
      }
      if !_storage._offerIdentifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._offerIdentifier, fieldNumber: 19)
      }
      if _storage._environment != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._environment, fieldNumber: 20)
      }
      if !_storage._storefront.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storefront, fieldNumber: 21)
      }
      if !_storage._storefrontID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storefrontID, fieldNumber: 22)
      }
      if _storage._transactionReason != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._transactionReason, fieldNumber: 23)
      }
      if !_storage._currency.isEmpty {
        try visitor.visitSingularStringField(value: _storage._currency, fieldNumber: 24)
      }
      if _storage._price != 0 {
        try visitor.visitSingularInt64Field(value: _storage._price, fieldNumber: 25)
      }
      if _storage._offerDiscountType != .unspecified {
        try visitor.visitSingularEnumField(value: _storage._offerDiscountType, fieldNumber: 26)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AppStoreTransactionProto, rhs: AppStoreTransactionProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._originalTransactionID != rhs_storage._originalTransactionID {return false}
        if _storage._transactionID != rhs_storage._transactionID {return false}
        if _storage._webOrderLineItemID != rhs_storage._webOrderLineItemID {return false}
        if _storage._bundleID != rhs_storage._bundleID {return false}
        if _storage._productID != rhs_storage._productID {return false}
        if _storage._subscriptionGroupIdentifier != rhs_storage._subscriptionGroupIdentifier {return false}
        if _storage._purchaseDate != rhs_storage._purchaseDate {return false}
        if _storage._originalPurchaseDate != rhs_storage._originalPurchaseDate {return false}
        if _storage._expiresDate != rhs_storage._expiresDate {return false}
        if _storage._quantity != rhs_storage._quantity {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._appAccountToken != rhs_storage._appAccountToken {return false}
        if _storage._inAppOwnershipType != rhs_storage._inAppOwnershipType {return false}
        if _storage._signedDate != rhs_storage._signedDate {return false}
        if _storage._revocationReason != rhs_storage._revocationReason {return false}
        if _storage._revocationDate != rhs_storage._revocationDate {return false}
        if _storage._isUpgraded != rhs_storage._isUpgraded {return false}
        if _storage._offerType != rhs_storage._offerType {return false}
        if _storage._offerIdentifier != rhs_storage._offerIdentifier {return false}
        if _storage._environment != rhs_storage._environment {return false}
        if _storage._storefront != rhs_storage._storefront {return false}
        if _storage._storefrontID != rhs_storage._storefrontID {return false}
        if _storage._transactionReason != rhs_storage._transactionReason {return false}
        if _storage._currency != rhs_storage._currency {return false}
        if _storage._price != rhs_storage._price {return false}
        if _storage._offerDiscountType != rhs_storage._offerDiscountType {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
