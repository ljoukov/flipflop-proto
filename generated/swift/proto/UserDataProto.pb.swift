// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: UserDataProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum LikeStatusProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case likeStatusUnknown // = 0
  case likeStatusActive // = 1
  case likeStatusInactive // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .likeStatusUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .likeStatusUnknown
    case 1: self = .likeStatusActive
    case 2: self = .likeStatusInactive
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .likeStatusUnknown: return 0
    case .likeStatusActive: return 1
    case .likeStatusInactive: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [LikeStatusProto] = [
    .likeStatusUnknown,
    .likeStatusActive,
    .likeStatusInactive,
  ]

}

struct GetUserDataRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetUserDataResponseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userData: UserDataProto {
    get {return _userData ?? UserDataProto()}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userData: UserDataProto? = nil
}

struct UpdateUserDataRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userData: UserDataProto {
    get {return _userData ?? UserDataProto()}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userData: UserDataProto? = nil
}

struct UpdateUserDataResponseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userData: UserDataProto {
    get {return _userData ?? UserDataProto()}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userData: UserDataProto? = nil
}

struct DeleteUserHistoryRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeleteUserHistoryResponseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UserApiRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encodedUserAuth: String = String()

  var request: UserApiRequestProto.OneOf_Request? = nil

  var getUserData: GetUserDataRequestProto {
    get {
      if case .getUserData(let v)? = request {return v}
      return GetUserDataRequestProto()
    }
    set {request = .getUserData(newValue)}
  }

  var updateUserData: UpdateUserDataRequestProto {
    get {
      if case .updateUserData(let v)? = request {return v}
      return UpdateUserDataRequestProto()
    }
    set {request = .updateUserData(newValue)}
  }

  var deleteUserHistory: DeleteUserHistoryRequestProto {
    get {
      if case .deleteUserHistory(let v)? = request {return v}
      return DeleteUserHistoryRequestProto()
    }
    set {request = .deleteUserHistory(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case getUserData(GetUserDataRequestProto)
    case updateUserData(UpdateUserDataRequestProto)
    case deleteUserHistory(DeleteUserHistoryRequestProto)

  }

  init() {}
}

struct UserApiResponseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present the token was refreshed and the client should use this new one
  /// from now onwards.
  var refreshedEncodedUserAuth: String = String()

  var response: UserApiResponseProto.OneOf_Response? = nil

  var getUserData: GetUserDataResponseProto {
    get {
      if case .getUserData(let v)? = response {return v}
      return GetUserDataResponseProto()
    }
    set {response = .getUserData(newValue)}
  }

  var updateUserData: UpdateUserDataResponseProto {
    get {
      if case .updateUserData(let v)? = response {return v}
      return UpdateUserDataResponseProto()
    }
    set {response = .updateUserData(newValue)}
  }

  var deleteUserHistory: DeleteUserHistoryResponseProto {
    get {
      if case .deleteUserHistory(let v)? = response {return v}
      return DeleteUserHistoryResponseProto()
    }
    set {response = .deleteUserHistory(newValue)}
  }

  var latencies: Dictionary<String,SwiftProtobuf.Google_Protobuf_Duration> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable, Sendable {
    case getUserData(GetUserDataResponseProto)
    case updateUserData(UpdateUserDataResponseProto)
    case deleteUserHistory(DeleteUserHistoryResponseProto)

  }

  init() {}
}

struct CardUserDataProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardID: String = String()

  var lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastModifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModifiedAt = newValue}
  }
  /// Returns true if `lastModifiedAt` has been explicitly set.
  var hasLastModifiedAt: Bool {return self._lastModifiedAt != nil}
  /// Clears the value of `lastModifiedAt`. Subsequent reads from it will return its default value.
  mutating func clearLastModifiedAt() {self._lastModifiedAt = nil}

  /// For cards with True/False, ABC, voting, starts with 1; 0 means not acted
  var selectedOptionNumber: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct StoryUserDataProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storyID: String = String()

  var lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastModifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModifiedAt = newValue}
  }
  /// Returns true if `lastModifiedAt` has been explicitly set.
  var hasLastModifiedAt: Bool {return self._lastModifiedAt != nil}
  /// Clears the value of `lastModifiedAt`. Subsequent reads from it will return its default value.
  mutating func clearLastModifiedAt() {self._lastModifiedAt = nil}

  var likeStatus: LikeStatusProto = .likeStatusUnknown

  var cardsData: [CardUserDataProto] = []

  var viewDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _viewDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_viewDuration = newValue}
  }
  /// Returns true if `viewDuration` has been explicitly set.
  var hasViewDuration: Bool {return self._viewDuration != nil}
  /// Clears the value of `viewDuration`. Subsequent reads from it will return its default value.
  mutating func clearViewDuration() {self._viewDuration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _viewDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct UserDataProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastModifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModifiedAt = newValue}
  }
  /// Returns true if `lastModifiedAt` has been explicitly set.
  var hasLastModifiedAt: Bool {return self._lastModifiedAt != nil}
  /// Clears the value of `lastModifiedAt`. Subsequent reads from it will return its default value.
  mutating func clearLastModifiedAt() {self._lastModifiedAt = nil}

  var storiesData: [StoryUserDataProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension LikeStatusProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LIKE_STATUS_UNKNOWN"),
    1: .same(proto: "LIKE_STATUS_ACTIVE"),
    2: .same(proto: "LIKE_STATUS_INACTIVE"),
  ]
}

extension GetUserDataRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetUserDataRequestProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetUserDataRequestProto, rhs: GetUserDataRequestProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetUserDataResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetUserDataResponseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetUserDataResponseProto, rhs: GetUserDataResponseProto) -> Bool {
    if lhs._userData != rhs._userData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateUserDataRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateUserDataRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateUserDataRequestProto, rhs: UpdateUserDataRequestProto) -> Bool {
    if lhs._userData != rhs._userData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateUserDataResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateUserDataResponseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._userData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userData {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateUserDataResponseProto, rhs: UpdateUserDataResponseProto) -> Bool {
    if lhs._userData != rhs._userData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteUserHistoryRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteUserHistoryRequestProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteUserHistoryRequestProto, rhs: DeleteUserHistoryRequestProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteUserHistoryResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteUserHistoryResponseProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteUserHistoryResponseProto, rhs: DeleteUserHistoryResponseProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserApiRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserApiRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encoded_user_auth"),
    2: .standard(proto: "get_user_data"),
    3: .standard(proto: "update_user_data"),
    4: .standard(proto: "delete_user_history"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.encodedUserAuth) }()
      case 2: try {
        var v: GetUserDataRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getUserData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getUserData(v)
        }
      }()
      case 3: try {
        var v: UpdateUserDataRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .updateUserData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .updateUserData(v)
        }
      }()
      case 4: try {
        var v: DeleteUserHistoryRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteUserHistory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteUserHistory(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.encodedUserAuth.isEmpty {
      try visitor.visitSingularStringField(value: self.encodedUserAuth, fieldNumber: 1)
    }
    switch self.request {
    case .getUserData?: try {
      guard case .getUserData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateUserData?: try {
      guard case .updateUserData(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteUserHistory?: try {
      guard case .deleteUserHistory(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserApiRequestProto, rhs: UserApiRequestProto) -> Bool {
    if lhs.encodedUserAuth != rhs.encodedUserAuth {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserApiResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserApiResponseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refreshed_encoded_user_auth"),
    2: .standard(proto: "get_user_data"),
    3: .standard(proto: "update_user_data"),
    4: .standard(proto: "delete_user_history"),
    100: .same(proto: "latencies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refreshedEncodedUserAuth) }()
      case 2: try {
        var v: GetUserDataResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getUserData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getUserData(v)
        }
      }()
      case 3: try {
        var v: UpdateUserDataResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .updateUserData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .updateUserData(v)
        }
      }()
      case 4: try {
        var v: DeleteUserHistoryResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteUserHistory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteUserHistory(v)
        }
      }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: &self.latencies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.refreshedEncodedUserAuth.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshedEncodedUserAuth, fieldNumber: 1)
    }
    switch self.response {
    case .getUserData?: try {
      guard case .getUserData(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateUserData?: try {
      guard case .updateUserData(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteUserHistory?: try {
      guard case .deleteUserHistory(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.latencies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: self.latencies, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserApiResponseProto, rhs: UserApiResponseProto) -> Bool {
    if lhs.refreshedEncodedUserAuth != rhs.refreshedEncodedUserAuth {return false}
    if lhs.response != rhs.response {return false}
    if lhs.latencies != rhs.latencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CardUserDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CardUserDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_id"),
    2: .standard(proto: "last_modified_at"),
    4: .standard(proto: "selected_option_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastModifiedAt) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.selectedOptionNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cardID.isEmpty {
      try visitor.visitSingularStringField(value: self.cardID, fieldNumber: 1)
    }
    try { if let v = self._lastModifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.selectedOptionNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.selectedOptionNumber, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CardUserDataProto, rhs: CardUserDataProto) -> Bool {
    if lhs.cardID != rhs.cardID {return false}
    if lhs._lastModifiedAt != rhs._lastModifiedAt {return false}
    if lhs.selectedOptionNumber != rhs.selectedOptionNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoryUserDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoryUserDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "last_modified_at"),
    6: .standard(proto: "like_status"),
    4: .standard(proto: "cards_data"),
    5: .standard(proto: "view_duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastModifiedAt) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.cardsData) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._viewDuration) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.likeStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    try { if let v = self._lastModifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.cardsData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cardsData, fieldNumber: 4)
    }
    try { if let v = self._viewDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if self.likeStatus != .likeStatusUnknown {
      try visitor.visitSingularEnumField(value: self.likeStatus, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoryUserDataProto, rhs: StoryUserDataProto) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs._lastModifiedAt != rhs._lastModifiedAt {return false}
    if lhs.likeStatus != rhs.likeStatus {return false}
    if lhs.cardsData != rhs.cardsData {return false}
    if lhs._viewDuration != rhs._viewDuration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserDataProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserDataProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .standard(proto: "user_id"),
    4: .standard(proto: "created_at"),
    2: .standard(proto: "last_modified_at"),
    1: .standard(proto: "stories_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.storiesData) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._lastModifiedAt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.storiesData.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.storiesData, fieldNumber: 1)
    }
    try { if let v = self._lastModifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 3)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserDataProto, rhs: UserDataProto) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._lastModifiedAt != rhs._lastModifiedAt {return false}
    if lhs.storiesData != rhs.storiesData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
