// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: StoredPodcastProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum StoredPodcastStateProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case ready // = 1

  /// User created with prompt
  /// user_prompted -> (user selected points) input_ready
  case userPrompted // = 10

  /// Automatically suggested
  /// suggested -> suggested_points -> (user selected points) input_ready
  case suggested // = 20
  case suggestedPoints // = 21
  case inputReady // = 2
  case generationStarted // = 3
  case generationFailed // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ready
    case 2: self = .inputReady
    case 3: self = .generationStarted
    case 4: self = .generationFailed
    case 10: self = .userPrompted
    case 20: self = .suggested
    case 21: self = .suggestedPoints
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ready: return 1
    case .inputReady: return 2
    case .generationStarted: return 3
    case .generationFailed: return 4
    case .userPrompted: return 10
    case .suggested: return 20
    case .suggestedPoints: return 21
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastStateProto] = [
    .unknown,
    .ready,
    .userPrompted,
    .suggested,
    .suggestedPoints,
    .inputReady,
    .generationStarted,
    .generationFailed,
  ]

}

enum StoredPodcastSectionTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case introduction // = 1
  case section // = 2
  case conclusion // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .introduction
    case 2: self = .section
    case 3: self = .conclusion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .introduction: return 1
    case .section: return 2
    case .conclusion: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastSectionTypeProto] = [
    .unknown,
    .introduction,
    .section,
    .conclusion,
  ]

}

enum StoredPodcastImageStyleProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case storybook // = 1
  case digitalArtwork // = 2
  case oilPainting // = 3
  case japaneseAnimation // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .storybook
    case 2: self = .digitalArtwork
    case 3: self = .oilPainting
    case 4: self = .japaneseAnimation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .storybook: return 1
    case .digitalArtwork: return 2
    case .oilPainting: return 3
    case .japaneseAnimation: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastImageStyleProto] = [
    .undefined,
    .storybook,
    .digitalArtwork,
    .oilPainting,
    .japaneseAnimation,
  ]

}

enum StoredPodcastSuggestionsStateProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case created // = 4
  case generating // = 1
  case ready // = 2
  case failed // = 3
  case generatingContent // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .generating
    case 2: self = .ready
    case 3: self = .failed
    case 4: self = .created
    case 5: self = .generatingContent
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .generating: return 1
    case .ready: return 2
    case .failed: return 3
    case .created: return 4
    case .generatingContent: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastSuggestionsStateProto] = [
    .undefined,
    .created,
    .generating,
    .ready,
    .failed,
    .generatingContent,
  ]

}

enum StoredPodcastGenerationStateProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case created // = 1
  case generating // = 2
  case ready // = 3
  case failed // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .created
    case 2: self = .generating
    case 3: self = .ready
    case 4: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .created: return 1
    case .generating: return 2
    case .ready: return 3
    case .failed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastGenerationStateProto] = [
    .undefined,
    .created,
    .generating,
    .ready,
    .failed,
  ]

}

enum StoredPodcastStoryStateProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case inputReady // = 1
  case generating // = 2
  case ready // = 3
  case failed // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .inputReady
    case 2: self = .generating
    case 3: self = .ready
    case 4: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .inputReady: return 1
    case .generating: return 2
    case .ready: return 3
    case .failed: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastStoryStateProto] = [
    .undefined,
    .inputReady,
    .generating,
    .ready,
    .failed,
  ]

}

enum StoredPodcastTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case explainer // = 1
  case exercise // = 2
  case meditation // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .explainer
    case 2: self = .exercise
    case 3: self = .meditation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .explainer: return 1
    case .exercise: return 2
    case .meditation: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastTypeProto] = [
    .undefined,
    .explainer,
    .exercise,
    .meditation,
  ]

}

enum StoredPodcastSubscriptionSourceProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case internalUser // = 1
  case appstore // = 2
  case playstore // = 3
  case web // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .internalUser
    case 2: self = .appstore
    case 3: self = .playstore
    case 4: self = .web
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .internalUser: return 1
    case .appstore: return 2
    case .playstore: return 3
    case .web: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastSubscriptionSourceProto] = [
    .undefined,
    .internalUser,
    .appstore,
    .playstore,
    .web,
  ]

}

enum StoredPodcastUserInterfaceStyleProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case light // = 1
  case dark // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .light
    case 2: self = .dark
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .light: return 1
    case .dark: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastUserInterfaceStyleProto] = [
    .undefined,
    .light,
    .dark,
  ]

}

enum StoredPodcastContentSizeCategoryProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case xSmall // = 1
  case small // = 2
  case medium // = 3
  case large // = 4
  case xLarge // = 5
  case xxLarge // = 6
  case xxxLarge // = 7
  case accessibilityMedium // = 8
  case accessibilityLarge // = 9
  case accessibilityXLarge // = 10
  case accessibilityXxLarge // = 11
  case accessibilityXxxLarge // = 12
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .xSmall
    case 2: self = .small
    case 3: self = .medium
    case 4: self = .large
    case 5: self = .xLarge
    case 6: self = .xxLarge
    case 7: self = .xxxLarge
    case 8: self = .accessibilityMedium
    case 9: self = .accessibilityLarge
    case 10: self = .accessibilityXLarge
    case 11: self = .accessibilityXxLarge
    case 12: self = .accessibilityXxxLarge
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .xSmall: return 1
    case .small: return 2
    case .medium: return 3
    case .large: return 4
    case .xLarge: return 5
    case .xxLarge: return 6
    case .xxxLarge: return 7
    case .accessibilityMedium: return 8
    case .accessibilityLarge: return 9
    case .accessibilityXLarge: return 10
    case .accessibilityXxLarge: return 11
    case .accessibilityXxxLarge: return 12
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [StoredPodcastContentSizeCategoryProto] = [
    .undefined,
    .xSmall,
    .small,
    .medium,
    .large,
    .xLarge,
    .xxLarge,
    .xxxLarge,
    .accessibilityMedium,
    .accessibilityLarge,
    .accessibilityXLarge,
    .accessibilityXxLarge,
    .accessibilityXxxLarge,
  ]

}

struct StoredPodcastProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String {
    get {return _storage._podcastID}
    set {_uniqueStorage()._podcastID = newValue}
  }

  var createdBy: String {
    get {return _storage._createdBy}
    set {_uniqueStorage()._createdBy = newValue}
  }

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  var deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deletedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deletedAt = newValue}
  }
  /// Returns true if `deletedAt` has been explicitly set.
  var hasDeletedAt: Bool {return _storage._deletedAt != nil}
  /// Clears the value of `deletedAt`. Subsequent reads from it will return its default value.
  mutating func clearDeletedAt() {_uniqueStorage()._deletedAt = nil}

  var userInput: StoredPodcastUserInputProto {
    get {return _storage._userInput ?? StoredPodcastUserInputProto()}
    set {_uniqueStorage()._userInput = newValue}
  }
  /// Returns true if `userInput` has been explicitly set.
  var hasUserInput: Bool {return _storage._userInput != nil}
  /// Clears the value of `userInput`. Subsequent reads from it will return its default value.
  mutating func clearUserInput() {_uniqueStorage()._userInput = nil}

  var suggestionInput: StoredPodcastSuggestionInputProto {
    get {return _storage._suggestionInput ?? StoredPodcastSuggestionInputProto()}
    set {_uniqueStorage()._suggestionInput = newValue}
  }
  /// Returns true if `suggestionInput` has been explicitly set.
  var hasSuggestionInput: Bool {return _storage._suggestionInput != nil}
  /// Clears the value of `suggestionInput`. Subsequent reads from it will return its default value.
  mutating func clearSuggestionInput() {_uniqueStorage()._suggestionInput = nil}

  var state: StoredPodcastStateProto {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var answer: PodcastPromptAnswerProto {
    get {return _storage._answer ?? PodcastPromptAnswerProto()}
    set {_uniqueStorage()._answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  var hasAnswer: Bool {return _storage._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  mutating func clearAnswer() {_uniqueStorage()._answer = nil}

  var points: StoredPodcastPointsProto {
    get {return _storage._points ?? StoredPodcastPointsProto()}
    set {_uniqueStorage()._points = newValue}
  }
  /// Returns true if `points` has been explicitly set.
  var hasPoints: Bool {return _storage._points != nil}
  /// Clears the value of `points`. Subsequent reads from it will return its default value.
  mutating func clearPoints() {_uniqueStorage()._points = nil}

  var plan: StoredPodcastPlanProto {
    get {return _storage._plan ?? StoredPodcastPlanProto()}
    set {_uniqueStorage()._plan = newValue}
  }
  /// Returns true if `plan` has been explicitly set.
  var hasPlan: Bool {return _storage._plan != nil}
  /// Clears the value of `plan`. Subsequent reads from it will return its default value.
  mutating func clearPlan() {_uniqueStorage()._plan = nil}

  var transcript: StoredPodcastTranscriptProto {
    get {return _storage._transcript ?? StoredPodcastTranscriptProto()}
    set {_uniqueStorage()._transcript = newValue}
  }
  /// Returns true if `transcript` has been explicitly set.
  var hasTranscript: Bool {return _storage._transcript != nil}
  /// Clears the value of `transcript`. Subsequent reads from it will return its default value.
  mutating func clearTranscript() {_uniqueStorage()._transcript = nil}

  var audio: StoredPodcastAudioProto {
    get {return _storage._audio ?? StoredPodcastAudioProto()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  mutating func clearAudio() {_uniqueStorage()._audio = nil}

  var visuals: StoredPodcastVisualsProto {
    get {return _storage._visuals ?? StoredPodcastVisualsProto()}
    set {_uniqueStorage()._visuals = newValue}
  }
  /// Returns true if `visuals` has been explicitly set.
  var hasVisuals: Bool {return _storage._visuals != nil}
  /// Clears the value of `visuals`. Subsequent reads from it will return its default value.
  mutating func clearVisuals() {_uniqueStorage()._visuals = nil}

  var keyPoints: StoredPodcastKeyPointsProto {
    get {return _storage._keyPoints ?? StoredPodcastKeyPointsProto()}
    set {_uniqueStorage()._keyPoints = newValue}
  }
  /// Returns true if `keyPoints` has been explicitly set.
  var hasKeyPoints: Bool {return _storage._keyPoints != nil}
  /// Clears the value of `keyPoints`. Subsequent reads from it will return its default value.
  mutating func clearKeyPoints() {_uniqueStorage()._keyPoints = nil}

  var followups: StoredPodcastFollowupsProto {
    get {return _storage._followups ?? StoredPodcastFollowupsProto()}
    set {_uniqueStorage()._followups = newValue}
  }
  /// Returns true if `followups` has been explicitly set.
  var hasFollowups: Bool {return _storage._followups != nil}
  /// Clears the value of `followups`. Subsequent reads from it will return its default value.
  mutating func clearFollowups() {_uniqueStorage()._followups = nil}

  var podcastType: StoredPodcastTypeProto {
    get {return _storage._podcastType}
    set {_uniqueStorage()._podcastType = newValue}
  }

  var exercise: StoredPodcastExerciseProto {
    get {return _storage._exercise ?? StoredPodcastExerciseProto()}
    set {_uniqueStorage()._exercise = newValue}
  }
  /// Returns true if `exercise` has been explicitly set.
  var hasExercise: Bool {return _storage._exercise != nil}
  /// Clears the value of `exercise`. Subsequent reads from it will return its default value.
  mutating func clearExercise() {_uniqueStorage()._exercise = nil}

  var completion: StoredPodcastCompletionProto {
    get {return _storage._completion ?? StoredPodcastCompletionProto()}
    set {_uniqueStorage()._completion = newValue}
  }
  /// Returns true if `completion` has been explicitly set.
  var hasCompletion: Bool {return _storage._completion != nil}
  /// Clears the value of `completion`. Subsequent reads from it will return its default value.
  mutating func clearCompletion() {_uniqueStorage()._completion = nil}

  var log: LogProto {
    get {return _storage._log ?? LogProto()}
    set {_uniqueStorage()._log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {return _storage._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {_uniqueStorage()._log = nil}

  var llmRequestIds: Dictionary<String,String> {
    get {return _storage._llmRequestIds}
    set {_uniqueStorage()._llmRequestIds = newValue}
  }

  var generationJob: StoredPodcastGenerationJobProto {
    get {return _storage._generationJob ?? StoredPodcastGenerationJobProto()}
    set {_uniqueStorage()._generationJob = newValue}
  }
  /// Returns true if `generationJob` has been explicitly set.
  var hasGenerationJob: Bool {return _storage._generationJob != nil}
  /// Clears the value of `generationJob`. Subsequent reads from it will return its default value.
  mutating func clearGenerationJob() {_uniqueStorage()._generationJob = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StoredPodcastGenerationJobProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var jobID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastUserInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prompt: String = String()

  var pointIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSuggestionInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestionsID: String = String()

  var title: String = String()

  /// passed further into generation prompts
  var thumbnailPrompt: String = String()

  var type: StoredPodcastSuggestionInputProto.OneOf_Type? = nil

  var suggestionSection: StoredPodcastSuggestionFromSectionInputProto {
    get {
      if case .suggestionSection(let v)? = type {return v}
      return StoredPodcastSuggestionFromSectionInputProto()
    }
    set {type = .suggestionSection(newValue)}
  }

  var routineStep: StoredPodcastSuggestionFromRoutineStepInputProto {
    get {
      if case .routineStep(let v)? = type {return v}
      return StoredPodcastSuggestionFromRoutineStepInputProto()
    }
    set {type = .routineStep(newValue)}
  }

  var followup: StoredPodcastSuggestionFromFollowupInputProto {
    get {
      if case .followup(let v)? = type {return v}
      return StoredPodcastSuggestionFromFollowupInputProto()
    }
    set {type = .followup(newValue)}
  }

  var suggestionPoints: StoredPodcastPointsProto {
    get {return _suggestionPoints ?? StoredPodcastPointsProto()}
    set {_suggestionPoints = newValue}
  }
  /// Returns true if `suggestionPoints` has been explicitly set.
  var hasSuggestionPoints: Bool {return self._suggestionPoints != nil}
  /// Clears the value of `suggestionPoints`. Subsequent reads from it will return its default value.
  mutating func clearSuggestionPoints() {self._suggestionPoints = nil}

  var userInput: StoredPodcastSuggestionUserInputProto {
    get {return _userInput ?? StoredPodcastSuggestionUserInputProto()}
    set {_userInput = newValue}
  }
  /// Returns true if `userInput` has been explicitly set.
  var hasUserInput: Bool {return self._userInput != nil}
  /// Clears the value of `userInput`. Subsequent reads from it will return its default value.
  mutating func clearUserInput() {self._userInput = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case suggestionSection(StoredPodcastSuggestionFromSectionInputProto)
    case routineStep(StoredPodcastSuggestionFromRoutineStepInputProto)
    case followup(StoredPodcastSuggestionFromFollowupInputProto)

  }

  init() {}

  fileprivate var _suggestionPoints: StoredPodcastPointsProto? = nil
  fileprivate var _userInput: StoredPodcastSuggestionUserInputProto? = nil
}

struct StoredPodcastSuggestionFromSectionInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestionSectionID: String = String()

  var suggestionSectionReasoning: String = String()

  var badge: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSuggestionFromRoutineStepInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routineID: String = String()

  var routineReasoning: String = String()

  var stepOutline: String = String()

  var stepTags: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSuggestionFromFollowupInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sourcePodcastID: String = String()

  var sourcePodcastTitle: String = String()

  var sourcePodcastPlan: String = String()

  var followupReasoning: String = String()

  var followupEmoji: String = String()

  var followupOutline: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSuggestionUserInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pointIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastPointsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var points: [StoredPodcastPointProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastPointProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pointID: String = String()

  var reasoning: String = String()

  var title: String = String()

  var titleEmoji: String = String()

  var outline: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastPlanProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var plan: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastTranscriptProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sections: [StoredPodcastSectionTranscriptProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSectionTranscriptProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sectionType: StoredPodcastSectionTypeProto = .unknown

  var entries: [StoredPodcastTranscriptEntryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastTranscriptEntryProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var host: PodcastHostProto = .unknown

  var text: String = String()

  var startMillis: Int32 = 0

  var endMillis: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastStyleProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageStyle: StoredPodcastImageStyleProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastVisualsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var style: StoredPodcastStyleProto {
    get {return _style ?? StoredPodcastStyleProto()}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var thumbnailPrompt: String = String()

  var thumbnailKey: String = String()

  var visuals: [StoredPodcastVisualProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _style: StoredPodcastStyleProto? = nil
}

struct StoredPodcastVisualProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestampMillis: Int32 = 0

  var imagePrompt: String = String()

  var imageKey: String = String()

  var transition: PodcastVisualTransitionProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastAudioProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var audioKey: String = String()

  var audioDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _audioDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_audioDuration = newValue}
  }
  /// Returns true if `audioDuration` has been explicitly set.
  var hasAudioDuration: Bool {return self._audioDuration != nil}
  /// Clears the value of `audioDuration`. Subsequent reads from it will return its default value.
  mutating func clearAudioDuration() {self._audioDuration = nil}

  var words: [PodcastWordProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _audioDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct StoredPodcastKeyPointsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var keyPoints: [StoredPodcastKeyPointProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastFollowupsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var followups: [StoredPodcastFollowupProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastFollowupProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var followupPodcastID: String = String()

  var reasoning: String = String()

  var emoji: String = String()

  var outline: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastKeyPointProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyPointID: String = String()

  var title: String = String()

  var titleEmoji: String = String()

  var outline: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastCompletionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "Mark Complete"
  var action: String = String()

  /// "Excellent!"
  var encouragement: String = String()

  /// "⚡", "💎"
  var emoji: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSuggestionsProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestionsID: String {
    get {return _storage._suggestionsID}
    set {_uniqueStorage()._suggestionsID = newValue}
  }

  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var state: StoredPodcastSuggestionsStateProto {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  var reasoning: String {
    get {return _storage._reasoning}
    set {_uniqueStorage()._reasoning = newValue}
  }

  var ranking: String {
    get {return _storage._ranking}
    set {_uniqueStorage()._ranking = newValue}
  }

  var sections: [StoredPodcastSuggestionsSectionProto] {
    get {return _storage._sections}
    set {_uniqueStorage()._sections = newValue}
  }

  var routine: StoredPodcastRoutineProto {
    get {return _storage._routine ?? StoredPodcastRoutineProto()}
    set {_uniqueStorage()._routine = newValue}
  }
  /// Returns true if `routine` has been explicitly set.
  var hasRoutine: Bool {return _storage._routine != nil}
  /// Clears the value of `routine`. Subsequent reads from it will return its default value.
  mutating func clearRoutine() {_uniqueStorage()._routine = nil}

  var log: LogProto {
    get {return _storage._log ?? LogProto()}
    set {_uniqueStorage()._log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {return _storage._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {_uniqueStorage()._log = nil}

  var llmRequestIds: Dictionary<String,String> {
    get {return _storage._llmRequestIds}
    set {_uniqueStorage()._llmRequestIds = newValue}
  }

  var generationJob: StoredPodcastGenerationJobProto {
    get {return _storage._generationJob ?? StoredPodcastGenerationJobProto()}
    set {_uniqueStorage()._generationJob = newValue}
  }
  /// Returns true if `generationJob` has been explicitly set.
  var hasGenerationJob: Bool {return _storage._generationJob != nil}
  /// Clears the value of `generationJob`. Subsequent reads from it will return its default value.
  mutating func clearGenerationJob() {_uniqueStorage()._generationJob = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StoredPodcastSuggestionsSectionProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// e.g. "do-right-now"
  var sectionID: String {
    get {return _storage._sectionID}
    set {_uniqueStorage()._sectionID = newValue}
  }

  var reasoning: String {
    get {return _storage._reasoning}
    set {_uniqueStorage()._reasoning = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var style: StoredPodcastStyleProto {
    get {return _storage._style ?? StoredPodcastStyleProto()}
    set {_uniqueStorage()._style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return _storage._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {_uniqueStorage()._style = nil}

  var bannerSuggestion: StoredPodcastSuggestionProto {
    get {return _storage._bannerSuggestion ?? StoredPodcastSuggestionProto()}
    set {_uniqueStorage()._bannerSuggestion = newValue}
  }
  /// Returns true if `bannerSuggestion` has been explicitly set.
  var hasBannerSuggestion: Bool {return _storage._bannerSuggestion != nil}
  /// Clears the value of `bannerSuggestion`. Subsequent reads from it will return its default value.
  mutating func clearBannerSuggestion() {_uniqueStorage()._bannerSuggestion = nil}

  var footerSuggestion: StoredPodcastSuggestionProto {
    get {return _storage._footerSuggestion ?? StoredPodcastSuggestionProto()}
    set {_uniqueStorage()._footerSuggestion = newValue}
  }
  /// Returns true if `footerSuggestion` has been explicitly set.
  var hasFooterSuggestion: Bool {return _storage._footerSuggestion != nil}
  /// Clears the value of `footerSuggestion`. Subsequent reads from it will return its default value.
  mutating func clearFooterSuggestion() {_uniqueStorage()._footerSuggestion = nil}

  var story1: StoredPodcastStorySuggestionProto {
    get {return _storage._story1 ?? StoredPodcastStorySuggestionProto()}
    set {_uniqueStorage()._story1 = newValue}
  }
  /// Returns true if `story1` has been explicitly set.
  var hasStory1: Bool {return _storage._story1 != nil}
  /// Clears the value of `story1`. Subsequent reads from it will return its default value.
  mutating func clearStory1() {_uniqueStorage()._story1 = nil}

  var story2: StoredPodcastStorySuggestionProto {
    get {return _storage._story2 ?? StoredPodcastStorySuggestionProto()}
    set {_uniqueStorage()._story2 = newValue}
  }
  /// Returns true if `story2` has been explicitly set.
  var hasStory2: Bool {return _storage._story2 != nil}
  /// Clears the value of `story2`. Subsequent reads from it will return its default value.
  mutating func clearStory2() {_uniqueStorage()._story2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StoredPodcastSuggestionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestedPodcastID: String = String()

  var title: String = String()

  /// Q&A, Explainer, ...
  var badge: String = String()

  var thumbnailPrompt: String = String()

  var thumbnailKey: String = String()

  var generationState: StoredPodcastGenerationStateProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastStorySuggestionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestionsID: String = String()

  var suggestedStoryID: String = String()

  var title: String = String()

  var thumbnailPrompt: String = String()

  var thumbnailKey: String = String()

  var generationState: StoredPodcastGenerationStateProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastStoryProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storyID: String {
    get {return _storage._storyID}
    set {_uniqueStorage()._storyID = newValue}
  }

  var userID: String {
    get {return _storage._userID}
    set {_uniqueStorage()._userID = newValue}
  }

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  var deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._deletedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._deletedAt = newValue}
  }
  /// Returns true if `deletedAt` has been explicitly set.
  var hasDeletedAt: Bool {return _storage._deletedAt != nil}
  /// Clears the value of `deletedAt`. Subsequent reads from it will return its default value.
  mutating func clearDeletedAt() {_uniqueStorage()._deletedAt = nil}

  var state: StoredPodcastStoryStateProto {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var input: StoredPodcastStoryInputProto {
    get {return _storage._input ?? StoredPodcastStoryInputProto()}
    set {_uniqueStorage()._input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return _storage._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {_uniqueStorage()._input = nil}

  var slides: StoredPodcastStorySlidesProto {
    get {return _storage._slides ?? StoredPodcastStorySlidesProto()}
    set {_uniqueStorage()._slides = newValue}
  }
  /// Returns true if `slides` has been explicitly set.
  var hasSlides: Bool {return _storage._slides != nil}
  /// Clears the value of `slides`. Subsequent reads from it will return its default value.
  mutating func clearSlides() {_uniqueStorage()._slides = nil}

  /// Debug metadata
  var log: LogProto {
    get {return _storage._log ?? LogProto()}
    set {_uniqueStorage()._log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {return _storage._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {_uniqueStorage()._log = nil}

  var llmRequestIds: Dictionary<String,String> {
    get {return _storage._llmRequestIds}
    set {_uniqueStorage()._llmRequestIds = newValue}
  }

  var generationJob: StoredPodcastGenerationJobProto {
    get {return _storage._generationJob ?? StoredPodcastGenerationJobProto()}
    set {_uniqueStorage()._generationJob = newValue}
  }
  /// Returns true if `generationJob` has been explicitly set.
  var hasGenerationJob: Bool {return _storage._generationJob != nil}
  /// Clears the value of `generationJob`. Subsequent reads from it will return its default value.
  mutating func clearGenerationJob() {_uniqueStorage()._generationJob = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StoredPodcastStoryInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: StoredPodcastStoryInputProto.OneOf_Type? = nil

  var suggestion: StoredPodcastStorySuggestionInputProto {
    get {
      if case .suggestion(let v)? = type {return v}
      return StoredPodcastStorySuggestionInputProto()
    }
    set {type = .suggestion(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case suggestion(StoredPodcastStorySuggestionInputProto)

  }

  init() {}
}

struct StoredPodcastStorySuggestionInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestionSectionID: String = String()

  var suggestionSectionReasoning: String = String()

  var suggestionTitle: String = String()

  var suggestionStyle: StoredPodcastStyleProto {
    get {return _suggestionStyle ?? StoredPodcastStyleProto()}
    set {_suggestionStyle = newValue}
  }
  /// Returns true if `suggestionStyle` has been explicitly set.
  var hasSuggestionStyle: Bool {return self._suggestionStyle != nil}
  /// Clears the value of `suggestionStyle`. Subsequent reads from it will return its default value.
  mutating func clearSuggestionStyle() {self._suggestionStyle = nil}

  var suggestionThumbnailPrompt: String = String()

  var suggestionThumbnailKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _suggestionStyle: StoredPodcastStyleProto? = nil
}

struct StoredPodcastStorySlidesProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isReady: Bool = false

  var reasoning: String = String()

  var structure: String = String()

  var slides: [StoredPodcastStorySlideProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastStorySlideProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideID: String = String()

  var isTextReady: Bool = false

  var title: String = String()

  var imagePrompt: String = String()

  var text: String = String()

  var imageKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastRoutineProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routineID: String = String()

  var reasoning: String = String()

  var segments: [StoredPodcastRoutineSegmentProto] = []

  var style: StoredPodcastStyleProto {
    get {return _style ?? StoredPodcastStyleProto()}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  /// string thumbnail_prompt = 5;
  /// string thumbnail_key = 6;
  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _style: StoredPodcastStyleProto? = nil
}

struct StoredPodcastRoutineSegmentProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var segmentID: String = String()

  var segmentLabel: String = String()

  var reasoning: String = String()

  var title: String = String()

  var steps: [StoredPodcastRoutineStepProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastRoutineStepProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var type: StoredPodcastTypeProto = .undefined

  var title: String = String()

  var outline: String = String()

  var tags: [String] = []

  var thumbnailPrompt: String = String()

  var thumbnailKey: String = String()

  var generationState: StoredPodcastGenerationStateProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastExerciseProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var plan: StoredPodcastExercisePlanProto {
    get {return _plan ?? StoredPodcastExercisePlanProto()}
    set {_plan = newValue}
  }
  /// Returns true if `plan` has been explicitly set.
  var hasPlan: Bool {return self._plan != nil}
  /// Clears the value of `plan`. Subsequent reads from it will return its default value.
  mutating func clearPlan() {self._plan = nil}

  var sections: [StoredPodcastExerciseSectionProto] = []

  var style: StoredPodcastStyleProto {
    get {return _style ?? StoredPodcastStyleProto()}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _plan: StoredPodcastExercisePlanProto? = nil
  fileprivate var _style: StoredPodcastStyleProto? = nil
}

struct StoredPodcastExercisePlanProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var ideas: String = String()

  var reasoning: String = String()

  var selectedCategory: String = String()

  var sections: [StoredPodcastExerciseSectionPlanProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastExerciseSectionPlanProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var plan: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastExerciseSectionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var segments: [StoredPodcastExerciseSegmentProto] = []

  var background: StoredPodcastExerciseSectionBackgroundProto {
    get {return _background ?? StoredPodcastExerciseSectionBackgroundProto()}
    set {_background = newValue}
  }
  /// Returns true if `background` has been explicitly set.
  var hasBackground: Bool {return self._background != nil}
  /// Clears the value of `background`. Subsequent reads from it will return its default value.
  mutating func clearBackground() {self._background = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _background: StoredPodcastExerciseSectionBackgroundProto? = nil
}

struct StoredPodcastExerciseSegmentProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: StoredPodcastExerciseSegmentProto.OneOf_Type? = nil

  var spokenSegment: StoredPodcastSpokenSegmentProto {
    get {
      if case .spokenSegment(let v)? = type {return v}
      return StoredPodcastSpokenSegmentProto()
    }
    set {type = .spokenSegment(newValue)}
  }

  var reps: StoredPodcastExerciseVisualRepsProto {
    get {
      if case .reps(let v)? = type {return v}
      return StoredPodcastExerciseVisualRepsProto()
    }
    set {type = .reps(newValue)}
  }

  var text: StoredPodcastExerciseVisualTextProto {
    get {
      if case .text(let v)? = type {return v}
      return StoredPodcastExerciseVisualTextProto()
    }
    set {type = .text(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case spokenSegment(StoredPodcastSpokenSegmentProto)
    case reps(StoredPodcastExerciseVisualRepsProto)
    case text(StoredPodcastExerciseVisualTextProto)

  }

  init() {}
}

struct StoredPodcastExerciseSectionBackgroundProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imagePrompt: String = String()

  var imageKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSpokenSegmentProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var leadingPause: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _leadingPause ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_leadingPause = newValue}
  }
  /// Returns true if `leadingPause` has been explicitly set.
  var hasLeadingPause: Bool {return self._leadingPause != nil}
  /// Clears the value of `leadingPause`. Subsequent reads from it will return its default value.
  mutating func clearLeadingPause() {self._leadingPause = nil}

  var minDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _minDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_minDuration = newValue}
  }
  /// Returns true if `minDuration` has been explicitly set.
  var hasMinDuration: Bool {return self._minDuration != nil}
  /// Clears the value of `minDuration`. Subsequent reads from it will return its default value.
  mutating func clearMinDuration() {self._minDuration = nil}

  var timing: StoredPodcastSpokenSegmentTimingProto {
    get {return _timing ?? StoredPodcastSpokenSegmentTimingProto()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  mutating func clearTiming() {self._timing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leadingPause: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _minDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _timing: StoredPodcastSpokenSegmentTimingProto? = nil
}

struct StoredPodcastSpokenSegmentTimingProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startMillis: Int32 = 0

  var endMillis: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastExerciseVisualTextProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastExerciseVisualRepsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: StoredPodcastExerciseVisualRepsProto.OneOf_Type? = nil

  var marker: StoredPodcastExerciseVisualRepsMarkerProto {
    get {
      if case .marker(let v)? = type {return v}
      return StoredPodcastExerciseVisualRepsMarkerProto()
    }
    set {type = .marker(newValue)}
  }

  var counter: StoredPodcastExerciseVisualRepsCounterProto {
    get {
      if case .counter(let v)? = type {return v}
      return StoredPodcastExerciseVisualRepsCounterProto()
    }
    set {type = .counter(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case marker(StoredPodcastExerciseVisualRepsMarkerProto)
    case counter(StoredPodcastExerciseVisualRepsCounterProto)

  }

  init() {}
}

struct StoredPodcastExerciseVisualRepsMarkerProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: StoredPodcastExerciseVisualRepsMarkerProto.TypeEnum = .undefined

  var repTotal: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
    typealias RawValue = Int
    case undefined // = 0
    case start // = 1
    case end // = 2
    case counter // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .undefined
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .undefined
      case 1: self = .start
      case 2: self = .end
      case 3: self = .counter
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .undefined: return 0
      case .start: return 1
      case .end: return 2
      case .counter: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

    // The compiler won't synthesize support with the UNRECOGNIZED case.
    static let allCases: [StoredPodcastExerciseVisualRepsMarkerProto.TypeEnum] = [
      .undefined,
      .start,
      .end,
      .counter,
    ]

  }

  init() {}
}

struct StoredPodcastExerciseVisualRepsCounterProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var repNumber: Int32 = 0

  var repTotal: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastUserProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _deletedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_deletedAt = newValue}
  }
  /// Returns true if `deletedAt` has been explicitly set.
  var hasDeletedAt: Bool {return self._deletedAt != nil}
  /// Clears the value of `deletedAt`. Subsequent reads from it will return its default value.
  mutating func clearDeletedAt() {self._deletedAt = nil}

  var onboardingInput: StoredPodcastOnboardingInputProto {
    get {return _onboardingInput ?? StoredPodcastOnboardingInputProto()}
    set {_onboardingInput = newValue}
  }
  /// Returns true if `onboardingInput` has been explicitly set.
  var hasOnboardingInput: Bool {return self._onboardingInput != nil}
  /// Clears the value of `onboardingInput`. Subsequent reads from it will return its default value.
  mutating func clearOnboardingInput() {self._onboardingInput = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _onboardingInput: StoredPodcastOnboardingInputProto? = nil
}

struct StoredPodcastOnboardingInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var name: String = String()

  var goalIds: [String] = []

  var learningStyleIds: [String] = []

  var interestIds: [String] = []

  var voiceID: String = String()

  var userAgent: StoredPodcastUserAgentProto {
    get {return _userAgent ?? StoredPodcastUserAgentProto()}
    set {_userAgent = newValue}
  }
  /// Returns true if `userAgent` has been explicitly set.
  var hasUserAgent: Bool {return self._userAgent != nil}
  /// Clears the value of `userAgent`. Subsequent reads from it will return its default value.
  mutating func clearUserAgent() {self._userAgent = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _userAgent: StoredPodcastUserAgentProto? = nil
}

struct StoredPodcastUserAgentProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userAgent: String {
    get {return _storage._userAgent}
    set {_uniqueStorage()._userAgent = newValue}
  }

  var device: StoredPodcastDeviceProto {
    get {return _storage._device ?? StoredPodcastDeviceProto()}
    set {_uniqueStorage()._device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return _storage._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {_uniqueStorage()._device = nil}

  var locale: StoredPodcastLocaleProto {
    get {return _storage._locale ?? StoredPodcastLocaleProto()}
    set {_uniqueStorage()._locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  var hasLocale: Bool {return _storage._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  mutating func clearLocale() {_uniqueStorage()._locale = nil}

  var location: StoredPodcastLocationProto {
    get {return _storage._location ?? StoredPodcastLocationProto()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var userInterfaceStyle: StoredPodcastUserInterfaceStyleProto {
    get {return _storage._userInterfaceStyle}
    set {_uniqueStorage()._userInterfaceStyle = newValue}
  }

  var accessibilitySettings: StoredPodcastAccessibilitySettingsProto {
    get {return _storage._accessibilitySettings ?? StoredPodcastAccessibilitySettingsProto()}
    set {_uniqueStorage()._accessibilitySettings = newValue}
  }
  /// Returns true if `accessibilitySettings` has been explicitly set.
  var hasAccessibilitySettings: Bool {return _storage._accessibilitySettings != nil}
  /// Clears the value of `accessibilitySettings`. Subsequent reads from it will return its default value.
  mutating func clearAccessibilitySettings() {_uniqueStorage()._accessibilitySettings = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StoredPodcastAccessibilitySettingsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var contentSizeCategory: StoredPodcastContentSizeCategoryProto = .undefined

  var boldText: Bool = false

  var increaseContrast: Bool = false

  var reduceTransparency: Bool = false

  var reduceMotion: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastLocaleProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var language: String = String()

  var region: String = String()

  var timeZone: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastLocationProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var regionCode: String = String()

  var country: String = String()

  var city: String = String()

  var timeZone: String = String()

  var latitude: Double = 0

  var longitude: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastDeviceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: StoredPodcastDeviceProto.OneOf_Type? = nil

  var ios: StoredPodcastIOSDeviceProto {
    get {
      if case .ios(let v)? = type {return v}
      return StoredPodcastIOSDeviceProto()
    }
    set {type = .ios(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case ios(StoredPodcastIOSDeviceProto)

  }

  init() {}
}

struct StoredPodcastIOSDeviceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceModel: String = String()

  var deviceIdentifier: String = String()

  var isSimulator: Bool = false

  var osName: String = String()

  var osVersion: String = String()

  var appBundleName: String = String()

  var appBundleVersion: String = String()

  var appBuildNumber: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension StoredPodcastStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_STATE_PROTO_UNKNOWN"),
    1: .same(proto: "STORED_PODCAST_STATE_PROTO_READY"),
    2: .same(proto: "STORED_PODCAST_STATE_PROTO_INPUT_READY"),
    3: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATION_STARTED"),
    4: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATION_FAILED"),
    10: .same(proto: "STORED_PODCAST_STATE_PROTO_USER_PROMPTED"),
    20: .same(proto: "STORED_PODCAST_STATE_PROTO_SUGGESTED"),
    21: .same(proto: "STORED_PODCAST_STATE_PROTO_SUGGESTED_POINTS"),
  ]
}

extension StoredPodcastSectionTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_UNKNOWN"),
    1: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_INTRODUCTION"),
    2: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_SECTION"),
    3: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_CONCLUSION"),
  ]
}

extension StoredPodcastImageStyleProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_IMAGE_STYLE_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_IMAGE_STYLE_PROTO_STORYBOOK"),
    2: .same(proto: "STORED_PODCAST_IMAGE_STYLE_PROTO_DIGITAL_ARTWORK"),
    3: .same(proto: "STORED_PODCAST_IMAGE_STYLE_PROTO_OIL_PAINTING"),
    4: .same(proto: "STORED_PODCAST_IMAGE_STYLE_PROTO_JAPANESE_ANIMATION"),
  ]
}

extension StoredPodcastSuggestionsStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_SUGGESTIONS_STATE_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_SUGGESTIONS_STATE_PROTO_GENERATING"),
    2: .same(proto: "STORED_PODCAST_SUGGESTIONS_STATE_PROTO_READY"),
    3: .same(proto: "STORED_PODCAST_SUGGESTIONS_STATE_PROTO_FAILED"),
    4: .same(proto: "STORED_PODCAST_SUGGESTIONS_STATE_PROTO_CREATED"),
    5: .same(proto: "STORED_PODCAST_SUGGESTIONS_STATE_PROTO_GENERATING_CONTENT"),
  ]
}

extension StoredPodcastGenerationStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_GENERATION_STATE_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_GENERATION_STATE_PROTO_CREATED"),
    2: .same(proto: "STORED_PODCAST_GENERATION_STATE_PROTO_GENERATING"),
    3: .same(proto: "STORED_PODCAST_GENERATION_STATE_PROTO_READY"),
    4: .same(proto: "STORED_PODCAST_GENERATION_STATE_PROTO_FAILED"),
  ]
}

extension StoredPodcastStoryStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_STORY_STATE_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_STORY_STATE_PROTO_INPUT_READY"),
    2: .same(proto: "STORED_PODCAST_STORY_STATE_PROTO_GENERATING"),
    3: .same(proto: "STORED_PODCAST_STORY_STATE_PROTO_READY"),
    4: .same(proto: "STORED_PODCAST_STORY_STATE_PROTO_FAILED"),
  ]
}

extension StoredPodcastTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_TYPE_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_TYPE_PROTO_EXPLAINER"),
    2: .same(proto: "STORED_PODCAST_TYPE_PROTO_EXERCISE"),
    3: .same(proto: "STORED_PODCAST_TYPE_PROTO_MEDITATION"),
  ]
}

extension StoredPodcastSubscriptionSourceProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_SUBSCRIPTION_SOURCE_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_SUBSCRIPTION_SOURCE_PROTO_INTERNAL_USER"),
    2: .same(proto: "STORED_PODCAST_SUBSCRIPTION_SOURCE_PROTO_APPSTORE"),
    3: .same(proto: "STORED_PODCAST_SUBSCRIPTION_SOURCE_PROTO_PLAYSTORE"),
    4: .same(proto: "STORED_PODCAST_SUBSCRIPTION_SOURCE_PROTO_WEB"),
  ]
}

extension StoredPodcastUserInterfaceStyleProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_USER_INTERFACE_STYLE_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_USER_INTERFACE_STYLE_PROTO_LIGHT"),
    2: .same(proto: "STORED_PODCAST_USER_INTERFACE_STYLE_PROTO_DARK"),
  ]
}

extension StoredPodcastContentSizeCategoryProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_UNDEFINED"),
    1: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_X_SMALL"),
    2: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_SMALL"),
    3: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_MEDIUM"),
    4: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_LARGE"),
    5: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_X_LARGE"),
    6: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_XX_LARGE"),
    7: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_XXX_LARGE"),
    8: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_ACCESSIBILITY_MEDIUM"),
    9: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_ACCESSIBILITY_LARGE"),
    10: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_ACCESSIBILITY_X_LARGE"),
    11: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_ACCESSIBILITY_XX_LARGE"),
    12: .same(proto: "STORED_PODCAST_CONTENT_SIZE_CATEGORY_PROTO_ACCESSIBILITY_XXX_LARGE"),
  ]
}

extension StoredPodcastProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "created_by"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "updated_at"),
    16: .standard(proto: "deleted_at"),
    5: .standard(proto: "user_input"),
    15: .standard(proto: "suggestion_input"),
    6: .same(proto: "state"),
    7: .same(proto: "answer"),
    8: .same(proto: "points"),
    9: .same(proto: "plan"),
    10: .same(proto: "transcript"),
    11: .same(proto: "audio"),
    12: .same(proto: "visuals"),
    13: .standard(proto: "key_points"),
    14: .same(proto: "followups"),
    17: .standard(proto: "podcast_type"),
    18: .same(proto: "exercise"),
    19: .same(proto: "completion"),
    101: .same(proto: "log"),
    102: .standard(proto: "llm_request_ids"),
    103: .standard(proto: "generation_job"),
  ]

  fileprivate class _StorageClass {
    var _podcastID: String = String()
    var _createdBy: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _userInput: StoredPodcastUserInputProto? = nil
    var _suggestionInput: StoredPodcastSuggestionInputProto? = nil
    var _state: StoredPodcastStateProto = .unknown
    var _answer: PodcastPromptAnswerProto? = nil
    var _points: StoredPodcastPointsProto? = nil
    var _plan: StoredPodcastPlanProto? = nil
    var _transcript: StoredPodcastTranscriptProto? = nil
    var _audio: StoredPodcastAudioProto? = nil
    var _visuals: StoredPodcastVisualsProto? = nil
    var _keyPoints: StoredPodcastKeyPointsProto? = nil
    var _followups: StoredPodcastFollowupsProto? = nil
    var _podcastType: StoredPodcastTypeProto = .undefined
    var _exercise: StoredPodcastExerciseProto? = nil
    var _completion: StoredPodcastCompletionProto? = nil
    var _log: LogProto? = nil
    var _llmRequestIds: Dictionary<String,String> = [:]
    var _generationJob: StoredPodcastGenerationJobProto? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _podcastID = source._podcastID
      _createdBy = source._createdBy
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _deletedAt = source._deletedAt
      _userInput = source._userInput
      _suggestionInput = source._suggestionInput
      _state = source._state
      _answer = source._answer
      _points = source._points
      _plan = source._plan
      _transcript = source._transcript
      _audio = source._audio
      _visuals = source._visuals
      _keyPoints = source._keyPoints
      _followups = source._followups
      _podcastType = source._podcastType
      _exercise = source._exercise
      _completion = source._completion
      _log = source._log
      _llmRequestIds = source._llmRequestIds
      _generationJob = source._generationJob
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._podcastID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._createdBy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._userInput) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._answer) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._points) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._plan) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._transcript) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._visuals) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._keyPoints) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._followups) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._suggestionInput) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._deletedAt) }()
        case 17: try { try decoder.decodeSingularEnumField(value: &_storage._podcastType) }()
        case 18: try { try decoder.decodeSingularMessageField(value: &_storage._exercise) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._completion) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._log) }()
        case 102: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._llmRequestIds) }()
        case 103: try { try decoder.decodeSingularMessageField(value: &_storage._generationJob) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._podcastID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._podcastID, fieldNumber: 1)
      }
      if !_storage._createdBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdBy, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._userInput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._state != .unknown {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      try { if let v = _storage._answer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._points {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._plan {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._transcript {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._visuals {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._keyPoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._followups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._suggestionInput {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._deletedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      if _storage._podcastType != .undefined {
        try visitor.visitSingularEnumField(value: _storage._podcastType, fieldNumber: 17)
      }
      try { if let v = _storage._exercise {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._completion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._log {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      } }()
      if !_storage._llmRequestIds.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._llmRequestIds, fieldNumber: 102)
      }
      try { if let v = _storage._generationJob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastProto, rhs: StoredPodcastProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podcastID != rhs_storage._podcastID {return false}
        if _storage._createdBy != rhs_storage._createdBy {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._deletedAt != rhs_storage._deletedAt {return false}
        if _storage._userInput != rhs_storage._userInput {return false}
        if _storage._suggestionInput != rhs_storage._suggestionInput {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._answer != rhs_storage._answer {return false}
        if _storage._points != rhs_storage._points {return false}
        if _storage._plan != rhs_storage._plan {return false}
        if _storage._transcript != rhs_storage._transcript {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._visuals != rhs_storage._visuals {return false}
        if _storage._keyPoints != rhs_storage._keyPoints {return false}
        if _storage._followups != rhs_storage._followups {return false}
        if _storage._podcastType != rhs_storage._podcastType {return false}
        if _storage._exercise != rhs_storage._exercise {return false}
        if _storage._completion != rhs_storage._completion {return false}
        if _storage._log != rhs_storage._log {return false}
        if _storage._llmRequestIds != rhs_storage._llmRequestIds {return false}
        if _storage._generationJob != rhs_storage._generationJob {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastGenerationJobProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastGenerationJobProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "job_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.jobID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.jobID.isEmpty {
      try visitor.visitSingularStringField(value: self.jobID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastGenerationJobProto, rhs: StoredPodcastGenerationJobProto) -> Bool {
    if lhs.jobID != rhs.jobID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastUserInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastUserInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prompt"),
    2: .standard(proto: "point_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pointIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 1)
    }
    if !self.pointIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pointIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastUserInputProto, rhs: StoredPodcastUserInputProto) -> Bool {
    if lhs.prompt != rhs.prompt {return false}
    if lhs.pointIds != rhs.pointIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suggestions_id"),
    2: .same(proto: "title"),
    3: .standard(proto: "thumbnail_prompt"),
    10: .standard(proto: "suggestion_section"),
    11: .standard(proto: "routine_step"),
    12: .same(proto: "followup"),
    20: .standard(proto: "suggestion_points"),
    21: .standard(proto: "user_input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suggestionsID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailPrompt) }()
      case 10: try {
        var v: StoredPodcastSuggestionFromSectionInputProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .suggestionSection(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .suggestionSection(v)
        }
      }()
      case 11: try {
        var v: StoredPodcastSuggestionFromRoutineStepInputProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .routineStep(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .routineStep(v)
        }
      }()
      case 12: try {
        var v: StoredPodcastSuggestionFromFollowupInputProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .followup(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .followup(v)
        }
      }()
      case 20: try { try decoder.decodeSingularMessageField(value: &self._suggestionPoints) }()
      case 21: try { try decoder.decodeSingularMessageField(value: &self._userInput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.suggestionsID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionsID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.thumbnailPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailPrompt, fieldNumber: 3)
    }
    switch self.type {
    case .suggestionSection?: try {
      guard case .suggestionSection(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .routineStep?: try {
      guard case .routineStep(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .followup?: try {
      guard case .followup(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try { if let v = self._suggestionPoints {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
    } }()
    try { if let v = self._userInput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionInputProto, rhs: StoredPodcastSuggestionInputProto) -> Bool {
    if lhs.suggestionsID != rhs.suggestionsID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.thumbnailPrompt != rhs.thumbnailPrompt {return false}
    if lhs.type != rhs.type {return false}
    if lhs._suggestionPoints != rhs._suggestionPoints {return false}
    if lhs._userInput != rhs._userInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionFromSectionInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionFromSectionInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suggestion_section_id"),
    2: .standard(proto: "suggestion_section_reasoning"),
    3: .same(proto: "badge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suggestionSectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.suggestionSectionReasoning) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.badge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suggestionSectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionSectionID, fieldNumber: 1)
    }
    if !self.suggestionSectionReasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionSectionReasoning, fieldNumber: 2)
    }
    if !self.badge.isEmpty {
      try visitor.visitSingularStringField(value: self.badge, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionFromSectionInputProto, rhs: StoredPodcastSuggestionFromSectionInputProto) -> Bool {
    if lhs.suggestionSectionID != rhs.suggestionSectionID {return false}
    if lhs.suggestionSectionReasoning != rhs.suggestionSectionReasoning {return false}
    if lhs.badge != rhs.badge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionFromRoutineStepInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionFromRoutineStepInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "routine_id"),
    2: .standard(proto: "routine_reasoning"),
    3: .standard(proto: "step_outline"),
    4: .standard(proto: "step_tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.routineID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.routineReasoning) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.stepOutline) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.stepTags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routineID.isEmpty {
      try visitor.visitSingularStringField(value: self.routineID, fieldNumber: 1)
    }
    if !self.routineReasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.routineReasoning, fieldNumber: 2)
    }
    if !self.stepOutline.isEmpty {
      try visitor.visitSingularStringField(value: self.stepOutline, fieldNumber: 3)
    }
    if !self.stepTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.stepTags, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionFromRoutineStepInputProto, rhs: StoredPodcastSuggestionFromRoutineStepInputProto) -> Bool {
    if lhs.routineID != rhs.routineID {return false}
    if lhs.routineReasoning != rhs.routineReasoning {return false}
    if lhs.stepOutline != rhs.stepOutline {return false}
    if lhs.stepTags != rhs.stepTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionFromFollowupInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionFromFollowupInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_podcast_id"),
    2: .standard(proto: "source_podcast_title"),
    3: .standard(proto: "source_podcast_plan"),
    4: .standard(proto: "followup_reasoning"),
    5: .standard(proto: "followup_emoji"),
    6: .standard(proto: "followup_outline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourcePodcastID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.sourcePodcastTitle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sourcePodcastPlan) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.followupReasoning) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.followupEmoji) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.followupOutline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourcePodcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePodcastID, fieldNumber: 1)
    }
    if !self.sourcePodcastTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePodcastTitle, fieldNumber: 2)
    }
    if !self.sourcePodcastPlan.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePodcastPlan, fieldNumber: 3)
    }
    if !self.followupReasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.followupReasoning, fieldNumber: 4)
    }
    if !self.followupEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.followupEmoji, fieldNumber: 5)
    }
    if !self.followupOutline.isEmpty {
      try visitor.visitSingularStringField(value: self.followupOutline, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionFromFollowupInputProto, rhs: StoredPodcastSuggestionFromFollowupInputProto) -> Bool {
    if lhs.sourcePodcastID != rhs.sourcePodcastID {return false}
    if lhs.sourcePodcastTitle != rhs.sourcePodcastTitle {return false}
    if lhs.sourcePodcastPlan != rhs.sourcePodcastPlan {return false}
    if lhs.followupReasoning != rhs.followupReasoning {return false}
    if lhs.followupEmoji != rhs.followupEmoji {return false}
    if lhs.followupOutline != rhs.followupOutline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionUserInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionUserInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.pointIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pointIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pointIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionUserInputProto, rhs: StoredPodcastSuggestionUserInputProto) -> Bool {
    if lhs.pointIds != rhs.pointIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastPointsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastPointsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.points) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.points.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.points, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastPointsProto, rhs: StoredPodcastPointsProto) -> Bool {
    if lhs.points != rhs.points {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastPointProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastPointProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_id"),
    2: .same(proto: "reasoning"),
    3: .same(proto: "title"),
    4: .standard(proto: "title_emoji"),
    5: .same(proto: "outline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reasoning) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.titleEmoji) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.outline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pointID.isEmpty {
      try visitor.visitSingularStringField(value: self.pointID, fieldNumber: 1)
    }
    if !self.reasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.reasoning, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.titleEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.titleEmoji, fieldNumber: 4)
    }
    if !self.outline.isEmpty {
      try visitor.visitSingularStringField(value: self.outline, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastPointProto, rhs: StoredPodcastPointProto) -> Bool {
    if lhs.pointID != rhs.pointID {return false}
    if lhs.reasoning != rhs.reasoning {return false}
    if lhs.title != rhs.title {return false}
    if lhs.titleEmoji != rhs.titleEmoji {return false}
    if lhs.outline != rhs.outline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastPlanProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastPlanProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "plan"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.plan) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.plan.isEmpty {
      try visitor.visitSingularStringField(value: self.plan, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastPlanProto, rhs: StoredPodcastPlanProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.plan != rhs.plan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastTranscriptProto, rhs: StoredPodcastTranscriptProto) -> Bool {
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSectionTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSectionTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "section_type"),
    2: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sectionType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sectionType != .unknown {
      try visitor.visitSingularEnumField(value: self.sectionType, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSectionTranscriptProto, rhs: StoredPodcastSectionTranscriptProto) -> Bool {
    if lhs.sectionType != rhs.sectionType {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastTranscriptEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastTranscriptEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "text"),
    3: .standard(proto: "start_millis"),
    4: .standard(proto: "end_millis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startMillis) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.endMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.host != .unknown {
      try visitor.visitSingularEnumField(value: self.host, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.startMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.startMillis, fieldNumber: 3)
    }
    if self.endMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.endMillis, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastTranscriptEntryProto, rhs: StoredPodcastTranscriptEntryProto) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.text != rhs.text {return false}
    if lhs.startMillis != rhs.startMillis {return false}
    if lhs.endMillis != rhs.endMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastStyleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastStyleProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.imageStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.imageStyle != .undefined {
      try visitor.visitSingularEnumField(value: self.imageStyle, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastStyleProto, rhs: StoredPodcastStyleProto) -> Bool {
    if lhs.imageStyle != rhs.imageStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastVisualsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastVisualsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "style"),
    2: .standard(proto: "thumbnail_prompt"),
    3: .standard(proto: "thumbnail_key"),
    4: .same(proto: "visuals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self.thumbnailPrompt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.visuals) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.thumbnailPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailPrompt, fieldNumber: 2)
    }
    if !self.thumbnailKey.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailKey, fieldNumber: 3)
    }
    if !self.visuals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.visuals, fieldNumber: 4)
    }
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastVisualsProto, rhs: StoredPodcastVisualsProto) -> Bool {
    if lhs._style != rhs._style {return false}
    if lhs.thumbnailPrompt != rhs.thumbnailPrompt {return false}
    if lhs.thumbnailKey != rhs.thumbnailKey {return false}
    if lhs.visuals != rhs.visuals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastVisualProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastVisualProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_millis"),
    2: .standard(proto: "image_prompt"),
    3: .standard(proto: "image_key"),
    4: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timestampMillis) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imagePrompt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.transition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.timestampMillis, fieldNumber: 1)
    }
    if !self.imagePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePrompt, fieldNumber: 2)
    }
    if !self.imageKey.isEmpty {
      try visitor.visitSingularStringField(value: self.imageKey, fieldNumber: 3)
    }
    if self.transition != .undefined {
      try visitor.visitSingularEnumField(value: self.transition, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastVisualProto, rhs: StoredPodcastVisualProto) -> Bool {
    if lhs.timestampMillis != rhs.timestampMillis {return false}
    if lhs.imagePrompt != rhs.imagePrompt {return false}
    if lhs.imageKey != rhs.imageKey {return false}
    if lhs.transition != rhs.transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastAudioProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastAudioProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_key"),
    2: .standard(proto: "audio_duration"),
    3: .same(proto: "words"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.audioKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._audioDuration) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.words) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.audioKey.isEmpty {
      try visitor.visitSingularStringField(value: self.audioKey, fieldNumber: 1)
    }
    try { if let v = self._audioDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.words.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.words, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastAudioProto, rhs: StoredPodcastAudioProto) -> Bool {
    if lhs.audioKey != rhs.audioKey {return false}
    if lhs._audioDuration != rhs._audioDuration {return false}
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastKeyPointsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastKeyPointsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .standard(proto: "key_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keyPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.keyPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastKeyPointsProto, rhs: StoredPodcastKeyPointsProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.keyPoints != rhs.keyPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastFollowupsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastFollowupsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "followups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.followups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.followups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.followups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastFollowupsProto, rhs: StoredPodcastFollowupsProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.followups != rhs.followups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastFollowupProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastFollowupProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "followup_podcast_id"),
    2: .same(proto: "reasoning"),
    3: .same(proto: "emoji"),
    4: .same(proto: "outline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.followupPodcastID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reasoning) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.followupPodcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.followupPodcastID, fieldNumber: 1)
    }
    if !self.reasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.reasoning, fieldNumber: 2)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 3)
    }
    if !self.outline.isEmpty {
      try visitor.visitSingularStringField(value: self.outline, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastFollowupProto, rhs: StoredPodcastFollowupProto) -> Bool {
    if lhs.followupPodcastID != rhs.followupPodcastID {return false}
    if lhs.reasoning != rhs.reasoning {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.outline != rhs.outline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastKeyPointProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastKeyPointProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_point_id"),
    2: .same(proto: "title"),
    3: .standard(proto: "title_emoji"),
    4: .same(proto: "outline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyPointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.titleEmoji) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPointID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyPointID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.titleEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.titleEmoji, fieldNumber: 3)
    }
    if !self.outline.isEmpty {
      try visitor.visitSingularStringField(value: self.outline, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastKeyPointProto, rhs: StoredPodcastKeyPointProto) -> Bool {
    if lhs.keyPointID != rhs.keyPointID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.titleEmoji != rhs.titleEmoji {return false}
    if lhs.outline != rhs.outline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastCompletionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastCompletionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "encouragement"),
    3: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.encouragement) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 1)
    }
    if !self.encouragement.isEmpty {
      try visitor.visitSingularStringField(value: self.encouragement, fieldNumber: 2)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastCompletionProto, rhs: StoredPodcastCompletionProto) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.encouragement != rhs.encouragement {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suggestions_id"),
    9: .standard(proto: "user_id"),
    2: .same(proto: "state"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "updated_at"),
    5: .same(proto: "reasoning"),
    6: .same(proto: "ranking"),
    7: .same(proto: "sections"),
    8: .same(proto: "routine"),
    101: .same(proto: "log"),
    102: .standard(proto: "llm_request_ids"),
    103: .standard(proto: "generation_job"),
  ]

  fileprivate class _StorageClass {
    var _suggestionsID: String = String()
    var _userID: String = String()
    var _state: StoredPodcastSuggestionsStateProto = .undefined
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _reasoning: String = String()
    var _ranking: String = String()
    var _sections: [StoredPodcastSuggestionsSectionProto] = []
    var _routine: StoredPodcastRoutineProto? = nil
    var _log: LogProto? = nil
    var _llmRequestIds: Dictionary<String,String> = [:]
    var _generationJob: StoredPodcastGenerationJobProto? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _suggestionsID = source._suggestionsID
      _userID = source._userID
      _state = source._state
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _reasoning = source._reasoning
      _ranking = source._ranking
      _sections = source._sections
      _routine = source._routine
      _log = source._log
      _llmRequestIds = source._llmRequestIds
      _generationJob = source._generationJob
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._suggestionsID) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._reasoning) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._ranking) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._sections) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._routine) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._log) }()
        case 102: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._llmRequestIds) }()
        case 103: try { try decoder.decodeSingularMessageField(value: &_storage._generationJob) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._suggestionsID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._suggestionsID, fieldNumber: 1)
      }
      if _storage._state != .undefined {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._reasoning.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reasoning, fieldNumber: 5)
      }
      if !_storage._ranking.isEmpty {
        try visitor.visitSingularStringField(value: _storage._ranking, fieldNumber: 6)
      }
      if !_storage._sections.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sections, fieldNumber: 7)
      }
      try { if let v = _storage._routine {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 9)
      }
      try { if let v = _storage._log {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      } }()
      if !_storage._llmRequestIds.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._llmRequestIds, fieldNumber: 102)
      }
      try { if let v = _storage._generationJob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionsProto, rhs: StoredPodcastSuggestionsProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._suggestionsID != rhs_storage._suggestionsID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._reasoning != rhs_storage._reasoning {return false}
        if _storage._ranking != rhs_storage._ranking {return false}
        if _storage._sections != rhs_storage._sections {return false}
        if _storage._routine != rhs_storage._routine {return false}
        if _storage._log != rhs_storage._log {return false}
        if _storage._llmRequestIds != rhs_storage._llmRequestIds {return false}
        if _storage._generationJob != rhs_storage._generationJob {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionsSectionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionsSectionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "section_id"),
    2: .same(proto: "reasoning"),
    3: .same(proto: "title"),
    9: .same(proto: "style"),
    5: .standard(proto: "banner_suggestion"),
    6: .standard(proto: "footer_suggestion"),
    7: .same(proto: "story1"),
    8: .same(proto: "story2"),
  ]

  fileprivate class _StorageClass {
    var _sectionID: String = String()
    var _reasoning: String = String()
    var _title: String = String()
    var _style: StoredPodcastStyleProto? = nil
    var _bannerSuggestion: StoredPodcastSuggestionProto? = nil
    var _footerSuggestion: StoredPodcastSuggestionProto? = nil
    var _story1: StoredPodcastStorySuggestionProto? = nil
    var _story2: StoredPodcastStorySuggestionProto? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sectionID = source._sectionID
      _reasoning = source._reasoning
      _title = source._title
      _style = source._style
      _bannerSuggestion = source._bannerSuggestion
      _footerSuggestion = source._footerSuggestion
      _story1 = source._story1
      _story2 = source._story2
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sectionID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._reasoning) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._bannerSuggestion) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._footerSuggestion) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._story1) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._story2) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._style) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sectionID, fieldNumber: 1)
      }
      if !_storage._reasoning.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reasoning, fieldNumber: 2)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 3)
      }
      try { if let v = _storage._bannerSuggestion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._footerSuggestion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._story1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._story2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._style {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionsSectionProto, rhs: StoredPodcastSuggestionsSectionProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sectionID != rhs_storage._sectionID {return false}
        if _storage._reasoning != rhs_storage._reasoning {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._style != rhs_storage._style {return false}
        if _storage._bannerSuggestion != rhs_storage._bannerSuggestion {return false}
        if _storage._footerSuggestion != rhs_storage._footerSuggestion {return false}
        if _storage._story1 != rhs_storage._story1 {return false}
        if _storage._story2 != rhs_storage._story2 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSuggestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSuggestionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suggested_podcast_id"),
    2: .same(proto: "title"),
    3: .same(proto: "badge"),
    4: .standard(proto: "thumbnail_prompt"),
    5: .standard(proto: "thumbnail_key"),
    6: .standard(proto: "generation_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suggestedPodcastID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.badge) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.thumbnailPrompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.thumbnailKey) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.generationState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suggestedPodcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestedPodcastID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.badge.isEmpty {
      try visitor.visitSingularStringField(value: self.badge, fieldNumber: 3)
    }
    if !self.thumbnailPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailPrompt, fieldNumber: 4)
    }
    if !self.thumbnailKey.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailKey, fieldNumber: 5)
    }
    if self.generationState != .undefined {
      try visitor.visitSingularEnumField(value: self.generationState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSuggestionProto, rhs: StoredPodcastSuggestionProto) -> Bool {
    if lhs.suggestedPodcastID != rhs.suggestedPodcastID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.badge != rhs.badge {return false}
    if lhs.thumbnailPrompt != rhs.thumbnailPrompt {return false}
    if lhs.thumbnailKey != rhs.thumbnailKey {return false}
    if lhs.generationState != rhs.generationState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastStorySuggestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastStorySuggestionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .standard(proto: "suggestions_id"),
    1: .standard(proto: "suggested_story_id"),
    2: .same(proto: "title"),
    3: .standard(proto: "thumbnail_prompt"),
    4: .standard(proto: "thumbnail_key"),
    6: .standard(proto: "generation_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suggestedStoryID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailPrompt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.thumbnailKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.suggestionsID) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.generationState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.suggestedStoryID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestedStoryID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.thumbnailPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailPrompt, fieldNumber: 3)
    }
    if !self.thumbnailKey.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailKey, fieldNumber: 4)
    }
    if !self.suggestionsID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionsID, fieldNumber: 5)
    }
    if self.generationState != .undefined {
      try visitor.visitSingularEnumField(value: self.generationState, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastStorySuggestionProto, rhs: StoredPodcastStorySuggestionProto) -> Bool {
    if lhs.suggestionsID != rhs.suggestionsID {return false}
    if lhs.suggestedStoryID != rhs.suggestedStoryID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.thumbnailPrompt != rhs.thumbnailPrompt {return false}
    if lhs.thumbnailKey != rhs.thumbnailKey {return false}
    if lhs.generationState != rhs.generationState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastStoryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastStoryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .standard(proto: "user_id"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "updated_at"),
    5: .standard(proto: "deleted_at"),
    6: .same(proto: "state"),
    7: .same(proto: "input"),
    8: .same(proto: "slides"),
    100: .same(proto: "log"),
    101: .standard(proto: "llm_request_ids"),
    103: .standard(proto: "generation_job"),
  ]

  fileprivate class _StorageClass {
    var _storyID: String = String()
    var _userID: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _deletedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _state: StoredPodcastStoryStateProto = .undefined
    var _input: StoredPodcastStoryInputProto? = nil
    var _slides: StoredPodcastStorySlidesProto? = nil
    var _log: LogProto? = nil
    var _llmRequestIds: Dictionary<String,String> = [:]
    var _generationJob: StoredPodcastGenerationJobProto? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _storyID = source._storyID
      _userID = source._userID
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _deletedAt = source._deletedAt
      _state = source._state
      _input = source._input
      _slides = source._slides
      _log = source._log
      _llmRequestIds = source._llmRequestIds
      _generationJob = source._generationJob
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._storyID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._userID) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._deletedAt) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._input) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._slides) }()
        case 100: try { try decoder.decodeSingularMessageField(value: &_storage._log) }()
        case 101: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &_storage._llmRequestIds) }()
        case 103: try { try decoder.decodeSingularMessageField(value: &_storage._generationJob) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._storyID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._storyID, fieldNumber: 1)
      }
      if !_storage._userID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userID, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._deletedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      if _storage._state != .undefined {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      try { if let v = _storage._input {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._slides {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._log {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      } }()
      if !_storage._llmRequestIds.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: _storage._llmRequestIds, fieldNumber: 101)
      }
      try { if let v = _storage._generationJob {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 103)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastStoryProto, rhs: StoredPodcastStoryProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._storyID != rhs_storage._storyID {return false}
        if _storage._userID != rhs_storage._userID {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._deletedAt != rhs_storage._deletedAt {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._input != rhs_storage._input {return false}
        if _storage._slides != rhs_storage._slides {return false}
        if _storage._log != rhs_storage._log {return false}
        if _storage._llmRequestIds != rhs_storage._llmRequestIds {return false}
        if _storage._generationJob != rhs_storage._generationJob {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastStoryInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastStoryInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "suggestion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StoredPodcastStorySuggestionInputProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .suggestion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .suggestion(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .suggestion(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastStoryInputProto, rhs: StoredPodcastStoryInputProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastStorySuggestionInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastStorySuggestionInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suggestion_section_id"),
    2: .standard(proto: "suggestion_section_reasoning"),
    3: .standard(proto: "suggestion_title"),
    7: .standard(proto: "suggestion_style"),
    5: .standard(proto: "suggestion_thumbnail_prompt"),
    6: .standard(proto: "suggestion_thumbnail_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suggestionSectionID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.suggestionSectionReasoning) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.suggestionTitle) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.suggestionThumbnailPrompt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.suggestionThumbnailKey) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._suggestionStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.suggestionSectionID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionSectionID, fieldNumber: 1)
    }
    if !self.suggestionSectionReasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionSectionReasoning, fieldNumber: 2)
    }
    if !self.suggestionTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionTitle, fieldNumber: 3)
    }
    if !self.suggestionThumbnailPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionThumbnailPrompt, fieldNumber: 5)
    }
    if !self.suggestionThumbnailKey.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionThumbnailKey, fieldNumber: 6)
    }
    try { if let v = self._suggestionStyle {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastStorySuggestionInputProto, rhs: StoredPodcastStorySuggestionInputProto) -> Bool {
    if lhs.suggestionSectionID != rhs.suggestionSectionID {return false}
    if lhs.suggestionSectionReasoning != rhs.suggestionSectionReasoning {return false}
    if lhs.suggestionTitle != rhs.suggestionTitle {return false}
    if lhs._suggestionStyle != rhs._suggestionStyle {return false}
    if lhs.suggestionThumbnailPrompt != rhs.suggestionThumbnailPrompt {return false}
    if lhs.suggestionThumbnailKey != rhs.suggestionThumbnailKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastStorySlidesProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastStorySlidesProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_ready"),
    2: .same(proto: "reasoning"),
    3: .same(proto: "structure"),
    4: .same(proto: "slides"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isReady) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reasoning) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.structure) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.slides) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isReady != false {
      try visitor.visitSingularBoolField(value: self.isReady, fieldNumber: 1)
    }
    if !self.reasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.reasoning, fieldNumber: 2)
    }
    if !self.structure.isEmpty {
      try visitor.visitSingularStringField(value: self.structure, fieldNumber: 3)
    }
    if !self.slides.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.slides, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastStorySlidesProto, rhs: StoredPodcastStorySlidesProto) -> Bool {
    if lhs.isReady != rhs.isReady {return false}
    if lhs.reasoning != rhs.reasoning {return false}
    if lhs.structure != rhs.structure {return false}
    if lhs.slides != rhs.slides {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastStorySlideProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastStorySlideProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_id"),
    2: .standard(proto: "is_text_ready"),
    3: .same(proto: "title"),
    4: .standard(proto: "image_prompt"),
    5: .same(proto: "text"),
    6: .standard(proto: "image_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.slideID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTextReady) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.imagePrompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.imageKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.slideID.isEmpty {
      try visitor.visitSingularStringField(value: self.slideID, fieldNumber: 1)
    }
    if self.isTextReady != false {
      try visitor.visitSingularBoolField(value: self.isTextReady, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.imagePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePrompt, fieldNumber: 4)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 5)
    }
    if !self.imageKey.isEmpty {
      try visitor.visitSingularStringField(value: self.imageKey, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastStorySlideProto, rhs: StoredPodcastStorySlideProto) -> Bool {
    if lhs.slideID != rhs.slideID {return false}
    if lhs.isTextReady != rhs.isTextReady {return false}
    if lhs.title != rhs.title {return false}
    if lhs.imagePrompt != rhs.imagePrompt {return false}
    if lhs.text != rhs.text {return false}
    if lhs.imageKey != rhs.imageKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastRoutineProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastRoutineProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    4: .standard(proto: "routine_id"),
    1: .same(proto: "reasoning"),
    2: .same(proto: "segments"),
    3: .same(proto: "style"),
    7: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.reasoning) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.routineID) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.reasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.reasoning, fieldNumber: 1)
    }
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 2)
    }
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.routineID.isEmpty {
      try visitor.visitSingularStringField(value: self.routineID, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastRoutineProto, rhs: StoredPodcastRoutineProto) -> Bool {
    if lhs.routineID != rhs.routineID {return false}
    if lhs.reasoning != rhs.reasoning {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs._style != rhs._style {return false}
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastRoutineSegmentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastRoutineSegmentProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "segment_id"),
    5: .standard(proto: "segment_label"),
    2: .same(proto: "reasoning"),
    3: .same(proto: "title"),
    4: .same(proto: "steps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.segmentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reasoning) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.steps) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.segmentLabel) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segmentID.isEmpty {
      try visitor.visitSingularStringField(value: self.segmentID, fieldNumber: 1)
    }
    if !self.reasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.reasoning, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.steps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.steps, fieldNumber: 4)
    }
    if !self.segmentLabel.isEmpty {
      try visitor.visitSingularStringField(value: self.segmentLabel, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastRoutineSegmentProto, rhs: StoredPodcastRoutineSegmentProto) -> Bool {
    if lhs.segmentID != rhs.segmentID {return false}
    if lhs.segmentLabel != rhs.segmentLabel {return false}
    if lhs.reasoning != rhs.reasoning {return false}
    if lhs.title != rhs.title {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastRoutineStepProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastRoutineStepProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .standard(proto: "podcast_id"),
    1: .same(proto: "type"),
    2: .same(proto: "title"),
    3: .same(proto: "outline"),
    8: .same(proto: "tags"),
    4: .standard(proto: "thumbnail_prompt"),
    5: .standard(proto: "thumbnail_key"),
    7: .standard(proto: "generation_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.outline) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.thumbnailPrompt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.thumbnailKey) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.generationState) }()
      case 8: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .undefined {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.outline.isEmpty {
      try visitor.visitSingularStringField(value: self.outline, fieldNumber: 3)
    }
    if !self.thumbnailPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailPrompt, fieldNumber: 4)
    }
    if !self.thumbnailKey.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailKey, fieldNumber: 5)
    }
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 6)
    }
    if self.generationState != .undefined {
      try visitor.visitSingularEnumField(value: self.generationState, fieldNumber: 7)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastRoutineStepProto, rhs: StoredPodcastRoutineStepProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.title != rhs.title {return false}
    if lhs.outline != rhs.outline {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.thumbnailPrompt != rhs.thumbnailPrompt {return false}
    if lhs.thumbnailKey != rhs.thumbnailKey {return false}
    if lhs.generationState != rhs.generationState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plan"),
    6: .same(proto: "sections"),
    5: .same(proto: "style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._plan) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._style) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._plan {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._style {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseProto, rhs: StoredPodcastExerciseProto) -> Bool {
    if lhs._plan != rhs._plan {return false}
    if lhs.sections != rhs.sections {return false}
    if lhs._style != rhs._style {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExercisePlanProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExercisePlanProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "ideas"),
    3: .same(proto: "reasoning"),
    4: .standard(proto: "selected_category"),
    8: .same(proto: "sections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.ideas) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.reasoning) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.selectedCategory) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.ideas.isEmpty {
      try visitor.visitSingularStringField(value: self.ideas, fieldNumber: 2)
    }
    if !self.reasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.reasoning, fieldNumber: 3)
    }
    if !self.selectedCategory.isEmpty {
      try visitor.visitSingularStringField(value: self.selectedCategory, fieldNumber: 4)
    }
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExercisePlanProto, rhs: StoredPodcastExercisePlanProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.ideas != rhs.ideas {return false}
    if lhs.reasoning != rhs.reasoning {return false}
    if lhs.selectedCategory != rhs.selectedCategory {return false}
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseSectionPlanProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseSectionPlanProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "plan"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.plan) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.plan.isEmpty {
      try visitor.visitSingularStringField(value: self.plan, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseSectionPlanProto, rhs: StoredPodcastExerciseSectionPlanProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.plan != rhs.plan {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseSectionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseSectionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    3: .same(proto: "label"),
    1: .same(proto: "segments"),
    2: .same(proto: "background"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._background) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 1)
    }
    try { if let v = self._background {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseSectionProto, rhs: StoredPodcastExerciseSectionProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs._background != rhs._background {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseSegmentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseSegmentProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spoken_segment"),
    2: .same(proto: "reps"),
    3: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StoredPodcastSpokenSegmentProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .spokenSegment(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .spokenSegment(v)
        }
      }()
      case 2: try {
        var v: StoredPodcastExerciseVisualRepsProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reps(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reps(v)
        }
      }()
      case 3: try {
        var v: StoredPodcastExerciseVisualTextProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .spokenSegment?: try {
      guard case .spokenSegment(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .reps?: try {
      guard case .reps(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseSegmentProto, rhs: StoredPodcastExerciseSegmentProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseSectionBackgroundProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseSectionBackgroundProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_prompt"),
    2: .standard(proto: "image_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.imagePrompt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imageKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.imagePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePrompt, fieldNumber: 1)
    }
    if !self.imageKey.isEmpty {
      try visitor.visitSingularStringField(value: self.imageKey, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseSectionBackgroundProto, rhs: StoredPodcastExerciseSectionBackgroundProto) -> Bool {
    if lhs.imagePrompt != rhs.imagePrompt {return false}
    if lhs.imageKey != rhs.imageKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSpokenSegmentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSpokenSegmentProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "leading_pause"),
    3: .standard(proto: "min_duration"),
    4: .same(proto: "timing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._leadingPause) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minDuration) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try { if let v = self._leadingPause {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSpokenSegmentProto, rhs: StoredPodcastSpokenSegmentProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs._leadingPause != rhs._leadingPause {return false}
    if lhs._minDuration != rhs._minDuration {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSpokenSegmentTimingProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSpokenSegmentTimingProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_millis"),
    2: .standard(proto: "end_millis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.startMillis) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.endMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.startMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.startMillis, fieldNumber: 1)
    }
    if self.endMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.endMillis, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSpokenSegmentTimingProto, rhs: StoredPodcastSpokenSegmentTimingProto) -> Bool {
    if lhs.startMillis != rhs.startMillis {return false}
    if lhs.endMillis != rhs.endMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseVisualTextProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseVisualTextProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseVisualTextProto, rhs: StoredPodcastExerciseVisualTextProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseVisualRepsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseVisualRepsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "marker"),
    2: .same(proto: "counter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StoredPodcastExerciseVisualRepsMarkerProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .marker(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .marker(v)
        }
      }()
      case 2: try {
        var v: StoredPodcastExerciseVisualRepsCounterProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .counter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .counter(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .marker?: try {
      guard case .marker(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .counter?: try {
      guard case .counter(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseVisualRepsProto, rhs: StoredPodcastExerciseVisualRepsProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseVisualRepsMarkerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseVisualRepsMarkerProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .standard(proto: "rep_total"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.repTotal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.type != .undefined {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    if self.repTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.repTotal, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseVisualRepsMarkerProto, rhs: StoredPodcastExerciseVisualRepsMarkerProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.repTotal != rhs.repTotal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastExerciseVisualRepsMarkerProto.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNDEFINED"),
    1: .same(proto: "START"),
    2: .same(proto: "END"),
    3: .same(proto: "COUNTER"),
  ]
}

extension StoredPodcastExerciseVisualRepsCounterProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastExerciseVisualRepsCounterProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "rep_number"),
    3: .standard(proto: "rep_total"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.repNumber) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.repTotal) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.repNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.repNumber, fieldNumber: 2)
    }
    if self.repTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.repTotal, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastExerciseVisualRepsCounterProto, rhs: StoredPodcastExerciseVisualRepsCounterProto) -> Bool {
    if lhs.repNumber != rhs.repNumber {return false}
    if lhs.repTotal != rhs.repTotal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastUserProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastUserProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "created_at"),
    3: .standard(proto: "updated_at"),
    5: .standard(proto: "deleted_at"),
    4: .standard(proto: "onboarding_input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._onboardingInput) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._deletedAt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._onboardingInput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._deletedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastUserProto, rhs: StoredPodcastUserProto) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs._deletedAt != rhs._deletedAt {return false}
    if lhs._onboardingInput != rhs._onboardingInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastOnboardingInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastOnboardingInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "created_at"),
    2: .same(proto: "name"),
    3: .standard(proto: "goal_ids"),
    4: .standard(proto: "learning_style_ids"),
    5: .standard(proto: "interest_ids"),
    6: .standard(proto: "voice_id"),
    7: .standard(proto: "user_agent"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.goalIds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.learningStyleIds) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.interestIds) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.voiceID) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._userAgent) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.goalIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.goalIds, fieldNumber: 3)
    }
    if !self.learningStyleIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.learningStyleIds, fieldNumber: 4)
    }
    if !self.interestIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.interestIds, fieldNumber: 5)
    }
    if !self.voiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.voiceID, fieldNumber: 6)
    }
    try { if let v = self._userAgent {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastOnboardingInputProto, rhs: StoredPodcastOnboardingInputProto) -> Bool {
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.name != rhs.name {return false}
    if lhs.goalIds != rhs.goalIds {return false}
    if lhs.learningStyleIds != rhs.learningStyleIds {return false}
    if lhs.interestIds != rhs.interestIds {return false}
    if lhs.voiceID != rhs.voiceID {return false}
    if lhs._userAgent != rhs._userAgent {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastUserAgentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastUserAgentProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_agent"),
    2: .same(proto: "device"),
    3: .same(proto: "locale"),
    4: .same(proto: "location"),
    5: .standard(proto: "user_interface_style"),
    6: .standard(proto: "accessibility_settings"),
  ]

  fileprivate class _StorageClass {
    var _userAgent: String = String()
    var _device: StoredPodcastDeviceProto? = nil
    var _locale: StoredPodcastLocaleProto? = nil
    var _location: StoredPodcastLocationProto? = nil
    var _userInterfaceStyle: StoredPodcastUserInterfaceStyleProto = .undefined
    var _accessibilitySettings: StoredPodcastAccessibilitySettingsProto? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _userAgent = source._userAgent
      _device = source._device
      _locale = source._locale
      _location = source._location
      _userInterfaceStyle = source._userInterfaceStyle
      _accessibilitySettings = source._accessibilitySettings
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._userAgent) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._device) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._locale) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 5: try { try decoder.decodeSingularEnumField(value: &_storage._userInterfaceStyle) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._accessibilitySettings) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._userAgent.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userAgent, fieldNumber: 1)
      }
      try { if let v = _storage._device {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._locale {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._userInterfaceStyle != .undefined {
        try visitor.visitSingularEnumField(value: _storage._userInterfaceStyle, fieldNumber: 5)
      }
      try { if let v = _storage._accessibilitySettings {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastUserAgentProto, rhs: StoredPodcastUserAgentProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._userAgent != rhs_storage._userAgent {return false}
        if _storage._device != rhs_storage._device {return false}
        if _storage._locale != rhs_storage._locale {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._userInterfaceStyle != rhs_storage._userInterfaceStyle {return false}
        if _storage._accessibilitySettings != rhs_storage._accessibilitySettings {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastAccessibilitySettingsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastAccessibilitySettingsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "content_size_category"),
    2: .standard(proto: "bold_text"),
    3: .standard(proto: "increase_contrast"),
    4: .standard(proto: "reduce_transparency"),
    5: .standard(proto: "reduce_motion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.contentSizeCategory) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.boldText) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.increaseContrast) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.reduceTransparency) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.reduceMotion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.contentSizeCategory != .undefined {
      try visitor.visitSingularEnumField(value: self.contentSizeCategory, fieldNumber: 1)
    }
    if self.boldText != false {
      try visitor.visitSingularBoolField(value: self.boldText, fieldNumber: 2)
    }
    if self.increaseContrast != false {
      try visitor.visitSingularBoolField(value: self.increaseContrast, fieldNumber: 3)
    }
    if self.reduceTransparency != false {
      try visitor.visitSingularBoolField(value: self.reduceTransparency, fieldNumber: 4)
    }
    if self.reduceMotion != false {
      try visitor.visitSingularBoolField(value: self.reduceMotion, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastAccessibilitySettingsProto, rhs: StoredPodcastAccessibilitySettingsProto) -> Bool {
    if lhs.contentSizeCategory != rhs.contentSizeCategory {return false}
    if lhs.boldText != rhs.boldText {return false}
    if lhs.increaseContrast != rhs.increaseContrast {return false}
    if lhs.reduceTransparency != rhs.reduceTransparency {return false}
    if lhs.reduceMotion != rhs.reduceMotion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastLocaleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastLocaleProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
    2: .same(proto: "region"),
    3: .standard(proto: "time_zone"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.region) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timeZone) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    if !self.region.isEmpty {
      try visitor.visitSingularStringField(value: self.region, fieldNumber: 2)
    }
    if !self.timeZone.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZone, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastLocaleProto, rhs: StoredPodcastLocaleProto) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.region != rhs.region {return false}
    if lhs.timeZone != rhs.timeZone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastLocationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastLocationProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "region_code"),
    2: .same(proto: "country"),
    3: .same(proto: "city"),
    4: .standard(proto: "time_zone"),
    5: .same(proto: "latitude"),
    6: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.regionCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.timeZone) }()
      case 5: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 6: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.regionCode.isEmpty {
      try visitor.visitSingularStringField(value: self.regionCode, fieldNumber: 1)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 2)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 3)
    }
    if !self.timeZone.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZone, fieldNumber: 4)
    }
    if self.latitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 5)
    }
    if self.longitude.bitPattern != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastLocationProto, rhs: StoredPodcastLocationProto) -> Bool {
    if lhs.regionCode != rhs.regionCode {return false}
    if lhs.country != rhs.country {return false}
    if lhs.city != rhs.city {return false}
    if lhs.timeZone != rhs.timeZone {return false}
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastDeviceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastDeviceProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ios"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: StoredPodcastIOSDeviceProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .ios(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .ios(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .ios(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastDeviceProto, rhs: StoredPodcastDeviceProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastIOSDeviceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastIOSDeviceProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_model"),
    2: .standard(proto: "device_identifier"),
    3: .standard(proto: "is_simulator"),
    4: .standard(proto: "os_name"),
    5: .standard(proto: "os_version"),
    6: .standard(proto: "app_bundle_name"),
    7: .standard(proto: "app_bundle_version"),
    8: .standard(proto: "app_build_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceIdentifier) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isSimulator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.appBundleName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.appBundleVersion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.appBuildNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 1)
    }
    if !self.deviceIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceIdentifier, fieldNumber: 2)
    }
    if self.isSimulator != false {
      try visitor.visitSingularBoolField(value: self.isSimulator, fieldNumber: 3)
    }
    if !self.osName.isEmpty {
      try visitor.visitSingularStringField(value: self.osName, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if !self.appBundleName.isEmpty {
      try visitor.visitSingularStringField(value: self.appBundleName, fieldNumber: 6)
    }
    if !self.appBundleVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appBundleVersion, fieldNumber: 7)
    }
    if !self.appBuildNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.appBuildNumber, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastIOSDeviceProto, rhs: StoredPodcastIOSDeviceProto) -> Bool {
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.deviceIdentifier != rhs.deviceIdentifier {return false}
    if lhs.isSimulator != rhs.isSimulator {return false}
    if lhs.osName != rhs.osName {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.appBundleName != rhs.appBundleName {return false}
    if lhs.appBundleVersion != rhs.appBundleVersion {return false}
    if lhs.appBuildNumber != rhs.appBuildNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
