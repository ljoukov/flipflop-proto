// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: StoredPodcastProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum StoredPodcastStateProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case ready // = 1
  case failed // = 2

  /// IDs start at 10
  case generatingSynopsys // = 10
  case synopsysReady // = 11
  case generatingThumbnail // = 12
  case thumbnailReady // = 13
  case generatingPlan // = 14
  case planReady // = 15
  case generatingTranscript // = 16
  case transcriptReady // = 17
  case generatingAudio // = 18
  case audioReady // = 19
  case generatingVisuals // = 20
  case visualsReady // = 21
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ready
    case 2: self = .failed
    case 10: self = .generatingSynopsys
    case 11: self = .synopsysReady
    case 12: self = .generatingThumbnail
    case 13: self = .thumbnailReady
    case 14: self = .generatingPlan
    case 15: self = .planReady
    case 16: self = .generatingTranscript
    case 17: self = .transcriptReady
    case 18: self = .generatingAudio
    case 19: self = .audioReady
    case 20: self = .generatingVisuals
    case 21: self = .visualsReady
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ready: return 1
    case .failed: return 2
    case .generatingSynopsys: return 10
    case .synopsysReady: return 11
    case .generatingThumbnail: return 12
    case .thumbnailReady: return 13
    case .generatingPlan: return 14
    case .planReady: return 15
    case .generatingTranscript: return 16
    case .transcriptReady: return 17
    case .generatingAudio: return 18
    case .audioReady: return 19
    case .generatingVisuals: return 20
    case .visualsReady: return 21
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension StoredPodcastStateProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StoredPodcastStateProto] = [
    .unknown,
    .ready,
    .failed,
    .generatingSynopsys,
    .synopsysReady,
    .generatingThumbnail,
    .thumbnailReady,
    .generatingPlan,
    .planReady,
    .generatingTranscript,
    .transcriptReady,
    .generatingAudio,
    .audioReady,
    .generatingVisuals,
    .visualsReady,
  ]
}

#endif  // swift(>=4.2)

enum StoredPodcastCardsStateProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case generating // = 1
  case ready // = 2
  case failed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .generating
    case 2: self = .ready
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .generating: return 1
    case .ready: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension StoredPodcastCardsStateProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StoredPodcastCardsStateProto] = [
    .unknown,
    .generating,
    .ready,
    .failed,
  ]
}

#endif  // swift(>=4.2)

enum StoredPodcastSectionTypeProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case introduction // = 1
  case section // = 2
  case conclusion // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .introduction
    case 2: self = .section
    case 3: self = .conclusion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .introduction: return 1
    case .section: return 2
    case .conclusion: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension StoredPodcastSectionTypeProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [StoredPodcastSectionTypeProto] = [
    .unknown,
    .introduction,
    .section,
    .conclusion,
  ]
}

#endif  // swift(>=4.2)

struct StoredPodcastProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String {
    get {return _storage._podcastID}
    set {_uniqueStorage()._podcastID = newValue}
  }

  var createdBy: String {
    get {return _storage._createdBy}
    set {_uniqueStorage()._createdBy = newValue}
  }

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  var userPrompt: String {
    get {return _storage._userPrompt}
    set {_uniqueStorage()._userPrompt = newValue}
  }

  var state: StoredPodcastStateProto {
    get {return _storage._state}
    set {_uniqueStorage()._state = newValue}
  }

  var answer: PodcastPromptAnswerProto {
    get {return _storage._answer ?? PodcastPromptAnswerProto()}
    set {_uniqueStorage()._answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  var hasAnswer: Bool {return _storage._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  mutating func clearAnswer() {_uniqueStorage()._answer = nil}

  var reasoning: String {
    get {return _storage._reasoning}
    set {_uniqueStorage()._reasoning = newValue}
  }

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var titleEmoji: String {
    get {return _storage._titleEmoji}
    set {_uniqueStorage()._titleEmoji = newValue}
  }

  var synopsis: String {
    get {return _storage._synopsis}
    set {_uniqueStorage()._synopsis = newValue}
  }

  var plan: String {
    get {return _storage._plan}
    set {_uniqueStorage()._plan = newValue}
  }

  var transcript: StoredPodcastTranscriptProto {
    get {return _storage._transcript ?? StoredPodcastTranscriptProto()}
    set {_uniqueStorage()._transcript = newValue}
  }
  /// Returns true if `transcript` has been explicitly set.
  var hasTranscript: Bool {return _storage._transcript != nil}
  /// Clears the value of `transcript`. Subsequent reads from it will return its default value.
  mutating func clearTranscript() {_uniqueStorage()._transcript = nil}

  var audio: StoredPodcastAudioProto {
    get {return _storage._audio ?? StoredPodcastAudioProto()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  mutating func clearAudio() {_uniqueStorage()._audio = nil}

  var visuals: StoredPodcastVisualsProto {
    get {return _storage._visuals ?? StoredPodcastVisualsProto()}
    set {_uniqueStorage()._visuals = newValue}
  }
  /// Returns true if `visuals` has been explicitly set.
  var hasVisuals: Bool {return _storage._visuals != nil}
  /// Clears the value of `visuals`. Subsequent reads from it will return its default value.
  mutating func clearVisuals() {_uniqueStorage()._visuals = nil}

  var cardsState: StoredPodcastCardsStateProto {
    get {return _storage._cardsState}
    set {_uniqueStorage()._cardsState = newValue}
  }

  var cards: PodcastCardsProto {
    get {return _storage._cards ?? PodcastCardsProto()}
    set {_uniqueStorage()._cards = newValue}
  }
  /// Returns true if `cards` has been explicitly set.
  var hasCards: Bool {return _storage._cards != nil}
  /// Clears the value of `cards`. Subsequent reads from it will return its default value.
  mutating func clearCards() {_uniqueStorage()._cards = nil}

  /// Debug metadata
  var latencies: LatenciesProto {
    get {return _storage._latencies ?? LatenciesProto()}
    set {_uniqueStorage()._latencies = newValue}
  }
  /// Returns true if `latencies` has been explicitly set.
  var hasLatencies: Bool {return _storage._latencies != nil}
  /// Clears the value of `latencies`. Subsequent reads from it will return its default value.
  mutating func clearLatencies() {_uniqueStorage()._latencies = nil}

  var log: LogProto {
    get {return _storage._log ?? LogProto()}
    set {_uniqueStorage()._log = newValue}
  }
  /// Returns true if `log` has been explicitly set.
  var hasLog: Bool {return _storage._log != nil}
  /// Clears the value of `log`. Subsequent reads from it will return its default value.
  mutating func clearLog() {_uniqueStorage()._log = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct StoredPodcastTranscriptProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sections: [StoredPodcastSectionTranscriptProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastSectionTranscriptProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sectionType: StoredPodcastSectionTypeProto = .unknown

  var entries: [StoredPodcastTranscriptEntryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastTranscriptEntryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var host: PodcastHostProto = .unknown

  var text: String = String()

  var startMillis: Int32 = 0

  var endMillis: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastVisualsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stylePrompt: String = String()

  var thumbnailPrompt: String = String()

  var thumbnailKey: String = String()

  var visuals: [StoredPodcastVisualProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastVisualProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestampMillis: Int32 = 0

  var imagePrompt: String = String()

  var imageKey: String = String()

  var transition: PodcastVisualTransitionProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoredPodcastAudioProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var audioKey: String = String()

  var audioDuration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _audioDuration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_audioDuration = newValue}
  }
  /// Returns true if `audioDuration` has been explicitly set.
  var hasAudioDuration: Bool {return self._audioDuration != nil}
  /// Clears the value of `audioDuration`. Subsequent reads from it will return its default value.
  mutating func clearAudioDuration() {self._audioDuration = nil}

  var words: [PodcastWordProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _audioDuration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension StoredPodcastStateProto: @unchecked Sendable {}
extension StoredPodcastCardsStateProto: @unchecked Sendable {}
extension StoredPodcastSectionTypeProto: @unchecked Sendable {}
extension StoredPodcastProto: @unchecked Sendable {}
extension StoredPodcastTranscriptProto: @unchecked Sendable {}
extension StoredPodcastSectionTranscriptProto: @unchecked Sendable {}
extension StoredPodcastTranscriptEntryProto: @unchecked Sendable {}
extension StoredPodcastVisualsProto: @unchecked Sendable {}
extension StoredPodcastVisualProto: @unchecked Sendable {}
extension StoredPodcastAudioProto: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension StoredPodcastStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_STATE_PROTO_UNKNOWN"),
    1: .same(proto: "STORED_PODCAST_STATE_PROTO_READY"),
    2: .same(proto: "STORED_PODCAST_STATE_PROTO_FAILED"),
    10: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATING_SYNOPSYS"),
    11: .same(proto: "STORED_PODCAST_STATE_PROTO_SYNOPSYS_READY"),
    12: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATING_THUMBNAIL"),
    13: .same(proto: "STORED_PODCAST_STATE_PROTO_THUMBNAIL_READY"),
    14: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATING_PLAN"),
    15: .same(proto: "STORED_PODCAST_STATE_PROTO_PLAN_READY"),
    16: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATING_TRANSCRIPT"),
    17: .same(proto: "STORED_PODCAST_STATE_PROTO_TRANSCRIPT_READY"),
    18: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATING_AUDIO"),
    19: .same(proto: "STORED_PODCAST_STATE_PROTO_AUDIO_READY"),
    20: .same(proto: "STORED_PODCAST_STATE_PROTO_GENERATING_VISUALS"),
    21: .same(proto: "STORED_PODCAST_STATE_PROTO_VISUALS_READY"),
  ]
}

extension StoredPodcastCardsStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_CARDS_STATE_PROTO_UNKNOWN"),
    1: .same(proto: "STORED_PODCAST_CARDS_STATE_PROTO_GENERATING"),
    2: .same(proto: "STORED_PODCAST_CARDS_STATE_PROTO_READY"),
    3: .same(proto: "STORED_PODCAST_CARDS_STATE_PROTO_FAILED"),
  ]
}

extension StoredPodcastSectionTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_UNKNOWN"),
    1: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_INTRODUCTION"),
    2: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_SECTION"),
    3: .same(proto: "STORED_PODCAST_SECTION_TYPE_PROTO_CONCLUSION"),
  ]
}

extension StoredPodcastProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "created_by"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "updated_at"),
    5: .standard(proto: "user_prompt"),
    6: .same(proto: "state"),
    7: .same(proto: "answer"),
    8: .same(proto: "reasoning"),
    9: .same(proto: "title"),
    10: .standard(proto: "title_emoji"),
    11: .same(proto: "synopsis"),
    12: .same(proto: "plan"),
    13: .same(proto: "transcript"),
    14: .same(proto: "audio"),
    15: .same(proto: "visuals"),
    16: .standard(proto: "cards_state"),
    17: .same(proto: "cards"),
    100: .same(proto: "latencies"),
    101: .same(proto: "log"),
  ]

  fileprivate class _StorageClass {
    var _podcastID: String = String()
    var _createdBy: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _userPrompt: String = String()
    var _state: StoredPodcastStateProto = .unknown
    var _answer: PodcastPromptAnswerProto? = nil
    var _reasoning: String = String()
    var _title: String = String()
    var _titleEmoji: String = String()
    var _synopsis: String = String()
    var _plan: String = String()
    var _transcript: StoredPodcastTranscriptProto? = nil
    var _audio: StoredPodcastAudioProto? = nil
    var _visuals: StoredPodcastVisualsProto? = nil
    var _cardsState: StoredPodcastCardsStateProto = .unknown
    var _cards: PodcastCardsProto? = nil
    var _latencies: LatenciesProto? = nil
    var _log: LogProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podcastID = source._podcastID
      _createdBy = source._createdBy
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _userPrompt = source._userPrompt
      _state = source._state
      _answer = source._answer
      _reasoning = source._reasoning
      _title = source._title
      _titleEmoji = source._titleEmoji
      _synopsis = source._synopsis
      _plan = source._plan
      _transcript = source._transcript
      _audio = source._audio
      _visuals = source._visuals
      _cardsState = source._cardsState
      _cards = source._cards
      _latencies = source._latencies
      _log = source._log
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._podcastID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._createdBy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._userPrompt) }()
        case 6: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._answer) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._reasoning) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._title) }()
        case 10: try { try decoder.decodeSingularStringField(value: &_storage._titleEmoji) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._synopsis) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._plan) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._transcript) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._visuals) }()
        case 16: try { try decoder.decodeSingularEnumField(value: &_storage._cardsState) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._cards) }()
        case 100: try { try decoder.decodeSingularMessageField(value: &_storage._latencies) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._log) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._podcastID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._podcastID, fieldNumber: 1)
      }
      if !_storage._createdBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdBy, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._userPrompt.isEmpty {
        try visitor.visitSingularStringField(value: _storage._userPrompt, fieldNumber: 5)
      }
      if _storage._state != .unknown {
        try visitor.visitSingularEnumField(value: _storage._state, fieldNumber: 6)
      }
      try { if let v = _storage._answer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._reasoning.isEmpty {
        try visitor.visitSingularStringField(value: _storage._reasoning, fieldNumber: 8)
      }
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 9)
      }
      if !_storage._titleEmoji.isEmpty {
        try visitor.visitSingularStringField(value: _storage._titleEmoji, fieldNumber: 10)
      }
      if !_storage._synopsis.isEmpty {
        try visitor.visitSingularStringField(value: _storage._synopsis, fieldNumber: 11)
      }
      if !_storage._plan.isEmpty {
        try visitor.visitSingularStringField(value: _storage._plan, fieldNumber: 12)
      }
      try { if let v = _storage._transcript {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._visuals {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      if _storage._cardsState != .unknown {
        try visitor.visitSingularEnumField(value: _storage._cardsState, fieldNumber: 16)
      }
      try { if let v = _storage._cards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._latencies {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 100)
      } }()
      try { if let v = _storage._log {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastProto, rhs: StoredPodcastProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podcastID != rhs_storage._podcastID {return false}
        if _storage._createdBy != rhs_storage._createdBy {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._userPrompt != rhs_storage._userPrompt {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._answer != rhs_storage._answer {return false}
        if _storage._reasoning != rhs_storage._reasoning {return false}
        if _storage._title != rhs_storage._title {return false}
        if _storage._titleEmoji != rhs_storage._titleEmoji {return false}
        if _storage._synopsis != rhs_storage._synopsis {return false}
        if _storage._plan != rhs_storage._plan {return false}
        if _storage._transcript != rhs_storage._transcript {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._visuals != rhs_storage._visuals {return false}
        if _storage._cardsState != rhs_storage._cardsState {return false}
        if _storage._cards != rhs_storage._cards {return false}
        if _storage._latencies != rhs_storage._latencies {return false}
        if _storage._log != rhs_storage._log {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastTranscriptProto, rhs: StoredPodcastTranscriptProto) -> Bool {
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastSectionTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastSectionTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "section_type"),
    2: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sectionType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sectionType != .unknown {
      try visitor.visitSingularEnumField(value: self.sectionType, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastSectionTranscriptProto, rhs: StoredPodcastSectionTranscriptProto) -> Bool {
    if lhs.sectionType != rhs.sectionType {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastTranscriptEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastTranscriptEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "text"),
    3: .standard(proto: "start_millis"),
    4: .standard(proto: "end_millis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.startMillis) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.endMillis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.host != .unknown {
      try visitor.visitSingularEnumField(value: self.host, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    if self.startMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.startMillis, fieldNumber: 3)
    }
    if self.endMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.endMillis, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastTranscriptEntryProto, rhs: StoredPodcastTranscriptEntryProto) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.text != rhs.text {return false}
    if lhs.startMillis != rhs.startMillis {return false}
    if lhs.endMillis != rhs.endMillis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastVisualsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastVisualsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "style_prompt"),
    2: .standard(proto: "thumbnail_prompt"),
    3: .standard(proto: "thumbnail_key"),
    4: .same(proto: "visuals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.stylePrompt) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.thumbnailPrompt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailKey) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.visuals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stylePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.stylePrompt, fieldNumber: 1)
    }
    if !self.thumbnailPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailPrompt, fieldNumber: 2)
    }
    if !self.thumbnailKey.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailKey, fieldNumber: 3)
    }
    if !self.visuals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.visuals, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastVisualsProto, rhs: StoredPodcastVisualsProto) -> Bool {
    if lhs.stylePrompt != rhs.stylePrompt {return false}
    if lhs.thumbnailPrompt != rhs.thumbnailPrompt {return false}
    if lhs.thumbnailKey != rhs.thumbnailKey {return false}
    if lhs.visuals != rhs.visuals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastVisualProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastVisualProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_millis"),
    2: .standard(proto: "image_prompt"),
    3: .standard(proto: "image_key"),
    4: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timestampMillis) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imagePrompt) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.imageKey) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.transition) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.timestampMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.timestampMillis, fieldNumber: 1)
    }
    if !self.imagePrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePrompt, fieldNumber: 2)
    }
    if !self.imageKey.isEmpty {
      try visitor.visitSingularStringField(value: self.imageKey, fieldNumber: 3)
    }
    if self.transition != .undefined {
      try visitor.visitSingularEnumField(value: self.transition, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastVisualProto, rhs: StoredPodcastVisualProto) -> Bool {
    if lhs.timestampMillis != rhs.timestampMillis {return false}
    if lhs.imagePrompt != rhs.imagePrompt {return false}
    if lhs.imageKey != rhs.imageKey {return false}
    if lhs.transition != rhs.transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoredPodcastAudioProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoredPodcastAudioProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "audio_key"),
    2: .standard(proto: "audio_duration"),
    3: .same(proto: "words"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.audioKey) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._audioDuration) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.words) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.audioKey.isEmpty {
      try visitor.visitSingularStringField(value: self.audioKey, fieldNumber: 1)
    }
    try { if let v = self._audioDuration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.words.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.words, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoredPodcastAudioProto, rhs: StoredPodcastAudioProto) -> Bool {
    if lhs.audioKey != rhs.audioKey {return false}
    if lhs._audioDuration != rhs._audioDuration {return false}
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
