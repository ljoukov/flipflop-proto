// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: StoryProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FontNameProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case text // = 0
  case display // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .text
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .text
    case 1: self = .display
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .text: return 0
    case .display: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FontNameProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FontNameProto] = [
    .text,
    .display,
  ]
}

#endif  // swift(>=4.2)

enum FontWeightProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case normal // = 0
  case bold // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .bold
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .bold: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FontWeightProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FontWeightProto] = [
    .normal,
    .bold,
  ]
}

#endif  // swift(>=4.2)

enum FontStyleProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case normal // = 0
  case italic // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .italic
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .italic: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension FontStyleProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [FontStyleProto] = [
    .normal,
    .italic,
  ]
}

#endif  // swift(>=4.2)

enum TextDecorationProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case underline // = 1
  case lineThrough // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .underline
    case 2: self = .lineThrough
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .underline: return 1
    case .lineThrough: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TextDecorationProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TextDecorationProto] = [
    .none,
    .underline,
    .lineThrough,
  ]
}

#endif  // swift(>=4.2)

enum TextAlignmentProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case left // = 0
  case center // = 1
  case right // = 2
  case justify // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .left
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .left
    case 1: self = .center
    case 2: self = .right
    case 3: self = .justify
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .left: return 0
    case .center: return 1
    case .right: return 2
    case .justify: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TextAlignmentProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TextAlignmentProto] = [
    .left,
    .center,
    .right,
    .justify,
  ]
}

#endif  // swift(>=4.2)

enum TextWhitespaceProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case normal // = 0
  case preWrap // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .normal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .normal
    case 1: self = .preWrap
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .normal: return 0
    case .preWrap: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TextWhitespaceProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TextWhitespaceProto] = [
    .normal,
    .preWrap,
  ]
}

#endif  // swift(>=4.2)

enum TextHyphensProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case manual // = 1
  case auto // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .manual
    case 2: self = .auto
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .manual: return 1
    case .auto: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension TextHyphensProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [TextHyphensProto] = [
    .none,
    .manual,
    .auto,
  ]
}

#endif  // swift(>=4.2)

struct GetStoriesRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetStoriesResponseProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stories: StoriesProto {
    get {return _stories ?? StoriesProto()}
    set {_stories = newValue}
  }
  /// Returns true if `stories` has been explicitly set.
  var hasStories: Bool {return self._stories != nil}
  /// Clears the value of `stories`. Subsequent reads from it will return its default value.
  mutating func clearStories() {self._stories = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _stories: StoriesProto? = nil
}

struct CreateStoryRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cards: [CardProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreateStoryResponseProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UpdateStoryRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storyID: String = String()

  var cards: [CardProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UpdateStoryResponseProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeleteStoryRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeleteStoryResponseProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StoryApiRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var request: StoryApiRequestProto.OneOf_Request? = nil

  var getStories: GetStoriesRequestProto {
    get {
      if case .getStories(let v)? = request {return v}
      return GetStoriesRequestProto()
    }
    set {request = .getStories(newValue)}
  }

  var createStory: CreateStoryRequestProto {
    get {
      if case .createStory(let v)? = request {return v}
      return CreateStoryRequestProto()
    }
    set {request = .createStory(newValue)}
  }

  var updateStory: UpdateStoryRequestProto {
    get {
      if case .updateStory(let v)? = request {return v}
      return UpdateStoryRequestProto()
    }
    set {request = .updateStory(newValue)}
  }

  var deleteStory: DeleteStoryRequestProto {
    get {
      if case .deleteStory(let v)? = request {return v}
      return DeleteStoryRequestProto()
    }
    set {request = .deleteStory(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case getStories(GetStoriesRequestProto)
    case createStory(CreateStoryRequestProto)
    case updateStory(UpdateStoryRequestProto)
    case deleteStory(DeleteStoryRequestProto)

  #if !swift(>=4.1)
    static func ==(lhs: StoryApiRequestProto.OneOf_Request, rhs: StoryApiRequestProto.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getStories, .getStories): return {
        guard case .getStories(let l) = lhs, case .getStories(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createStory, .createStory): return {
        guard case .createStory(let l) = lhs, case .createStory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateStory, .updateStory): return {
        guard case .updateStory(let l) = lhs, case .updateStory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteStory, .deleteStory): return {
        guard case .deleteStory(let l) = lhs, case .deleteStory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct StoryApiResponseProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var response: StoryApiResponseProto.OneOf_Response? = nil

  var getStories: GetStoriesResponseProto {
    get {
      if case .getStories(let v)? = response {return v}
      return GetStoriesResponseProto()
    }
    set {response = .getStories(newValue)}
  }

  var createStory: CreateStoryResponseProto {
    get {
      if case .createStory(let v)? = response {return v}
      return CreateStoryResponseProto()
    }
    set {response = .createStory(newValue)}
  }

  var updateStory: UpdateStoryResponseProto {
    get {
      if case .updateStory(let v)? = response {return v}
      return UpdateStoryResponseProto()
    }
    set {response = .updateStory(newValue)}
  }

  var deleteStory: DeleteStoryResponseProto {
    get {
      if case .deleteStory(let v)? = response {return v}
      return DeleteStoryResponseProto()
    }
    set {response = .deleteStory(newValue)}
  }

  var latencies: Dictionary<String,SwiftProtobuf.Google_Protobuf_Duration> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Response: Equatable {
    case getStories(GetStoriesResponseProto)
    case createStory(CreateStoryResponseProto)
    case updateStory(UpdateStoryResponseProto)
    case deleteStory(DeleteStoryResponseProto)

  #if !swift(>=4.1)
    static func ==(lhs: StoryApiResponseProto.OneOf_Response, rhs: StoryApiResponseProto.OneOf_Response) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.getStories, .getStories): return {
        guard case .getStories(let l) = lhs, case .getStories(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.createStory, .createStory): return {
        guard case .createStory(let l) = lhs, case .createStory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateStory, .updateStory): return {
        guard case .updateStory(let l) = lhs, case .updateStory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deleteStory, .deleteStory): return {
        guard case .deleteStory(let l) = lhs, case .deleteStory(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct StoriesProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestamp: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _timestamp ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var stories: [StoryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timestamp: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct StoryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var createdBy: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var lastModifiedBy: String = String()

  var lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _lastModifiedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_lastModifiedAt = newValue}
  }
  /// Returns true if `lastModifiedAt` has been explicitly set.
  var hasLastModifiedAt: Bool {return self._lastModifiedAt != nil}
  /// Clears the value of `lastModifiedAt`. Subsequent reads from it will return its default value.
  mutating func clearLastModifiedAt() {self._lastModifiedAt = nil}

  var title: String = String()

  var cards: [CardProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _lastModifiedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct CardProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var frontFace: CardFaceProto {
    get {return _frontFace ?? CardFaceProto()}
    set {_frontFace = newValue}
  }
  /// Returns true if `frontFace` has been explicitly set.
  var hasFrontFace: Bool {return self._frontFace != nil}
  /// Clears the value of `frontFace`. Subsequent reads from it will return its default value.
  mutating func clearFrontFace() {self._frontFace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _frontFace: CardFaceProto? = nil
}

struct CardFaceProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var blocks: [CardBlockProto] = []

  var hashTags: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CardBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: CardBlockProto.OneOf_Type? = nil

  var space: SpaceBlockProto {
    get {
      if case .space(let v)? = type {return v}
      return SpaceBlockProto()
    }
    set {type = .space(newValue)}
  }

  var image: ImageBlockProto {
    get {
      if case .image(let v)? = type {return v}
      return ImageBlockProto()
    }
    set {type = .image(newValue)}
  }

  var text: TextBlockProto {
    get {
      if case .text(let v)? = type {return v}
      return TextBlockProto()
    }
    set {type = .text(newValue)}
  }

  var flip: FlipBlockProto {
    get {
      if case .flip(let v)? = type {return v}
      return FlipBlockProto()
    }
    set {type = .flip(newValue)}
  }

  var coffee: CoffeeBlockProto {
    get {
      if case .coffee(let v)? = type {return v}
      return CoffeeBlockProto()
    }
    set {type = .coffee(newValue)}
  }

  var reveal: RevealBlockProto {
    get {
      if case .reveal(let v)? = type {return v}
      return RevealBlockProto()
    }
    set {type = .reveal(newValue)}
  }

  var choice: ChoiceBlockProto {
    get {
      if case .choice(let v)? = type {return v}
      return ChoiceBlockProto()
    }
    set {type = .choice(newValue)}
  }

  var question: QuestionBlockProto {
    get {
      if case .question(let v)? = type {return v}
      return QuestionBlockProto()
    }
    set {type = .question(newValue)}
  }

  var prompt: PromptBlockProto {
    get {
      if case .prompt(let v)? = type {return v}
      return PromptBlockProto()
    }
    set {type = .prompt(newValue)}
  }

  var revealBack: RevealBackBlockProto {
    get {
      if case .revealBack(let v)? = type {return v}
      return RevealBackBlockProto()
    }
    set {type = .revealBack(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case space(SpaceBlockProto)
    case image(ImageBlockProto)
    case text(TextBlockProto)
    case flip(FlipBlockProto)
    case coffee(CoffeeBlockProto)
    case reveal(RevealBlockProto)
    case choice(ChoiceBlockProto)
    case question(QuestionBlockProto)
    case prompt(PromptBlockProto)
    case revealBack(RevealBackBlockProto)

  #if !swift(>=4.1)
    static func ==(lhs: CardBlockProto.OneOf_Type, rhs: CardBlockProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.space, .space): return {
        guard case .space(let l) = lhs, case .space(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.image, .image): return {
        guard case .image(let l) = lhs, case .image(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.text, .text): return {
        guard case .text(let l) = lhs, case .text(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.flip, .flip): return {
        guard case .flip(let l) = lhs, case .flip(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.coffee, .coffee): return {
        guard case .coffee(let l) = lhs, case .coffee(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.reveal, .reveal): return {
        guard case .reveal(let l) = lhs, case .reveal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.choice, .choice): return {
        guard case .choice(let l) = lhs, case .choice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.question, .question): return {
        guard case .question(let l) = lhs, case .question(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.prompt, .prompt): return {
        guard case .prompt(let l) = lhs, case .prompt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.revealBack, .revealBack): return {
        guard case .revealBack(let l) = lhs, case .revealBack(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct SpaceBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scale: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ImageRefProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storagePath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ImageBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imageRef: ImageRefProto {
    get {return _imageRef ?? ImageRefProto()}
    set {_imageRef = newValue}
  }
  /// Returns true if `imageRef` has been explicitly set.
  var hasImageRef: Bool {return self._imageRef != nil}
  /// Clears the value of `imageRef`. Subsequent reads from it will return its default value.
  mutating func clearImageRef() {self._imageRef = nil}

  var scale: Float = 0

  var borderRadius: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _imageRef: ImageRefProto? = nil
}

struct TextSpanProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var fontWeight: FontWeightProto = .normal

  var fontStyle: FontStyleProto = .normal

  var decoration: TextDecorationProto = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Box of text with styles
struct StyledTextProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spans: [TextSpanProto] = []

  var fontName: FontNameProto = .text

  var fontSize: Float = 0

  var paddingStart: Float = 0

  var paddingEnd: Float = 0

  var align: TextAlignmentProto = .left

  var whitespace: TextWhitespaceProto = .normal

  var hyphens: TextHyphensProto = .none

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TextBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var styledText: StyledTextProto {
    get {return _styledText ?? StyledTextProto()}
    set {_styledText = newValue}
  }
  /// Returns true if `styledText` has been explicitly set.
  var hasStyledText: Bool {return self._styledText != nil}
  /// Clears the value of `styledText`. Subsequent reads from it will return its default value.
  mutating func clearStyledText() {self._styledText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _styledText: StyledTextProto? = nil
}

struct FlipBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CoffeeBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  /// moves the label along the circle
  var startOffset: Float = 0

  var imageRef: ImageRefProto {
    get {return _imageRef ?? ImageRefProto()}
    set {_imageRef = newValue}
  }
  /// Returns true if `imageRef` has been explicitly set.
  var hasImageRef: Bool {return self._imageRef != nil}
  /// Clears the value of `imageRef`. Subsequent reads from it will return its default value.
  mutating func clearImageRef() {self._imageRef = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _imageRef: ImageRefProto? = nil
}

struct RevealBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scale: Float = 0

  var label: String = String()

  var text: StyledTextProto {
    get {return _text ?? StyledTextProto()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _text: StyledTextProto? = nil
}

struct ChoiceBlockOptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: StyledTextProto {
    get {return _text ?? StyledTextProto()}
    set {_text = newValue}
  }
  /// Returns true if `text` has been explicitly set.
  var hasText: Bool {return self._text != nil}
  /// Clears the value of `text`. Subsequent reads from it will return its default value.
  mutating func clearText() {self._text = nil}

  var fraction: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _text: StyledTextProto? = nil
}

struct ChoiceBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scale: Float = 0

  var options: [ChoiceBlockOptionProto] = []

  var correctIndex: Int32 = 0

  var correctAnswerFace: CardFaceProto {
    get {return _correctAnswerFace ?? CardFaceProto()}
    set {_correctAnswerFace = newValue}
  }
  /// Returns true if `correctAnswerFace` has been explicitly set.
  var hasCorrectAnswerFace: Bool {return self._correctAnswerFace != nil}
  /// Clears the value of `correctAnswerFace`. Subsequent reads from it will return its default value.
  mutating func clearCorrectAnswerFace() {self._correctAnswerFace = nil}

  var wrongAnswerFace: CardFaceProto {
    get {return _wrongAnswerFace ?? CardFaceProto()}
    set {_wrongAnswerFace = newValue}
  }
  /// Returns true if `wrongAnswerFace` has been explicitly set.
  var hasWrongAnswerFace: Bool {return self._wrongAnswerFace != nil}
  /// Clears the value of `wrongAnswerFace`. Subsequent reads from it will return its default value.
  mutating func clearWrongAnswerFace() {self._wrongAnswerFace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _correctAnswerFace: CardFaceProto? = nil
  fileprivate var _wrongAnswerFace: CardFaceProto? = nil
}

struct QuestionBlockOptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var fraction: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct QuestionBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var scale: Float = 0

  var options: [QuestionBlockOptionProto] = []

  var correctIndex: Int32 = 0

  var correctAnswerFace: CardFaceProto {
    get {return _correctAnswerFace ?? CardFaceProto()}
    set {_correctAnswerFace = newValue}
  }
  /// Returns true if `correctAnswerFace` has been explicitly set.
  var hasCorrectAnswerFace: Bool {return self._correctAnswerFace != nil}
  /// Clears the value of `correctAnswerFace`. Subsequent reads from it will return its default value.
  mutating func clearCorrectAnswerFace() {self._correctAnswerFace = nil}

  var wrongAnswerFace: CardFaceProto {
    get {return _wrongAnswerFace ?? CardFaceProto()}
    set {_wrongAnswerFace = newValue}
  }
  /// Returns true if `wrongAnswerFace` has been explicitly set.
  var hasWrongAnswerFace: Bool {return self._wrongAnswerFace != nil}
  /// Clears the value of `wrongAnswerFace`. Subsequent reads from it will return its default value.
  mutating func clearWrongAnswerFace() {self._wrongAnswerFace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _correctAnswerFace: CardFaceProto? = nil
  fileprivate var _wrongAnswerFace: CardFaceProto? = nil
}

struct PromptBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RevealBackBlockProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var backFace: CardFaceProto {
    get {return _backFace ?? CardFaceProto()}
    set {_backFace = newValue}
  }
  /// Returns true if `backFace` has been explicitly set.
  var hasBackFace: Bool {return self._backFace != nil}
  /// Clears the value of `backFace`. Subsequent reads from it will return its default value.
  mutating func clearBackFace() {self._backFace = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _backFace: CardFaceProto? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FontNameProto: @unchecked Sendable {}
extension FontWeightProto: @unchecked Sendable {}
extension FontStyleProto: @unchecked Sendable {}
extension TextDecorationProto: @unchecked Sendable {}
extension TextAlignmentProto: @unchecked Sendable {}
extension TextWhitespaceProto: @unchecked Sendable {}
extension TextHyphensProto: @unchecked Sendable {}
extension GetStoriesRequestProto: @unchecked Sendable {}
extension GetStoriesResponseProto: @unchecked Sendable {}
extension CreateStoryRequestProto: @unchecked Sendable {}
extension CreateStoryResponseProto: @unchecked Sendable {}
extension UpdateStoryRequestProto: @unchecked Sendable {}
extension UpdateStoryResponseProto: @unchecked Sendable {}
extension DeleteStoryRequestProto: @unchecked Sendable {}
extension DeleteStoryResponseProto: @unchecked Sendable {}
extension StoryApiRequestProto: @unchecked Sendable {}
extension StoryApiRequestProto.OneOf_Request: @unchecked Sendable {}
extension StoryApiResponseProto: @unchecked Sendable {}
extension StoryApiResponseProto.OneOf_Response: @unchecked Sendable {}
extension StoriesProto: @unchecked Sendable {}
extension StoryProto: @unchecked Sendable {}
extension CardProto: @unchecked Sendable {}
extension CardFaceProto: @unchecked Sendable {}
extension CardBlockProto: @unchecked Sendable {}
extension CardBlockProto.OneOf_Type: @unchecked Sendable {}
extension SpaceBlockProto: @unchecked Sendable {}
extension ImageRefProto: @unchecked Sendable {}
extension ImageBlockProto: @unchecked Sendable {}
extension TextSpanProto: @unchecked Sendable {}
extension StyledTextProto: @unchecked Sendable {}
extension TextBlockProto: @unchecked Sendable {}
extension FlipBlockProto: @unchecked Sendable {}
extension CoffeeBlockProto: @unchecked Sendable {}
extension RevealBlockProto: @unchecked Sendable {}
extension ChoiceBlockOptionProto: @unchecked Sendable {}
extension ChoiceBlockProto: @unchecked Sendable {}
extension QuestionBlockOptionProto: @unchecked Sendable {}
extension QuestionBlockProto: @unchecked Sendable {}
extension PromptBlockProto: @unchecked Sendable {}
extension RevealBackBlockProto: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension FontNameProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FONT_NAME_PROTO_TEXT"),
    1: .same(proto: "FONT_NAME_PROTO_DISPLAY"),
  ]
}

extension FontWeightProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FONT_WEIGHT_PROTO_NORMAL"),
    1: .same(proto: "FONT_WEIGHT_PROTO_BOLD"),
  ]
}

extension FontStyleProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "FONT_STYLE_PROTO_NORMAL"),
    1: .same(proto: "FONT_STYLE_PROTO_ITALIC"),
  ]
}

extension TextDecorationProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_DECORATION_PROTO_NONE"),
    1: .same(proto: "TEXT_DECORATION_PROTO_UNDERLINE"),
    2: .same(proto: "TEXT_DECORATION_PROTO_LINE_THROUGH"),
  ]
}

extension TextAlignmentProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_ALIGNMENT_PROTO_LEFT"),
    1: .same(proto: "TEXT_ALIGNMENT_PROTO_CENTER"),
    2: .same(proto: "TEXT_ALIGNMENT_PROTO_RIGHT"),
    3: .same(proto: "TEXT_ALIGNMENT_PROTO_JUSTIFY"),
  ]
}

extension TextWhitespaceProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_WHITESPACE_PROTO_NORMAL"),
    1: .same(proto: "TEXT_WHITESPACE_PROTO_PRE_WRAP"),
  ]
}

extension TextHyphensProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEXT_HYPHENS_PROTO_NONE"),
    1: .same(proto: "TEXT_HYPHENS_PROTO_MANUAL"),
    2: .same(proto: "TEXT_HYPHENS_PROTO_AUTO"),
  ]
}

extension GetStoriesRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetStoriesRequestProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetStoriesRequestProto, rhs: GetStoriesRequestProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetStoriesResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetStoriesResponseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "stories"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._stories) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._stories {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetStoriesResponseProto, rhs: GetStoriesResponseProto) -> Bool {
    if lhs._stories != rhs._stories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateStoryRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreateStoryRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreateStoryRequestProto, rhs: CreateStoryRequestProto) -> Bool {
    if lhs.cards != rhs.cards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateStoryResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreateStoryResponseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreateStoryResponseProto, rhs: CreateStoryResponseProto) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateStoryRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateStoryRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .same(proto: "cards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    if !self.cards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cards, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateStoryRequestProto, rhs: UpdateStoryRequestProto) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.cards != rhs.cards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateStoryResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UpdateStoryResponseProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UpdateStoryResponseProto, rhs: UpdateStoryResponseProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteStoryRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteStoryRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteStoryRequestProto, rhs: DeleteStoryRequestProto) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteStoryResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteStoryResponseProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteStoryResponseProto, rhs: DeleteStoryResponseProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoryApiRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoryApiRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_stories"),
    2: .standard(proto: "create_story"),
    3: .standard(proto: "update_story"),
    4: .standard(proto: "delete_story"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GetStoriesRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .getStories(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .getStories(v)
        }
      }()
      case 2: try {
        var v: CreateStoryRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .createStory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .createStory(v)
        }
      }()
      case 3: try {
        var v: UpdateStoryRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .updateStory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .updateStory(v)
        }
      }()
      case 4: try {
        var v: DeleteStoryRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteStory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteStory(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.request {
    case .getStories?: try {
      guard case .getStories(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createStory?: try {
      guard case .createStory(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateStory?: try {
      guard case .updateStory(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteStory?: try {
      guard case .deleteStory(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoryApiRequestProto, rhs: StoryApiRequestProto) -> Bool {
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoryApiResponseProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoryApiResponseProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "get_stories"),
    2: .standard(proto: "create_story"),
    3: .standard(proto: "update_story"),
    4: .standard(proto: "delete_story"),
    5: .same(proto: "latencies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GetStoriesResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .getStories(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .getStories(v)
        }
      }()
      case 2: try {
        var v: CreateStoryResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .createStory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .createStory(v)
        }
      }()
      case 3: try {
        var v: UpdateStoryResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .updateStory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .updateStory(v)
        }
      }()
      case 4: try {
        var v: DeleteStoryResponseProto?
        var hadOneofValue = false
        if let current = self.response {
          hadOneofValue = true
          if case .deleteStory(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.response = .deleteStory(v)
        }
      }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: &self.latencies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.response {
    case .getStories?: try {
      guard case .getStories(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .createStory?: try {
      guard case .createStory(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .updateStory?: try {
      guard case .updateStory(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .deleteStory?: try {
      guard case .deleteStory(let v)? = self.response else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.latencies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: self.latencies, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoryApiResponseProto, rhs: StoryApiResponseProto) -> Bool {
    if lhs.response != rhs.response {return false}
    if lhs.latencies != rhs.latencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoriesProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoriesProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "stories"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timestamp) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.stories) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timestamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.stories.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.stories, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoriesProto, rhs: StoriesProto) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.stories != rhs.stories {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StoryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StoryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "created_by"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "last_modified_by"),
    5: .standard(proto: "last_modified_at"),
    6: .same(proto: "title"),
    7: .same(proto: "cards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.createdBy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lastModifiedBy) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._lastModifiedAt) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.cards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.createdBy.isEmpty {
      try visitor.visitSingularStringField(value: self.createdBy, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.lastModifiedBy.isEmpty {
      try visitor.visitSingularStringField(value: self.lastModifiedBy, fieldNumber: 4)
    }
    try { if let v = self._lastModifiedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 6)
    }
    if !self.cards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cards, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StoryProto, rhs: StoryProto) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.createdBy != rhs.createdBy {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.lastModifiedBy != rhs.lastModifiedBy {return false}
    if lhs._lastModifiedAt != rhs._lastModifiedAt {return false}
    if lhs.title != rhs.title {return false}
    if lhs.cards != rhs.cards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "front_face"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._frontFace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._frontFace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CardProto, rhs: CardProto) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._frontFace != rhs._frontFace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CardFaceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CardFaceProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "blocks"),
    2: .standard(proto: "hash_tags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.blocks) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.hashTags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.blocks.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.blocks, fieldNumber: 1)
    }
    if !self.hashTags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hashTags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CardFaceProto, rhs: CardFaceProto) -> Bool {
    if lhs.blocks != rhs.blocks {return false}
    if lhs.hashTags != rhs.hashTags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CardBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CardBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "space"),
    2: .same(proto: "image"),
    3: .same(proto: "text"),
    4: .same(proto: "flip"),
    5: .same(proto: "coffee"),
    6: .same(proto: "reveal"),
    7: .same(proto: "choice"),
    8: .same(proto: "question"),
    9: .same(proto: "prompt"),
    10: .standard(proto: "reveal_back"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: SpaceBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .space(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .space(v)
        }
      }()
      case 2: try {
        var v: ImageBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .image(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .image(v)
        }
      }()
      case 3: try {
        var v: TextBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .text(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .text(v)
        }
      }()
      case 4: try {
        var v: FlipBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .flip(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .flip(v)
        }
      }()
      case 5: try {
        var v: CoffeeBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .coffee(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .coffee(v)
        }
      }()
      case 6: try {
        var v: RevealBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .reveal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .reveal(v)
        }
      }()
      case 7: try {
        var v: ChoiceBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .choice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .choice(v)
        }
      }()
      case 8: try {
        var v: QuestionBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .question(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .question(v)
        }
      }()
      case 9: try {
        var v: PromptBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .prompt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .prompt(v)
        }
      }()
      case 10: try {
        var v: RevealBackBlockProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .revealBack(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .revealBack(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .space?: try {
      guard case .space(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .image?: try {
      guard case .image(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .text?: try {
      guard case .text(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .flip?: try {
      guard case .flip(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .coffee?: try {
      guard case .coffee(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .reveal?: try {
      guard case .reveal(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .choice?: try {
      guard case .choice(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .question?: try {
      guard case .question(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .prompt?: try {
      guard case .prompt(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .revealBack?: try {
      guard case .revealBack(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CardBlockProto, rhs: CardBlockProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SpaceBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SpaceBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SpaceBlockProto, rhs: SpaceBlockProto) -> Bool {
    if lhs.scale != rhs.scale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageRefProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageRefProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "storage_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storagePath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.storagePath, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageRefProto, rhs: ImageRefProto) -> Bool {
    if lhs.storagePath != rhs.storagePath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImageBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ImageBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "image_ref"),
    2: .same(proto: "scale"),
    3: .standard(proto: "border_radius"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._imageRef) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.borderRadius) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imageRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 2)
    }
    if self.borderRadius != 0 {
      try visitor.visitSingularFloatField(value: self.borderRadius, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ImageBlockProto, rhs: ImageBlockProto) -> Bool {
    if lhs._imageRef != rhs._imageRef {return false}
    if lhs.scale != rhs.scale {return false}
    if lhs.borderRadius != rhs.borderRadius {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextSpanProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextSpanProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .standard(proto: "font_weight"),
    3: .standard(proto: "font_style"),
    4: .same(proto: "decoration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.fontWeight) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.fontStyle) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.decoration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    if self.fontWeight != .normal {
      try visitor.visitSingularEnumField(value: self.fontWeight, fieldNumber: 2)
    }
    if self.fontStyle != .normal {
      try visitor.visitSingularEnumField(value: self.fontStyle, fieldNumber: 3)
    }
    if self.decoration != .none {
      try visitor.visitSingularEnumField(value: self.decoration, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextSpanProto, rhs: TextSpanProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.fontWeight != rhs.fontWeight {return false}
    if lhs.fontStyle != rhs.fontStyle {return false}
    if lhs.decoration != rhs.decoration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StyledTextProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StyledTextProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spans"),
    2: .standard(proto: "font_name"),
    3: .standard(proto: "font_size"),
    4: .standard(proto: "padding_start"),
    5: .standard(proto: "padding_end"),
    6: .same(proto: "align"),
    7: .same(proto: "whitespace"),
    8: .same(proto: "hyphens"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.spans) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.fontName) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.fontSize) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self.paddingStart) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self.paddingEnd) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.align) }()
      case 7: try { try decoder.decodeSingularEnumField(value: &self.whitespace) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.hyphens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.spans.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.spans, fieldNumber: 1)
    }
    if self.fontName != .text {
      try visitor.visitSingularEnumField(value: self.fontName, fieldNumber: 2)
    }
    if self.fontSize != 0 {
      try visitor.visitSingularFloatField(value: self.fontSize, fieldNumber: 3)
    }
    if self.paddingStart != 0 {
      try visitor.visitSingularFloatField(value: self.paddingStart, fieldNumber: 4)
    }
    if self.paddingEnd != 0 {
      try visitor.visitSingularFloatField(value: self.paddingEnd, fieldNumber: 5)
    }
    if self.align != .left {
      try visitor.visitSingularEnumField(value: self.align, fieldNumber: 6)
    }
    if self.whitespace != .normal {
      try visitor.visitSingularEnumField(value: self.whitespace, fieldNumber: 7)
    }
    if self.hyphens != .none {
      try visitor.visitSingularEnumField(value: self.hyphens, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StyledTextProto, rhs: StyledTextProto) -> Bool {
    if lhs.spans != rhs.spans {return false}
    if lhs.fontName != rhs.fontName {return false}
    if lhs.fontSize != rhs.fontSize {return false}
    if lhs.paddingStart != rhs.paddingStart {return false}
    if lhs.paddingEnd != rhs.paddingEnd {return false}
    if lhs.align != rhs.align {return false}
    if lhs.whitespace != rhs.whitespace {return false}
    if lhs.hyphens != rhs.hyphens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TextBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TextBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "styled_text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._styledText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._styledText {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TextBlockProto, rhs: TextBlockProto) -> Bool {
    if lhs._styledText != rhs._styledText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FlipBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FlipBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FlipBlockProto, rhs: FlipBlockProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CoffeeBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CoffeeBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .standard(proto: "start_offset"),
    3: .standard(proto: "image_ref"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startOffset) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._imageRef) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.startOffset != 0 {
      try visitor.visitSingularFloatField(value: self.startOffset, fieldNumber: 2)
    }
    try { if let v = self._imageRef {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CoffeeBlockProto, rhs: CoffeeBlockProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.startOffset != rhs.startOffset {return false}
    if lhs._imageRef != rhs._imageRef {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RevealBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RevealBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
    2: .same(proto: "label"),
    3: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RevealBlockProto, rhs: RevealBlockProto) -> Bool {
    if lhs.scale != rhs.scale {return false}
    if lhs.label != rhs.label {return false}
    if lhs._text != rhs._text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChoiceBlockOptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChoiceBlockOptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
    2: .same(proto: "fraction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._text) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.fraction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._text {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.fraction != 0 {
      try visitor.visitSingularFloatField(value: self.fraction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChoiceBlockOptionProto, rhs: ChoiceBlockOptionProto) -> Bool {
    if lhs._text != rhs._text {return false}
    if lhs.fraction != rhs.fraction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChoiceBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChoiceBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
    2: .same(proto: "options"),
    3: .standard(proto: "correct_index"),
    4: .standard(proto: "correct_answer_face"),
    5: .standard(proto: "wrong_answer_face"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.correctIndex) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._correctAnswerFace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._wrongAnswerFace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 2)
    }
    if self.correctIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.correctIndex, fieldNumber: 3)
    }
    try { if let v = self._correctAnswerFace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._wrongAnswerFace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChoiceBlockProto, rhs: ChoiceBlockProto) -> Bool {
    if lhs.scale != rhs.scale {return false}
    if lhs.options != rhs.options {return false}
    if lhs.correctIndex != rhs.correctIndex {return false}
    if lhs._correctAnswerFace != rhs._correctAnswerFace {return false}
    if lhs._wrongAnswerFace != rhs._wrongAnswerFace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QuestionBlockOptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "QuestionBlockOptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "fraction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.fraction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if self.fraction != 0 {
      try visitor.visitSingularFloatField(value: self.fraction, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QuestionBlockOptionProto, rhs: QuestionBlockOptionProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.fraction != rhs.fraction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension QuestionBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "QuestionBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "scale"),
    2: .same(proto: "options"),
    3: .standard(proto: "correct_index"),
    4: .standard(proto: "correct_answer_face"),
    5: .standard(proto: "wrong_answer_face"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self.scale) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.correctIndex) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._correctAnswerFace) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._wrongAnswerFace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.scale != 0 {
      try visitor.visitSingularFloatField(value: self.scale, fieldNumber: 1)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 2)
    }
    if self.correctIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.correctIndex, fieldNumber: 3)
    }
    try { if let v = self._correctAnswerFace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._wrongAnswerFace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: QuestionBlockProto, rhs: QuestionBlockProto) -> Bool {
    if lhs.scale != rhs.scale {return false}
    if lhs.options != rhs.options {return false}
    if lhs.correctIndex != rhs.correctIndex {return false}
    if lhs._correctAnswerFace != rhs._correctAnswerFace {return false}
    if lhs._wrongAnswerFace != rhs._wrongAnswerFace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PromptBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PromptBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PromptBlockProto, rhs: PromptBlockProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RevealBackBlockProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RevealBackBlockProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .standard(proto: "back_face"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._backFace) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    try { if let v = self._backFace {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RevealBackBlockProto, rhs: RevealBackBlockProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs._backFace != rhs._backFace {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
