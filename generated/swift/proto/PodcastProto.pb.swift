// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: PodcastProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PodcastBadgeProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefined // = 0
  case none // = 1
  case listen // = 2
  case poll // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .none
    case 2: self = .listen
    case 3: self = .poll
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .none: return 1
    case .listen: return 2
    case .poll: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PodcastBadgeProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PodcastBadgeProto] = [
    .undefined,
    .none,
    .listen,
    .poll,
  ]
}

#endif  // swift(>=4.2)

enum PodcastVisualTransitionProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case undefined // = 0
  case dissolve // = 1
  case swipe // = 2
  case barSwipe // = 3
  case pageCurl // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .dissolve
    case 2: self = .swipe
    case 3: self = .barSwipe
    case 4: self = .pageCurl
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .dissolve: return 1
    case .swipe: return 2
    case .barSwipe: return 3
    case .pageCurl: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PodcastVisualTransitionProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PodcastVisualTransitionProto] = [
    .undefined,
    .dissolve,
    .swipe,
    .barSwipe,
    .pageCurl,
  ]
}

#endif  // swift(>=4.2)

enum PodcastHostProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case male // = 1
  case female // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .male
    case 2: self = .female
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .male: return 1
    case .female: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PodcastHostProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PodcastHostProto] = [
    .unknown,
    .male,
    .female,
  ]
}

#endif  // swift(>=4.2)

struct PodcastStreamApiRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encodedUserAuth: String = String()

  var request: PodcastStreamApiRequestProto.OneOf_Request? = nil

  var create: CreatePodcastRequestProto {
    get {
      if case .create(let v)? = request {return v}
      return CreatePodcastRequestProto()
    }
    set {request = .create(newValue)}
  }

  var generate: GeneratePodcastRequestProto {
    get {
      if case .generate(let v)? = request {return v}
      return GeneratePodcastRequestProto()
    }
    set {request = .generate(newValue)}
  }

  var list: ListPodcastsRequestProto {
    get {
      if case .list(let v)? = request {return v}
      return ListPodcastsRequestProto()
    }
    set {request = .list(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case create(CreatePodcastRequestProto)
    case generate(GeneratePodcastRequestProto)
    case list(ListPodcastsRequestProto)

  #if !swift(>=4.1)
    static func ==(lhs: PodcastStreamApiRequestProto.OneOf_Request, rhs: PodcastStreamApiRequestProto.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.create, .create): return {
        guard case .create(let l) = lhs, case .create(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.generate, .generate): return {
        guard case .generate(let l) = lhs, case .generate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.list, .list): return {
        guard case .list(let l) = lhs, case .list(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PodcastStreamApiResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present the token was refreshed and the client should use this new one
  /// from now onwards.
  var refreshedEncodedUserAuth: String = String()

  var header: PodcastStreamApiResponseHeaderProto.OneOf_Header? = nil

  var createHeader: CreatePodcastResponseHeaderProto {
    get {
      if case .createHeader(let v)? = header {return v}
      return CreatePodcastResponseHeaderProto()
    }
    set {header = .createHeader(newValue)}
  }

  var generate: GeneratePodcastResponseHeaderProto {
    get {
      if case .generate(let v)? = header {return v}
      return GeneratePodcastResponseHeaderProto()
    }
    set {header = .generate(newValue)}
  }

  var list: ListPodcastsResponseHeaderProto {
    get {
      if case .list(let v)? = header {return v}
      return ListPodcastsResponseHeaderProto()
    }
    set {header = .list(newValue)}
  }

  var latencies: Dictionary<String,SwiftProtobuf.Google_Protobuf_Duration> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Header: Equatable {
    case createHeader(CreatePodcastResponseHeaderProto)
    case generate(GeneratePodcastResponseHeaderProto)
    case list(ListPodcastsResponseHeaderProto)

  #if !swift(>=4.1)
    static func ==(lhs: PodcastStreamApiResponseHeaderProto.OneOf_Header, rhs: PodcastStreamApiResponseHeaderProto.OneOf_Header) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createHeader, .createHeader): return {
        guard case .createHeader(let l) = lhs, case .createHeader(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.generate, .generate): return {
        guard case .generate(let l) = lhs, case .generate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.list, .list): return {
        guard case .list(let l) = lhs, case .list(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PodcastStreamApiResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responseDelta: PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta? = nil

  var createDelta: CreatePodcastResponseDeltaProto {
    get {
      if case .createDelta(let v)? = responseDelta {return v}
      return CreatePodcastResponseDeltaProto()
    }
    set {responseDelta = .createDelta(newValue)}
  }

  var generateDelta: GeneratePodcastResponseDeltaProto {
    get {
      if case .generateDelta(let v)? = responseDelta {return v}
      return GeneratePodcastResponseDeltaProto()
    }
    set {responseDelta = .generateDelta(newValue)}
  }

  var listDelta: ListPodcastsResponseDeltaProto {
    get {
      if case .listDelta(let v)? = responseDelta {return v}
      return ListPodcastsResponseDeltaProto()
    }
    set {responseDelta = .listDelta(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResponseDelta: Equatable {
    case createDelta(CreatePodcastResponseDeltaProto)
    case generateDelta(GeneratePodcastResponseDeltaProto)
    case listDelta(ListPodcastsResponseDeltaProto)

  #if !swift(>=4.1)
    static func ==(lhs: PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta, rhs: PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createDelta, .createDelta): return {
        guard case .createDelta(let l) = lhs, case .createDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.generateDelta, .generateDelta): return {
        guard case .generateDelta(let l) = lhs, case .generateDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listDelta, .listDelta): return {
        guard case .listDelta(let l) = lhs, case .listDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct CreatePodcastRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prompt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreatePodcastResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreatePodcastResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: CreatePodcastResponseDeltaProto.OneOf_Type? = nil

  var separator: Bool {
    get {
      if case .separator(let v)? = type {return v}
      return false
    }
    set {type = .separator(newValue)}
  }

  /// This is the last delta message
  var errorNoTopic: Bool {
    get {
      if case .errorNoTopic(let v)? = type {return v}
      return false
    }
    set {type = .errorNoTopic(newValue)}
  }

  /// IDs start at 10
  var podcast: PodcastProto {
    get {
      if case .podcast(let v)? = type {return v}
      return PodcastProto()
    }
    set {type = .podcast(newValue)}
  }

  var answer: PodcastPromptAnswerProto {
    get {
      if case .answer(let v)? = type {return v}
      return PodcastPromptAnswerProto()
    }
    set {type = .answer(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case separator(Bool)
    /// This is the last delta message
    case errorNoTopic(Bool)
    /// IDs start at 10
    case podcast(PodcastProto)
    case answer(PodcastPromptAnswerProto)

  #if !swift(>=4.1)
    static func ==(lhs: CreatePodcastResponseDeltaProto.OneOf_Type, rhs: CreatePodcastResponseDeltaProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.separator, .separator): return {
        guard case .separator(let l) = lhs, case .separator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorNoTopic, .errorNoTopic): return {
        guard case .errorNoTopic(let l) = lhs, case .errorNoTopic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.podcast, .podcast): return {
        guard case .podcast(let l) = lhs, case .podcast(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.answer, .answer): return {
        guard case .answer(let l) = lhs, case .answer(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct GeneratePodcastRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var durationSeconds: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GeneratePodcastResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GeneratePodcastResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: GeneratePodcastResponseDeltaProto.OneOf_Type? = nil

  var podcast: PodcastProto {
    get {
      if case .podcast(let v)? = type {return v}
      return PodcastProto()
    }
    set {type = .podcast(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case podcast(PodcastProto)

  #if !swift(>=4.1)
    static func ==(lhs: GeneratePodcastResponseDeltaProto.OneOf_Type, rhs: GeneratePodcastResponseDeltaProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.podcast, .podcast): return {
        guard case .podcast(let l) = lhs, case .podcast(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct ListPodcastsRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListPodcastsResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcasts: [PodcastProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListPodcastsResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ListPodcastsResponseDeltaProto.OneOf_Type? = nil

  var ping: Bool {
    get {
      if case .ping(let v)? = type {return v}
      return false
    }
    set {type = .ping(newValue)}
  }

  var updatedPodcast: PodcastProto {
    get {
      if case .updatedPodcast(let v)? = type {return v}
      return PodcastProto()
    }
    set {type = .updatedPodcast(newValue)}
  }

  var deletedPodcastID: String {
    get {
      if case .deletedPodcastID(let v)? = type {return v}
      return String()
    }
    set {type = .deletedPodcastID(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case ping(Bool)
    case updatedPodcast(PodcastProto)
    case deletedPodcastID(String)

  #if !swift(>=4.1)
    static func ==(lhs: ListPodcastsResponseDeltaProto.OneOf_Type, rhs: ListPodcastsResponseDeltaProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ping, .ping): return {
        guard case .ping(let l) = lhs, case .ping(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updatedPodcast, .updatedPodcast): return {
        guard case .updatedPodcast(let l) = lhs, case .updatedPodcast(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deletedPodcastID, .deletedPodcastID): return {
        guard case .deletedPodcastID(let l) = lhs, case .deletedPodcastID(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PodcastProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String {
    get {return _storage._podcastID}
    set {_uniqueStorage()._podcastID = newValue}
  }

  var createdBy: String {
    get {return _storage._createdBy}
    set {_uniqueStorage()._createdBy = newValue}
  }

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return _storage._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {_uniqueStorage()._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  var isReady: Bool {
    get {return _storage._isReady}
    set {_uniqueStorage()._isReady = newValue}
  }

  var displayStatus: String {
    get {return _storage._displayStatus}
    set {_uniqueStorage()._displayStatus = newValue}
  }

  var preview: PodcastPreviewProto {
    get {return _storage._preview ?? PodcastPreviewProto()}
    set {_uniqueStorage()._preview = newValue}
  }
  /// Returns true if `preview` has been explicitly set.
  var hasPreview: Bool {return _storage._preview != nil}
  /// Clears the value of `preview`. Subsequent reads from it will return its default value.
  mutating func clearPreview() {_uniqueStorage()._preview = nil}

  var thumbnail: PodcastThumbnailProto {
    get {return _storage._thumbnail ?? PodcastThumbnailProto()}
    set {_uniqueStorage()._thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  var hasThumbnail: Bool {return _storage._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  mutating func clearThumbnail() {_uniqueStorage()._thumbnail = nil}

  var audio: PodcastAudioProto {
    get {return _storage._audio ?? PodcastAudioProto()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  mutating func clearAudio() {_uniqueStorage()._audio = nil}

  var visuals: PodcastVisualsProto {
    get {return _storage._visuals ?? PodcastVisualsProto()}
    set {_uniqueStorage()._visuals = newValue}
  }
  /// Returns true if `visuals` has been explicitly set.
  var hasVisuals: Bool {return _storage._visuals != nil}
  /// Clears the value of `visuals`. Subsequent reads from it will return its default value.
  mutating func clearVisuals() {_uniqueStorage()._visuals = nil}

  var transcript: PodcastTranscriptProto {
    get {return _storage._transcript ?? PodcastTranscriptProto()}
    set {_uniqueStorage()._transcript = newValue}
  }
  /// Returns true if `transcript` has been explicitly set.
  var hasTranscript: Bool {return _storage._transcript != nil}
  /// Clears the value of `transcript`. Subsequent reads from it will return its default value.
  mutating func clearTranscript() {_uniqueStorage()._transcript = nil}

  var cards: PodcastCardsProto {
    get {return _storage._cards ?? PodcastCardsProto()}
    set {_uniqueStorage()._cards = newValue}
  }
  /// Returns true if `cards` has been explicitly set.
  var hasCards: Bool {return _storage._cards != nil}
  /// Clears the value of `cards`. Subsequent reads from it will return its default value.
  mutating func clearCards() {_uniqueStorage()._cards = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PodcastPreviewProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var titleEmoji: String = String()

  var synopsis: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastThumbnailProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var badge: PodcastBadgeProto = .undefined

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastAudioProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct PodcastCardsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cards: [PodcastCardProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastCardProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardID: String = String()

  /// IDs start at 10
  var type: PodcastCardProto.OneOf_Type? = nil

  var knowledge: PodcastKnowledgeCardProto {
    get {
      if case .knowledge(let v)? = type {return v}
      return PodcastKnowledgeCardProto()
    }
    set {type = .knowledge(newValue)}
  }

  var multipleChoice: PodcastMultipleChoiceCardProto {
    get {
      if case .multipleChoice(let v)? = type {return v}
      return PodcastMultipleChoiceCardProto()
    }
    set {type = .multipleChoice(newValue)}
  }

  var poll: PodcastPollCardProto {
    get {
      if case .poll(let v)? = type {return v}
      return PodcastPollCardProto()
    }
    set {type = .poll(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// IDs start at 10
  enum OneOf_Type: Equatable {
    case knowledge(PodcastKnowledgeCardProto)
    case multipleChoice(PodcastMultipleChoiceCardProto)
    case poll(PodcastPollCardProto)

  #if !swift(>=4.1)
    static func ==(lhs: PodcastCardProto.OneOf_Type, rhs: PodcastCardProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.knowledge, .knowledge): return {
        guard case .knowledge(let l) = lhs, case .knowledge(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.multipleChoice, .multipleChoice): return {
        guard case .multipleChoice(let l) = lhs, case .multipleChoice(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.poll, .poll): return {
        guard case .poll(let l) = lhs, case .poll(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PodcastPromptAnswerProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastVisualsProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var visuals: [PodcastVisualProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastVisualProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestampMillis: Int32 = 0

  var imagePath: String = String()

  var animation: PodcastVisualAnimationProto {
    get {return _animation ?? PodcastVisualAnimationProto()}
    set {_animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  var hasAnimation: Bool {return self._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  mutating func clearAnimation() {self._animation = nil}

  var transition: PodcastVisualTransitionProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _animation: PodcastVisualAnimationProto? = nil
}

struct PodcastVisualAnimationProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var durationMillis: Int32 = 0

  var startScale: Float = 0

  var endScale: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastTranscriptProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [PodcastTranscriptEntryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastTranscriptEntryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var host: PodcastHostProto = .unknown

  var words: [PodcastWordProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastWordProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var word: String = String()

  var startMillis: Int32 = 0

  var endMillis: Int32 = 0

  var separator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// No user input assumed
struct PodcastKnowledgeCardProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var hero: PodcastCardHeroProto {
    get {return _hero ?? PodcastCardHeroProto()}
    set {_hero = newValue}
  }
  /// Returns true if `hero` has been explicitly set.
  var hasHero: Bool {return self._hero != nil}
  /// Clears the value of `hero`. Subsequent reads from it will return its default value.
  mutating func clearHero() {self._hero = nil}

  var text: String = String()

  var explanation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hero: PodcastCardHeroProto? = nil
}

/// 2: True/False, 3: A/B/C or 4: 1/2/3/4 user input
struct PodcastMultipleChoiceCardProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var hero: PodcastCardHeroProto {
    get {return _hero ?? PodcastCardHeroProto()}
    set {_hero = newValue}
  }
  /// Returns true if `hero` has been explicitly set.
  var hasHero: Bool {return self._hero != nil}
  /// Clears the value of `hero`. Subsequent reads from it will return its default value.
  mutating func clearHero() {self._hero = nil}

  var question: String = String()

  var options: [PodcastMultipleChoiceOptionProto] = []

  var correctAnswerNumber: Int32 = 0

  /// Number of hints is the number of possible wrong answers.
  var hints: [String] = []

  var explanation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hero: PodcastCardHeroProto? = nil
}

/// 2, 3 or 4 options to vote for
struct PodcastPollCardProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var hero: PodcastCardHeroProto {
    get {return _hero ?? PodcastCardHeroProto()}
    set {_hero = newValue}
  }
  /// Returns true if `hero` has been explicitly set.
  var hasHero: Bool {return self._hero != nil}
  /// Clears the value of `hero`. Subsequent reads from it will return its default value.
  mutating func clearHero() {self._hero = nil}

  var question: String = String()

  /// commentary
  var options: [PodcastPollOptionProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hero: PodcastCardHeroProto? = nil
}

struct PodcastCardHeroProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var emoji: String = String()

  var lottieURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastMultipleChoiceOptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Could be a label like True/False or a short sentence
  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastPollOptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PodcastBadgeProto: @unchecked Sendable {}
extension PodcastVisualTransitionProto: @unchecked Sendable {}
extension PodcastHostProto: @unchecked Sendable {}
extension PodcastStreamApiRequestProto: @unchecked Sendable {}
extension PodcastStreamApiRequestProto.OneOf_Request: @unchecked Sendable {}
extension PodcastStreamApiResponseHeaderProto: @unchecked Sendable {}
extension PodcastStreamApiResponseHeaderProto.OneOf_Header: @unchecked Sendable {}
extension PodcastStreamApiResponseDeltaProto: @unchecked Sendable {}
extension PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta: @unchecked Sendable {}
extension CreatePodcastRequestProto: @unchecked Sendable {}
extension CreatePodcastResponseHeaderProto: @unchecked Sendable {}
extension CreatePodcastResponseDeltaProto: @unchecked Sendable {}
extension CreatePodcastResponseDeltaProto.OneOf_Type: @unchecked Sendable {}
extension GeneratePodcastRequestProto: @unchecked Sendable {}
extension GeneratePodcastResponseHeaderProto: @unchecked Sendable {}
extension GeneratePodcastResponseDeltaProto: @unchecked Sendable {}
extension GeneratePodcastResponseDeltaProto.OneOf_Type: @unchecked Sendable {}
extension ListPodcastsRequestProto: @unchecked Sendable {}
extension ListPodcastsResponseHeaderProto: @unchecked Sendable {}
extension ListPodcastsResponseDeltaProto: @unchecked Sendable {}
extension ListPodcastsResponseDeltaProto.OneOf_Type: @unchecked Sendable {}
extension PodcastProto: @unchecked Sendable {}
extension PodcastPreviewProto: @unchecked Sendable {}
extension PodcastThumbnailProto: @unchecked Sendable {}
extension PodcastAudioProto: @unchecked Sendable {}
extension PodcastCardsProto: @unchecked Sendable {}
extension PodcastCardProto: @unchecked Sendable {}
extension PodcastCardProto.OneOf_Type: @unchecked Sendable {}
extension PodcastPromptAnswerProto: @unchecked Sendable {}
extension PodcastVisualsProto: @unchecked Sendable {}
extension PodcastVisualProto: @unchecked Sendable {}
extension PodcastVisualAnimationProto: @unchecked Sendable {}
extension PodcastTranscriptProto: @unchecked Sendable {}
extension PodcastTranscriptEntryProto: @unchecked Sendable {}
extension PodcastWordProto: @unchecked Sendable {}
extension PodcastKnowledgeCardProto: @unchecked Sendable {}
extension PodcastMultipleChoiceCardProto: @unchecked Sendable {}
extension PodcastPollCardProto: @unchecked Sendable {}
extension PodcastCardHeroProto: @unchecked Sendable {}
extension PodcastMultipleChoiceOptionProto: @unchecked Sendable {}
extension PodcastPollOptionProto: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PodcastBadgeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_BADGE_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_BADGE_PROTO_NONE"),
    2: .same(proto: "PODCAST_BADGE_PROTO_LISTEN"),
    3: .same(proto: "PODCAST_BADGE_PROTO_POLL"),
  ]
}

extension PodcastVisualTransitionProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_DISSOLVE"),
    2: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_SWIPE"),
    3: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_BAR_SWIPE"),
    4: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_PAGE_CURL"),
  ]
}

extension PodcastHostProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_HOST_PROTO_UNKNOWN"),
    1: .same(proto: "PODCAST_HOST_PROTO_MALE"),
    2: .same(proto: "PODCAST_HOST_PROTO_FEMALE"),
  ]
}

extension PodcastStreamApiRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encoded_user_auth"),
    2: .same(proto: "create"),
    3: .same(proto: "generate"),
    4: .same(proto: "list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.encodedUserAuth) }()
      case 2: try {
        var v: CreatePodcastRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .create(v)
        }
      }()
      case 3: try {
        var v: GeneratePodcastRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .generate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .generate(v)
        }
      }()
      case 4: try {
        var v: ListPodcastsRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .list(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.encodedUserAuth.isEmpty {
      try visitor.visitSingularStringField(value: self.encodedUserAuth, fieldNumber: 1)
    }
    switch self.request {
    case .create?: try {
      guard case .create(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .generate?: try {
      guard case .generate(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .list?: try {
      guard case .list(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiRequestProto, rhs: PodcastStreamApiRequestProto) -> Bool {
    if lhs.encodedUserAuth != rhs.encodedUserAuth {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStreamApiResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refreshed_encoded_user_auth"),
    2: .standard(proto: "create_header"),
    3: .same(proto: "generate"),
    4: .same(proto: "list"),
    100: .same(proto: "latencies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refreshedEncodedUserAuth) }()
      case 2: try {
        var v: CreatePodcastResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .createHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .createHeader(v)
        }
      }()
      case 3: try {
        var v: GeneratePodcastResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .generate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .generate(v)
        }
      }()
      case 4: try {
        var v: ListPodcastsResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .list(v)
        }
      }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: &self.latencies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.refreshedEncodedUserAuth.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshedEncodedUserAuth, fieldNumber: 1)
    }
    switch self.header {
    case .createHeader?: try {
      guard case .createHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .generate?: try {
      guard case .generate(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .list?: try {
      guard case .list(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.latencies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: self.latencies, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiResponseHeaderProto, rhs: PodcastStreamApiResponseHeaderProto) -> Bool {
    if lhs.refreshedEncodedUserAuth != rhs.refreshedEncodedUserAuth {return false}
    if lhs.header != rhs.header {return false}
    if lhs.latencies != rhs.latencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStreamApiResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_delta"),
    2: .standard(proto: "generate_delta"),
    3: .standard(proto: "list_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CreatePodcastResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .createDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .createDelta(v)
        }
      }()
      case 2: try {
        var v: GeneratePodcastResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .generateDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .generateDelta(v)
        }
      }()
      case 3: try {
        var v: ListPodcastsResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .listDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .listDelta(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseDelta {
    case .createDelta?: try {
      guard case .createDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .generateDelta?: try {
      guard case .generateDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .listDelta?: try {
      guard case .listDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiResponseDeltaProto, rhs: PodcastStreamApiResponseDeltaProto) -> Bool {
    if lhs.responseDelta != rhs.responseDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prompt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastRequestProto, rhs: CreatePodcastRequestProto) -> Bool {
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastResponseHeaderProto, rhs: CreatePodcastResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "separator"),
    2: .standard(proto: "error_no_topic"),
    10: .same(proto: "podcast"),
    11: .same(proto: "answer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .separator(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .errorNoTopic(v)
        }
      }()
      case 10: try {
        var v: PodcastProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .podcast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .podcast(v)
        }
      }()
      case 11: try {
        var v: PodcastPromptAnswerProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .answer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .answer(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .separator?: try {
      guard case .separator(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .errorNoTopic?: try {
      guard case .errorNoTopic(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .podcast?: try {
      guard case .podcast(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .answer?: try {
      guard case .answer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastResponseDeltaProto, rhs: CreatePodcastResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "duration_seconds"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.durationSeconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    if self.durationSeconds != 0 {
      try visitor.visitSingularInt32Field(value: self.durationSeconds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastRequestProto, rhs: GeneratePodcastRequestProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.durationSeconds != rhs.durationSeconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastResponseHeaderProto, rhs: GeneratePodcastResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .podcast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .podcast(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .podcast(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastResponseDeltaProto, rhs: GeneratePodcastResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListPodcastsRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListPodcastsRequestProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListPodcastsRequestProto, rhs: ListPodcastsRequestProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListPodcastsResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListPodcastsResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podcasts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.podcasts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcasts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.podcasts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListPodcastsResponseHeaderProto, rhs: ListPodcastsResponseHeaderProto) -> Bool {
    if lhs.podcasts != rhs.podcasts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListPodcastsResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListPodcastsResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ping"),
    2: .standard(proto: "updated_podcast"),
    3: .standard(proto: "deleted_podcast_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .ping(v)
        }
      }()
      case 2: try {
        var v: PodcastProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .updatedPodcast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .updatedPodcast(v)
        }
      }()
      case 3: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .deletedPodcastID(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .ping?: try {
      guard case .ping(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .updatedPodcast?: try {
      guard case .updatedPodcast(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .deletedPodcastID?: try {
      guard case .deletedPodcastID(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListPodcastsResponseDeltaProto, rhs: ListPodcastsResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "created_by"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "updated_at"),
    5: .standard(proto: "is_ready"),
    6: .standard(proto: "display_status"),
    7: .same(proto: "preview"),
    8: .same(proto: "thumbnail"),
    9: .same(proto: "audio"),
    10: .same(proto: "visuals"),
    11: .same(proto: "transcript"),
    12: .same(proto: "cards"),
  ]

  fileprivate class _StorageClass {
    var _podcastID: String = String()
    var _createdBy: String = String()
    var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _isReady: Bool = false
    var _displayStatus: String = String()
    var _preview: PodcastPreviewProto? = nil
    var _thumbnail: PodcastThumbnailProto? = nil
    var _audio: PodcastAudioProto? = nil
    var _visuals: PodcastVisualsProto? = nil
    var _transcript: PodcastTranscriptProto? = nil
    var _cards: PodcastCardsProto? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _podcastID = source._podcastID
      _createdBy = source._createdBy
      _createdAt = source._createdAt
      _updatedAt = source._updatedAt
      _isReady = source._isReady
      _displayStatus = source._displayStatus
      _preview = source._preview
      _thumbnail = source._thumbnail
      _audio = source._audio
      _visuals = source._visuals
      _transcript = source._transcript
      _cards = source._cards
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._podcastID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._createdBy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._createdAt) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._isReady) }()
        case 6: try { try decoder.decodeSingularStringField(value: &_storage._displayStatus) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._preview) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnail) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._visuals) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._transcript) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._cards) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._podcastID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._podcastID, fieldNumber: 1)
      }
      if !_storage._createdBy.isEmpty {
        try visitor.visitSingularStringField(value: _storage._createdBy, fieldNumber: 2)
      }
      try { if let v = _storage._createdAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if _storage._isReady != false {
        try visitor.visitSingularBoolField(value: _storage._isReady, fieldNumber: 5)
      }
      if !_storage._displayStatus.isEmpty {
        try visitor.visitSingularStringField(value: _storage._displayStatus, fieldNumber: 6)
      }
      try { if let v = _storage._preview {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._thumbnail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._visuals {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._transcript {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._cards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastProto, rhs: PodcastProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._podcastID != rhs_storage._podcastID {return false}
        if _storage._createdBy != rhs_storage._createdBy {return false}
        if _storage._createdAt != rhs_storage._createdAt {return false}
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._isReady != rhs_storage._isReady {return false}
        if _storage._displayStatus != rhs_storage._displayStatus {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._thumbnail != rhs_storage._thumbnail {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._visuals != rhs_storage._visuals {return false}
        if _storage._transcript != rhs_storage._transcript {return false}
        if _storage._cards != rhs_storage._cards {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPreviewProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPreviewProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .standard(proto: "title_emoji"),
    3: .same(proto: "synopsis"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.titleEmoji) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.synopsis) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.titleEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.titleEmoji, fieldNumber: 2)
    }
    if !self.synopsis.isEmpty {
      try visitor.visitSingularStringField(value: self.synopsis, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPreviewProto, rhs: PodcastPreviewProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.titleEmoji != rhs.titleEmoji {return false}
    if lhs.synopsis != rhs.synopsis {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastThumbnailProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastThumbnailProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "badge"),
    3: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.badge) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.path) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if self.badge != .undefined {
      try visitor.visitSingularEnumField(value: self.badge, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastThumbnailProto, rhs: PodcastThumbnailProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.badge != rhs.badge {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastAudioProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastAudioProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastAudioProto, rhs: PodcastAudioProto) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastCardsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastCardsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "cards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.cards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.cards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cards, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastCardsProto, rhs: PodcastCardsProto) -> Bool {
    if lhs.cards != rhs.cards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_id"),
    10: .same(proto: "knowledge"),
    11: .standard(proto: "multiple_choice"),
    12: .same(proto: "poll"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardID) }()
      case 10: try {
        var v: PodcastKnowledgeCardProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .knowledge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .knowledge(v)
        }
      }()
      case 11: try {
        var v: PodcastMultipleChoiceCardProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .multipleChoice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .multipleChoice(v)
        }
      }()
      case 12: try {
        var v: PodcastPollCardProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .poll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .poll(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cardID.isEmpty {
      try visitor.visitSingularStringField(value: self.cardID, fieldNumber: 1)
    }
    switch self.type {
    case .knowledge?: try {
      guard case .knowledge(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .multipleChoice?: try {
      guard case .multipleChoice(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .poll?: try {
      guard case .poll(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastCardProto, rhs: PodcastCardProto) -> Bool {
    if lhs.cardID != rhs.cardID {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPromptAnswerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPromptAnswerProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPromptAnswerProto, rhs: PodcastPromptAnswerProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastVisualsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastVisualsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visuals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.visuals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.visuals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.visuals, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastVisualsProto, rhs: PodcastVisualsProto) -> Bool {
    if lhs.visuals != rhs.visuals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastVisualProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastVisualProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_millis"),
    2: .standard(proto: "image_path"),
    4: .same(proto: "animation"),
    3: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timestampMillis) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imagePath) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.transition) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._animation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestampMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.timestampMillis, fieldNumber: 1)
    }
    if !self.imagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePath, fieldNumber: 2)
    }
    if self.transition != .undefined {
      try visitor.visitSingularEnumField(value: self.transition, fieldNumber: 3)
    }
    try { if let v = self._animation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastVisualProto, rhs: PodcastVisualProto) -> Bool {
    if lhs.timestampMillis != rhs.timestampMillis {return false}
    if lhs.imagePath != rhs.imagePath {return false}
    if lhs._animation != rhs._animation {return false}
    if lhs.transition != rhs.transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastVisualAnimationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastVisualAnimationProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_millis"),
    2: .standard(proto: "start_scale"),
    3: .standard(proto: "end_scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.durationMillis) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startScale) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.endScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.durationMillis, fieldNumber: 1)
    }
    if self.startScale != 0 {
      try visitor.visitSingularFloatField(value: self.startScale, fieldNumber: 2)
    }
    if self.endScale != 0 {
      try visitor.visitSingularFloatField(value: self.endScale, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastVisualAnimationProto, rhs: PodcastVisualAnimationProto) -> Bool {
    if lhs.durationMillis != rhs.durationMillis {return false}
    if lhs.startScale != rhs.startScale {return false}
    if lhs.endScale != rhs.endScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastTranscriptProto, rhs: PodcastTranscriptProto) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastTranscriptEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastTranscriptEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "words"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.host) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.words) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.host != .unknown {
      try visitor.visitSingularEnumField(value: self.host, fieldNumber: 1)
    }
    if !self.words.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.words, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastTranscriptEntryProto, rhs: PodcastTranscriptEntryProto) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastWordProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastWordProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .standard(proto: "start_millis"),
    3: .standard(proto: "end_millis"),
    4: .same(proto: "separator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startMillis) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endMillis) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.separator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if self.startMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.startMillis, fieldNumber: 2)
    }
    if self.endMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.endMillis, fieldNumber: 3)
    }
    if !self.separator.isEmpty {
      try visitor.visitSingularStringField(value: self.separator, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastWordProto, rhs: PodcastWordProto) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.startMillis != rhs.startMillis {return false}
    if lhs.endMillis != rhs.endMillis {return false}
    if lhs.separator != rhs.separator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastKnowledgeCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastKnowledgeCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "hero"),
    3: .same(proto: "text"),
    4: .same(proto: "explanation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hero) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._hero {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastKnowledgeCardProto, rhs: PodcastKnowledgeCardProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._hero != rhs._hero {return false}
    if lhs.text != rhs.text {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastMultipleChoiceCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastMultipleChoiceCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "hero"),
    3: .same(proto: "question"),
    4: .same(proto: "options"),
    5: .standard(proto: "correct_answer_number"),
    6: .same(proto: "hints"),
    7: .same(proto: "explanation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hero) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.question) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.correctAnswerNumber) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.hints) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._hero {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.question.isEmpty {
      try visitor.visitSingularStringField(value: self.question, fieldNumber: 3)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 4)
    }
    if self.correctAnswerNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.correctAnswerNumber, fieldNumber: 5)
    }
    if !self.hints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hints, fieldNumber: 6)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastMultipleChoiceCardProto, rhs: PodcastMultipleChoiceCardProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._hero != rhs._hero {return false}
    if lhs.question != rhs.question {return false}
    if lhs.options != rhs.options {return false}
    if lhs.correctAnswerNumber != rhs.correctAnswerNumber {return false}
    if lhs.hints != rhs.hints {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPollCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPollCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "hero"),
    3: .same(proto: "question"),
    4: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hero) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.question) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._hero {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.question.isEmpty {
      try visitor.visitSingularStringField(value: self.question, fieldNumber: 3)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPollCardProto, rhs: PodcastPollCardProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._hero != rhs._hero {return false}
    if lhs.question != rhs.question {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastCardHeroProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastCardHeroProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "lottie_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lottieURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 1)
    }
    if !self.lottieURL.isEmpty {
      try visitor.visitSingularStringField(value: self.lottieURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastCardHeroProto, rhs: PodcastCardHeroProto) -> Bool {
    if lhs.emoji != rhs.emoji {return false}
    if lhs.lottieURL != rhs.lottieURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastMultipleChoiceOptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastMultipleChoiceOptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastMultipleChoiceOptionProto, rhs: PodcastMultipleChoiceOptionProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPollOptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPollOptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPollOptionProto, rhs: PodcastPollOptionProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
