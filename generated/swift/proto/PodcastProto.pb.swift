// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: PodcastProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PodcastStateProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case ready // = 1
  case synopsys // = 2
  case plan // = 3
  case transcript // = 4
  case audio // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ready
    case 2: self = .synopsys
    case 3: self = .plan
    case 4: self = .transcript
    case 5: self = .audio
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ready: return 1
    case .synopsys: return 2
    case .plan: return 3
    case .transcript: return 4
    case .audio: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PodcastStateProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PodcastStateProto] = [
    .unknown,
    .ready,
    .synopsys,
    .plan,
    .transcript,
    .audio,
  ]
}

#endif  // swift(>=4.2)

enum PodcastSectionTypeProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case introduction // = 1
  case section // = 2
  case conclusion // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .introduction
    case 2: self = .section
    case 3: self = .conclusion
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .introduction: return 1
    case .section: return 2
    case .conclusion: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PodcastSectionTypeProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PodcastSectionTypeProto] = [
    .unknown,
    .introduction,
    .section,
    .conclusion,
  ]
}

#endif  // swift(>=4.2)

enum PodcastHostProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case male // = 1
  case female // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .male
    case 2: self = .female
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .male: return 1
    case .female: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension PodcastHostProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [PodcastHostProto] = [
    .unknown,
    .male,
    .female,
  ]
}

#endif  // swift(>=4.2)

struct PodcastStreamApiRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var encodedUserAuth: String = String()

  var request: PodcastStreamApiRequestProto.OneOf_Request? = nil

  var createPreview: CreatePodcastPreviewRequestProto {
    get {
      if case .createPreview(let v)? = request {return v}
      return CreatePodcastPreviewRequestProto()
    }
    set {request = .createPreview(newValue)}
  }

  var generate: GeneratePodcastRequestProto {
    get {
      if case .generate(let v)? = request {return v}
      return GeneratePodcastRequestProto()
    }
    set {request = .generate(newValue)}
  }

  var list: ListPodcastsRequestProto {
    get {
      if case .list(let v)? = request {return v}
      return ListPodcastsRequestProto()
    }
    set {request = .list(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable {
    case createPreview(CreatePodcastPreviewRequestProto)
    case generate(GeneratePodcastRequestProto)
    case list(ListPodcastsRequestProto)

  #if !swift(>=4.1)
    static func ==(lhs: PodcastStreamApiRequestProto.OneOf_Request, rhs: PodcastStreamApiRequestProto.OneOf_Request) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createPreview, .createPreview): return {
        guard case .createPreview(let l) = lhs, case .createPreview(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.generate, .generate): return {
        guard case .generate(let l) = lhs, case .generate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.list, .list): return {
        guard case .list(let l) = lhs, case .list(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PodcastStreamApiResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// If present the token was refreshed and the client should use this new one
  /// from now onwards.
  var refreshedEncodedUserAuth: String = String()

  var header: PodcastStreamApiResponseHeaderProto.OneOf_Header? = nil

  var createPreviewHeader: CreatePodcastPreviewResponseHeaderProto {
    get {
      if case .createPreviewHeader(let v)? = header {return v}
      return CreatePodcastPreviewResponseHeaderProto()
    }
    set {header = .createPreviewHeader(newValue)}
  }

  var generate: GeneratePodcastResponseHeaderProto {
    get {
      if case .generate(let v)? = header {return v}
      return GeneratePodcastResponseHeaderProto()
    }
    set {header = .generate(newValue)}
  }

  var list: ListPodcastsResponseHeaderProto {
    get {
      if case .list(let v)? = header {return v}
      return ListPodcastsResponseHeaderProto()
    }
    set {header = .list(newValue)}
  }

  var latencies: Dictionary<String,SwiftProtobuf.Google_Protobuf_Duration> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Header: Equatable {
    case createPreviewHeader(CreatePodcastPreviewResponseHeaderProto)
    case generate(GeneratePodcastResponseHeaderProto)
    case list(ListPodcastsResponseHeaderProto)

  #if !swift(>=4.1)
    static func ==(lhs: PodcastStreamApiResponseHeaderProto.OneOf_Header, rhs: PodcastStreamApiResponseHeaderProto.OneOf_Header) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createPreviewHeader, .createPreviewHeader): return {
        guard case .createPreviewHeader(let l) = lhs, case .createPreviewHeader(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.generate, .generate): return {
        guard case .generate(let l) = lhs, case .generate(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.list, .list): return {
        guard case .list(let l) = lhs, case .list(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct PodcastStreamApiResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responseDelta: PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta? = nil

  var createPreviewDelta: CreatePodcastPreviewResponseDeltaProto {
    get {
      if case .createPreviewDelta(let v)? = responseDelta {return v}
      return CreatePodcastPreviewResponseDeltaProto()
    }
    set {responseDelta = .createPreviewDelta(newValue)}
  }

  var generateDelta: GeneratePodcastResponseDeltaProto {
    get {
      if case .generateDelta(let v)? = responseDelta {return v}
      return GeneratePodcastResponseDeltaProto()
    }
    set {responseDelta = .generateDelta(newValue)}
  }

  var listDelta: ListPodcastsResponseDeltaProto {
    get {
      if case .listDelta(let v)? = responseDelta {return v}
      return ListPodcastsResponseDeltaProto()
    }
    set {responseDelta = .listDelta(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResponseDelta: Equatable {
    case createPreviewDelta(CreatePodcastPreviewResponseDeltaProto)
    case generateDelta(GeneratePodcastResponseDeltaProto)
    case listDelta(ListPodcastsResponseDeltaProto)

  #if !swift(>=4.1)
    static func ==(lhs: PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta, rhs: PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.createPreviewDelta, .createPreviewDelta): return {
        guard case .createPreviewDelta(let l) = lhs, case .createPreviewDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.generateDelta, .generateDelta): return {
        guard case .generateDelta(let l) = lhs, case .generateDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.listDelta, .listDelta): return {
        guard case .listDelta(let l) = lhs, case .listDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct CreatePodcastPreviewRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prompt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreatePodcastPreviewResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreatePodcastPreviewResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: CreatePodcastPreviewResponseDeltaProto.OneOf_Type? = nil

  var separator: Bool {
    get {
      if case .separator(let v)? = type {return v}
      return false
    }
    set {type = .separator(newValue)}
  }

  /// This is the last delta message
  var errorNoTopic: Bool {
    get {
      if case .errorNoTopic(let v)? = type {return v}
      return false
    }
    set {type = .errorNoTopic(newValue)}
  }

  /// IDs start at 10
  var previewDelta: PodcastPreviewProto {
    get {
      if case .previewDelta(let v)? = type {return v}
      return PodcastPreviewProto()
    }
    set {type = .previewDelta(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case separator(Bool)
    /// This is the last delta message
    case errorNoTopic(Bool)
    /// IDs start at 10
    case previewDelta(PodcastPreviewProto)

  #if !swift(>=4.1)
    static func ==(lhs: CreatePodcastPreviewResponseDeltaProto.OneOf_Type, rhs: CreatePodcastPreviewResponseDeltaProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.separator, .separator): return {
        guard case .separator(let l) = lhs, case .separator(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.errorNoTopic, .errorNoTopic): return {
        guard case .errorNoTopic(let l) = lhs, case .errorNoTopic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.previewDelta, .previewDelta): return {
        guard case .previewDelta(let l) = lhs, case .previewDelta(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct GeneratePodcastRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GeneratePodcastResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GeneratePodcastResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: GeneratePodcastResponseDeltaProto.OneOf_Type? = nil

  var planning: Bool {
    get {
      if case .planning(let v)? = type {return v}
      return false
    }
    set {type = .planning(newValue)}
  }

  var producingTranscript: Bool {
    get {
      if case .producingTranscript(let v)? = type {return v}
      return false
    }
    set {type = .producingTranscript(newValue)}
  }

  var narrating: Bool {
    get {
      if case .narrating(let v)? = type {return v}
      return false
    }
    set {type = .narrating(newValue)}
  }

  var audioPath: String {
    get {
      if case .audioPath(let v)? = type {return v}
      return String()
    }
    set {type = .audioPath(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case planning(Bool)
    case producingTranscript(Bool)
    case narrating(Bool)
    case audioPath(String)

  #if !swift(>=4.1)
    static func ==(lhs: GeneratePodcastResponseDeltaProto.OneOf_Type, rhs: GeneratePodcastResponseDeltaProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.planning, .planning): return {
        guard case .planning(let l) = lhs, case .planning(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.producingTranscript, .producingTranscript): return {
        guard case .producingTranscript(let l) = lhs, case .producingTranscript(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.narrating, .narrating): return {
        guard case .narrating(let l) = lhs, case .narrating(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.audioPath, .audioPath): return {
        guard case .audioPath(let l) = lhs, case .audioPath(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct ListPodcastsRequestProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListPodcastsResponseHeaderProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcasts: [PodcastPreviewProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ListPodcastsResponseDeltaProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ListPodcastsResponseDeltaProto.OneOf_Type? = nil

  var updatedPodcast: PodcastPreviewProto {
    get {
      if case .updatedPodcast(let v)? = type {return v}
      return PodcastPreviewProto()
    }
    set {type = .updatedPodcast(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable {
    case updatedPodcast(PodcastPreviewProto)

  #if !swift(>=4.1)
    static func ==(lhs: ListPodcastsResponseDeltaProto.OneOf_Type, rhs: ListPodcastsResponseDeltaProto.OneOf_Type) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.updatedPodcast, .updatedPodcast): return {
        guard case .updatedPodcast(let l) = lhs, case .updatedPodcast(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      }
    }
  #endif
  }

  init() {}
}

struct PodcastPreviewProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var createdBy: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var state: PodcastStateProto = .unknown

  var title: String = String()

  var titleEmoji: String = String()

  var synopsis: String = String()

  var audioPath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct PodcastProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var createdBy: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var userPrompt: String = String()

  var state: PodcastStateProto = .unknown

  var reasoning: String = String()

  var title: String = String()

  var titleEmoji: String = String()

  var synopsis: String = String()

  var plan: String = String()

  var transcript: PodcastTranscriptProto {
    get {return _transcript ?? PodcastTranscriptProto()}
    set {_transcript = newValue}
  }
  /// Returns true if `transcript` has been explicitly set.
  var hasTranscript: Bool {return self._transcript != nil}
  /// Clears the value of `transcript`. Subsequent reads from it will return its default value.
  mutating func clearTranscript() {self._transcript = nil}

  var audioKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _transcript: PodcastTranscriptProto? = nil
}

struct PodcastTranscriptProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sections: [PodcastSectionTranscriptProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastSectionTranscriptProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sectionType: PodcastSectionTypeProto = .unknown

  var entries: [PodcastTranscriptEntryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastTranscriptEntryProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var host: PodcastHostProto = .unknown

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension PodcastStateProto: @unchecked Sendable {}
extension PodcastSectionTypeProto: @unchecked Sendable {}
extension PodcastHostProto: @unchecked Sendable {}
extension PodcastStreamApiRequestProto: @unchecked Sendable {}
extension PodcastStreamApiRequestProto.OneOf_Request: @unchecked Sendable {}
extension PodcastStreamApiResponseHeaderProto: @unchecked Sendable {}
extension PodcastStreamApiResponseHeaderProto.OneOf_Header: @unchecked Sendable {}
extension PodcastStreamApiResponseDeltaProto: @unchecked Sendable {}
extension PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta: @unchecked Sendable {}
extension CreatePodcastPreviewRequestProto: @unchecked Sendable {}
extension CreatePodcastPreviewResponseHeaderProto: @unchecked Sendable {}
extension CreatePodcastPreviewResponseDeltaProto: @unchecked Sendable {}
extension CreatePodcastPreviewResponseDeltaProto.OneOf_Type: @unchecked Sendable {}
extension GeneratePodcastRequestProto: @unchecked Sendable {}
extension GeneratePodcastResponseHeaderProto: @unchecked Sendable {}
extension GeneratePodcastResponseDeltaProto: @unchecked Sendable {}
extension GeneratePodcastResponseDeltaProto.OneOf_Type: @unchecked Sendable {}
extension ListPodcastsRequestProto: @unchecked Sendable {}
extension ListPodcastsResponseHeaderProto: @unchecked Sendable {}
extension ListPodcastsResponseDeltaProto: @unchecked Sendable {}
extension ListPodcastsResponseDeltaProto.OneOf_Type: @unchecked Sendable {}
extension PodcastPreviewProto: @unchecked Sendable {}
extension PodcastProto: @unchecked Sendable {}
extension PodcastTranscriptProto: @unchecked Sendable {}
extension PodcastSectionTranscriptProto: @unchecked Sendable {}
extension PodcastTranscriptEntryProto: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PodcastStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_STATE_PROTO_UNKNOWN"),
    1: .same(proto: "PODCAST_STATE_PROTO_READY"),
    2: .same(proto: "PODCAST_STATE_PROTO_SYNOPSYS"),
    3: .same(proto: "PODCAST_STATE_PROTO_PLAN"),
    4: .same(proto: "PODCAST_STATE_PROTO_TRANSCRIPT"),
    5: .same(proto: "PODCAST_STATE_PROTO_AUDIO"),
  ]
}

extension PodcastSectionTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_SECTION_TYPE_PROTO_UNKNOWN"),
    1: .same(proto: "PODCAST_SECTION_TYPE_PROTO_INTRODUCTION"),
    2: .same(proto: "PODCAST_SECTION_TYPE_PROTO_SECTION"),
    3: .same(proto: "PODCAST_SECTION_TYPE_PROTO_CONCLUSION"),
  ]
}

extension PodcastHostProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_HOST_PROTO_UNKNOWN"),
    1: .same(proto: "PODCAST_HOST_PROTO_MALE"),
    2: .same(proto: "PODCAST_HOST_PROTO_FEMALE"),
  ]
}

extension PodcastStreamApiRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "encoded_user_auth"),
    2: .standard(proto: "create_preview"),
    3: .same(proto: "generate"),
    4: .same(proto: "list"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.encodedUserAuth) }()
      case 2: try {
        var v: CreatePodcastPreviewRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .createPreview(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .createPreview(v)
        }
      }()
      case 3: try {
        var v: GeneratePodcastRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .generate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .generate(v)
        }
      }()
      case 4: try {
        var v: ListPodcastsRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .list(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.encodedUserAuth.isEmpty {
      try visitor.visitSingularStringField(value: self.encodedUserAuth, fieldNumber: 1)
    }
    switch self.request {
    case .createPreview?: try {
      guard case .createPreview(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .generate?: try {
      guard case .generate(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .list?: try {
      guard case .list(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiRequestProto, rhs: PodcastStreamApiRequestProto) -> Bool {
    if lhs.encodedUserAuth != rhs.encodedUserAuth {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStreamApiResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "refreshed_encoded_user_auth"),
    2: .standard(proto: "create_preview_header"),
    3: .same(proto: "generate"),
    4: .same(proto: "list"),
    100: .same(proto: "latencies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.refreshedEncodedUserAuth) }()
      case 2: try {
        var v: CreatePodcastPreviewResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .createPreviewHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .createPreviewHeader(v)
        }
      }()
      case 3: try {
        var v: GeneratePodcastResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .generate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .generate(v)
        }
      }()
      case 4: try {
        var v: ListPodcastsResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .list(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .list(v)
        }
      }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: &self.latencies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.refreshedEncodedUserAuth.isEmpty {
      try visitor.visitSingularStringField(value: self.refreshedEncodedUserAuth, fieldNumber: 1)
    }
    switch self.header {
    case .createPreviewHeader?: try {
      guard case .createPreviewHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .generate?: try {
      guard case .generate(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .list?: try {
      guard case .list(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    if !self.latencies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: self.latencies, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiResponseHeaderProto, rhs: PodcastStreamApiResponseHeaderProto) -> Bool {
    if lhs.refreshedEncodedUserAuth != rhs.refreshedEncodedUserAuth {return false}
    if lhs.header != rhs.header {return false}
    if lhs.latencies != rhs.latencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStreamApiResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "create_preview_delta"),
    2: .standard(proto: "generate_delta"),
    3: .standard(proto: "list_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CreatePodcastPreviewResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .createPreviewDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .createPreviewDelta(v)
        }
      }()
      case 2: try {
        var v: GeneratePodcastResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .generateDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .generateDelta(v)
        }
      }()
      case 3: try {
        var v: ListPodcastsResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .listDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .listDelta(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseDelta {
    case .createPreviewDelta?: try {
      guard case .createPreviewDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .generateDelta?: try {
      guard case .generateDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .listDelta?: try {
      guard case .listDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiResponseDeltaProto, rhs: PodcastStreamApiResponseDeltaProto) -> Bool {
    if lhs.responseDelta != rhs.responseDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastPreviewRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastPreviewRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prompt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastPreviewRequestProto, rhs: CreatePodcastPreviewRequestProto) -> Bool {
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastPreviewResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastPreviewResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastPreviewResponseHeaderProto, rhs: CreatePodcastPreviewResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastPreviewResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastPreviewResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "separator"),
    2: .standard(proto: "error_no_topic"),
    10: .standard(proto: "preview_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .separator(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .errorNoTopic(v)
        }
      }()
      case 10: try {
        var v: PodcastPreviewProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .previewDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .previewDelta(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .separator?: try {
      guard case .separator(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .errorNoTopic?: try {
      guard case .errorNoTopic(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .previewDelta?: try {
      guard case .previewDelta(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastPreviewResponseDeltaProto, rhs: CreatePodcastPreviewResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastRequestProto, rhs: GeneratePodcastRequestProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastResponseHeaderProto, rhs: GeneratePodcastResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "planning"),
    2: .standard(proto: "producing_transcript"),
    3: .same(proto: "narrating"),
    4: .standard(proto: "audio_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .planning(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .producingTranscript(v)
        }
      }()
      case 3: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .narrating(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.type != nil {try decoder.handleConflictingOneOf()}
          self.type = .audioPath(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .planning?: try {
      guard case .planning(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .producingTranscript?: try {
      guard case .producingTranscript(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .narrating?: try {
      guard case .narrating(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    }()
    case .audioPath?: try {
      guard case .audioPath(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastResponseDeltaProto, rhs: GeneratePodcastResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListPodcastsRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListPodcastsRequestProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListPodcastsRequestProto, rhs: ListPodcastsRequestProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListPodcastsResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListPodcastsResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podcasts"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.podcasts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcasts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.podcasts, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListPodcastsResponseHeaderProto, rhs: ListPodcastsResponseHeaderProto) -> Bool {
    if lhs.podcasts != rhs.podcasts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ListPodcastsResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ListPodcastsResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "updated_podcast"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastPreviewProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .updatedPodcast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .updatedPodcast(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .updatedPodcast(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ListPodcastsResponseDeltaProto, rhs: ListPodcastsResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPreviewProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPreviewProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "created_by"),
    3: .standard(proto: "created_at"),
    4: .same(proto: "state"),
    5: .same(proto: "title"),
    6: .standard(proto: "title_emoji"),
    7: .same(proto: "synopsis"),
    8: .standard(proto: "audio_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.createdBy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.titleEmoji) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.synopsis) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.audioPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    if !self.createdBy.isEmpty {
      try visitor.visitSingularStringField(value: self.createdBy, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    if !self.titleEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.titleEmoji, fieldNumber: 6)
    }
    if !self.synopsis.isEmpty {
      try visitor.visitSingularStringField(value: self.synopsis, fieldNumber: 7)
    }
    if !self.audioPath.isEmpty {
      try visitor.visitSingularStringField(value: self.audioPath, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPreviewProto, rhs: PodcastPreviewProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.createdBy != rhs.createdBy {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.state != rhs.state {return false}
    if lhs.title != rhs.title {return false}
    if lhs.titleEmoji != rhs.titleEmoji {return false}
    if lhs.synopsis != rhs.synopsis {return false}
    if lhs.audioPath != rhs.audioPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "created_by"),
    3: .standard(proto: "created_at"),
    4: .standard(proto: "updated_at"),
    5: .standard(proto: "user_prompt"),
    6: .same(proto: "state"),
    7: .same(proto: "reasoning"),
    8: .same(proto: "title"),
    9: .standard(proto: "title_emoji"),
    10: .same(proto: "synopsis"),
    11: .same(proto: "plan"),
    12: .same(proto: "transcript"),
    13: .standard(proto: "audio_key"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.createdBy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.userPrompt) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.reasoning) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.titleEmoji) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.synopsis) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self.plan) }()
      case 12: try { try decoder.decodeSingularMessageField(value: &self._transcript) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self.audioKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    if !self.createdBy.isEmpty {
      try visitor.visitSingularStringField(value: self.createdBy, fieldNumber: 2)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.userPrompt.isEmpty {
      try visitor.visitSingularStringField(value: self.userPrompt, fieldNumber: 5)
    }
    if self.state != .unknown {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 6)
    }
    if !self.reasoning.isEmpty {
      try visitor.visitSingularStringField(value: self.reasoning, fieldNumber: 7)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 8)
    }
    if !self.titleEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.titleEmoji, fieldNumber: 9)
    }
    if !self.synopsis.isEmpty {
      try visitor.visitSingularStringField(value: self.synopsis, fieldNumber: 10)
    }
    if !self.plan.isEmpty {
      try visitor.visitSingularStringField(value: self.plan, fieldNumber: 11)
    }
    try { if let v = self._transcript {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    } }()
    if !self.audioKey.isEmpty {
      try visitor.visitSingularStringField(value: self.audioKey, fieldNumber: 13)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastProto, rhs: PodcastProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.createdBy != rhs.createdBy {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.userPrompt != rhs.userPrompt {return false}
    if lhs.state != rhs.state {return false}
    if lhs.reasoning != rhs.reasoning {return false}
    if lhs.title != rhs.title {return false}
    if lhs.titleEmoji != rhs.titleEmoji {return false}
    if lhs.synopsis != rhs.synopsis {return false}
    if lhs.plan != rhs.plan {return false}
    if lhs._transcript != rhs._transcript {return false}
    if lhs.audioKey != rhs.audioKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sections"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastTranscriptProto, rhs: PodcastTranscriptProto) -> Bool {
    if lhs.sections != rhs.sections {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastSectionTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastSectionTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "section_type"),
    2: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.sectionType) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.sectionType != .unknown {
      try visitor.visitSingularEnumField(value: self.sectionType, fieldNumber: 1)
    }
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastSectionTranscriptProto, rhs: PodcastSectionTranscriptProto) -> Bool {
    if lhs.sectionType != rhs.sectionType {return false}
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastTranscriptEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastTranscriptEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.host) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.host != .unknown {
      try visitor.visitSingularEnumField(value: self.host, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastTranscriptEntryProto, rhs: PodcastTranscriptEntryProto) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
