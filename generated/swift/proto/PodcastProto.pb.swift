// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: PodcastProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum PodcastSubscriptionSourceProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case platformSubscription // = 1
  case externalSubscription // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .platformSubscription
    case 2: self = .externalSubscription
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .platformSubscription: return 1
    case .externalSubscription: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PodcastSubscriptionSourceProto] = [
    .undefined,
    .platformSubscription,
    .externalSubscription,
  ]

}

enum PodcastStatusProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case generating // = 1
  case ready // = 2
  case failed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .generating
    case 2: self = .ready
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .generating: return 1
    case .ready: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PodcastStatusProto] = [
    .undefined,
    .generating,
    .ready,
    .failed,
  ]

}

enum PodcastTypeProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case explainer // = 1
  case exercise // = 2
  case meditation // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .explainer
    case 2: self = .exercise
    case 3: self = .meditation
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .explainer: return 1
    case .exercise: return 2
    case .meditation: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PodcastTypeProto] = [
    .undefined,
    .explainer,
    .exercise,
    .meditation,
  ]

}

enum PodcastVisualTransitionProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case dissolve // = 1
  case swipe // = 2
  case barSwipe // = 3
  case pageCurl // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .dissolve
    case 2: self = .swipe
    case 3: self = .barSwipe
    case 4: self = .pageCurl
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .dissolve: return 1
    case .swipe: return 2
    case .barSwipe: return 3
    case .pageCurl: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PodcastVisualTransitionProto] = [
    .undefined,
    .dissolve,
    .swipe,
    .barSwipe,
    .pageCurl,
  ]

}

enum PodcastHostProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case unknown // = 0
  case male // = 1
  case female // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .male
    case 2: self = .female
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .male: return 1
    case .female: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PodcastHostProto] = [
    .unknown,
    .male,
    .female,
  ]

}

enum PodcastSuggestionsStateProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case generating // = 1
  case ready // = 2
  case failed // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .generating
    case 2: self = .ready
    case 3: self = .failed
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .generating: return 1
    case .ready: return 2
    case .failed: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PodcastSuggestionsStateProto] = [
    .undefined,
    .generating,
    .ready,
    .failed,
  ]

}

enum PodcastUserInterfaceStyleProto: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case undefined // = 0
  case light // = 1
  case dark // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .undefined
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .undefined
    case 1: self = .light
    case 2: self = .dark
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .undefined: return 0
    case .light: return 1
    case .dark: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [PodcastUserInterfaceStyleProto] = [
    .undefined,
    .light,
    .dark,
  ]

}

struct PodcastRequestAuthProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var firebaseIDToken: String = String()

  var appcheckToken: String = String()

  var isAnonomous: Bool = false

  var appstoreCurrentEntitlements: [PodcastAppStoreTransactionProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastSubscriptionStatusProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isSubscriber: Bool = false

  var source: PodcastSubscriptionSourceProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastStreamApiRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var requestAuth: PodcastRequestAuthProto {
    get {return _requestAuth ?? PodcastRequestAuthProto()}
    set {_requestAuth = newValue}
  }
  /// Returns true if `requestAuth` has been explicitly set.
  var hasRequestAuth: Bool {return self._requestAuth != nil}
  /// Clears the value of `requestAuth`. Subsequent reads from it will return its default value.
  mutating func clearRequestAuth() {self._requestAuth = nil}

  var request: PodcastStreamApiRequestProto.OneOf_Request? = nil

  var create: CreatePodcastRequestProto {
    get {
      if case .create(let v)? = request {return v}
      return CreatePodcastRequestProto()
    }
    set {request = .create(newValue)}
  }

  var generate: GeneratePodcastRequestProto {
    get {
      if case .generate(let v)? = request {return v}
      return GeneratePodcastRequestProto()
    }
    set {request = .generate(newValue)}
  }

  var podcast: GetPodcastRequestProto {
    get {
      if case .podcast(let v)? = request {return v}
      return GetPodcastRequestProto()
    }
    set {request = .podcast(newValue)}
  }

  var story: GetPodcastStoryRequestProto {
    get {
      if case .story(let v)? = request {return v}
      return GetPodcastStoryRequestProto()
    }
    set {request = .story(newValue)}
  }

  var suggestionPoints: GetPodcastSuggestionPointsRequestProto {
    get {
      if case .suggestionPoints(let v)? = request {return v}
      return GetPodcastSuggestionPointsRequestProto()
    }
    set {request = .suggestionPoints(newValue)}
  }

  var followupPoints: GetPodcastFollowupPointsRequestProto {
    get {
      if case .followupPoints(let v)? = request {return v}
      return GetPodcastFollowupPointsRequestProto()
    }
    set {request = .followupPoints(newValue)}
  }

  var home: GetPodcastHomeRequestProto {
    get {
      if case .home(let v)? = request {return v}
      return GetPodcastHomeRequestProto()
    }
    set {request = .home(newValue)}
  }

  var deleteAccount: DeleteAccountRequestProto {
    get {
      if case .deleteAccount(let v)? = request {return v}
      return DeleteAccountRequestProto()
    }
    set {request = .deleteAccount(newValue)}
  }

  var onboardingInput: GetPodcastOnboardingInputRequestProto {
    get {
      if case .onboardingInput(let v)? = request {return v}
      return GetPodcastOnboardingInputRequestProto()
    }
    set {request = .onboardingInput(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Request: Equatable, Sendable {
    case create(CreatePodcastRequestProto)
    case generate(GeneratePodcastRequestProto)
    case podcast(GetPodcastRequestProto)
    case story(GetPodcastStoryRequestProto)
    case suggestionPoints(GetPodcastSuggestionPointsRequestProto)
    case followupPoints(GetPodcastFollowupPointsRequestProto)
    case home(GetPodcastHomeRequestProto)
    case deleteAccount(DeleteAccountRequestProto)
    case onboardingInput(GetPodcastOnboardingInputRequestProto)

  }

  init() {}

  fileprivate var _requestAuth: PodcastRequestAuthProto? = nil
}

struct PodcastStreamApiResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var header: PodcastStreamApiResponseHeaderProto.OneOf_Header? = nil

  var createHeader: CreatePodcastResponseHeaderProto {
    get {
      if case .createHeader(let v)? = header {return v}
      return CreatePodcastResponseHeaderProto()
    }
    set {header = .createHeader(newValue)}
  }

  var generateHeader: GeneratePodcastResponseHeaderProto {
    get {
      if case .generateHeader(let v)? = header {return v}
      return GeneratePodcastResponseHeaderProto()
    }
    set {header = .generateHeader(newValue)}
  }

  var podcastHeader: GetPodcastResponseHeaderProto {
    get {
      if case .podcastHeader(let v)? = header {return v}
      return GetPodcastResponseHeaderProto()
    }
    set {header = .podcastHeader(newValue)}
  }

  var storyHeader: GetPodcastStoryResponseHeaderProto {
    get {
      if case .storyHeader(let v)? = header {return v}
      return GetPodcastStoryResponseHeaderProto()
    }
    set {header = .storyHeader(newValue)}
  }

  var suggestionPointsHeader: GetPodcastSuggestionPointsResponseHeaderProto {
    get {
      if case .suggestionPointsHeader(let v)? = header {return v}
      return GetPodcastSuggestionPointsResponseHeaderProto()
    }
    set {header = .suggestionPointsHeader(newValue)}
  }

  var followupPointsHeader: GetPodcastFollowupPointsResponseHeaderProto {
    get {
      if case .followupPointsHeader(let v)? = header {return v}
      return GetPodcastFollowupPointsResponseHeaderProto()
    }
    set {header = .followupPointsHeader(newValue)}
  }

  var homeHeader: GetPodcastHomeResponseHeaderProto {
    get {
      if case .homeHeader(let v)? = header {return v}
      return GetPodcastHomeResponseHeaderProto()
    }
    set {header = .homeHeader(newValue)}
  }

  var deleteAccountHeader: DeleteAccountResponseHeaderProto {
    get {
      if case .deleteAccountHeader(let v)? = header {return v}
      return DeleteAccountResponseHeaderProto()
    }
    set {header = .deleteAccountHeader(newValue)}
  }

  var onboardingInput: GetPodcastOnboardingInputResponseHeaderProto {
    get {
      if case .onboardingInput(let v)? = header {return v}
      return GetPodcastOnboardingInputResponseHeaderProto()
    }
    set {header = .onboardingInput(newValue)}
  }

  var latencies: Dictionary<String,SwiftProtobuf.Google_Protobuf_Duration> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Header: Equatable, Sendable {
    case createHeader(CreatePodcastResponseHeaderProto)
    case generateHeader(GeneratePodcastResponseHeaderProto)
    case podcastHeader(GetPodcastResponseHeaderProto)
    case storyHeader(GetPodcastStoryResponseHeaderProto)
    case suggestionPointsHeader(GetPodcastSuggestionPointsResponseHeaderProto)
    case followupPointsHeader(GetPodcastFollowupPointsResponseHeaderProto)
    case homeHeader(GetPodcastHomeResponseHeaderProto)
    case deleteAccountHeader(DeleteAccountResponseHeaderProto)
    case onboardingInput(GetPodcastOnboardingInputResponseHeaderProto)

  }

  init() {}
}

struct PodcastStreamApiResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responseDelta: PodcastStreamApiResponseDeltaProto.OneOf_ResponseDelta? = nil

  var createDelta: CreatePodcastResponseDeltaProto {
    get {
      if case .createDelta(let v)? = responseDelta {return v}
      return CreatePodcastResponseDeltaProto()
    }
    set {responseDelta = .createDelta(newValue)}
  }

  var generateDelta: GeneratePodcastResponseDeltaProto {
    get {
      if case .generateDelta(let v)? = responseDelta {return v}
      return GeneratePodcastResponseDeltaProto()
    }
    set {responseDelta = .generateDelta(newValue)}
  }

  var podcastDelta: GetPodcastResponseDeltaProto {
    get {
      if case .podcastDelta(let v)? = responseDelta {return v}
      return GetPodcastResponseDeltaProto()
    }
    set {responseDelta = .podcastDelta(newValue)}
  }

  var storyDelta: GetPodcastStoryResponseDeltaProto {
    get {
      if case .storyDelta(let v)? = responseDelta {return v}
      return GetPodcastStoryResponseDeltaProto()
    }
    set {responseDelta = .storyDelta(newValue)}
  }

  var suggestionPointsDelta: GetPodcastSuggestionPointsResponseDeltaProto {
    get {
      if case .suggestionPointsDelta(let v)? = responseDelta {return v}
      return GetPodcastSuggestionPointsResponseDeltaProto()
    }
    set {responseDelta = .suggestionPointsDelta(newValue)}
  }

  var followupPointsDelta: GetPodcastFollowupPointsResponseDeltaProto {
    get {
      if case .followupPointsDelta(let v)? = responseDelta {return v}
      return GetPodcastFollowupPointsResponseDeltaProto()
    }
    set {responseDelta = .followupPointsDelta(newValue)}
  }

  var homeDelta: GetPodcastHomeResponseDeltaProto {
    get {
      if case .homeDelta(let v)? = responseDelta {return v}
      return GetPodcastHomeResponseDeltaProto()
    }
    set {responseDelta = .homeDelta(newValue)}
  }

  var deleteAccountDelta: DeleteAccountResponseDeltaProto {
    get {
      if case .deleteAccountDelta(let v)? = responseDelta {return v}
      return DeleteAccountResponseDeltaProto()
    }
    set {responseDelta = .deleteAccountDelta(newValue)}
  }

  var onboardingInputDelta: GetPodcastOnboardingInputResponseDeltaProto {
    get {
      if case .onboardingInputDelta(let v)? = responseDelta {return v}
      return GetPodcastOnboardingInputResponseDeltaProto()
    }
    set {responseDelta = .onboardingInputDelta(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_ResponseDelta: Equatable, Sendable {
    case createDelta(CreatePodcastResponseDeltaProto)
    case generateDelta(GeneratePodcastResponseDeltaProto)
    case podcastDelta(GetPodcastResponseDeltaProto)
    case storyDelta(GetPodcastStoryResponseDeltaProto)
    case suggestionPointsDelta(GetPodcastSuggestionPointsResponseDeltaProto)
    case followupPointsDelta(GetPodcastFollowupPointsResponseDeltaProto)
    case homeDelta(GetPodcastHomeResponseDeltaProto)
    case deleteAccountDelta(DeleteAccountResponseDeltaProto)
    case onboardingInputDelta(GetPodcastOnboardingInputResponseDeltaProto)

  }

  init() {}
}

struct CreatePodcastRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var prompt: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreatePodcastResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreatePodcastResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: CreatePodcastResponseDeltaProto.OneOf_Type? = nil

  /// This is the last delta message
  var error: PodcastErrorProto {
    get {
      if case .error(let v)? = type {return v}
      return PodcastErrorProto()
    }
    set {type = .error(newValue)}
  }

  var answer: PodcastPromptAnswerProto {
    get {
      if case .answer(let v)? = type {return v}
      return PodcastPromptAnswerProto()
    }
    set {type = .answer(newValue)}
  }

  var point: PodcastPointProto {
    get {
      if case .point(let v)? = type {return v}
      return PodcastPointProto()
    }
    set {type = .point(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    /// This is the last delta message
    case error(PodcastErrorProto)
    case answer(PodcastPromptAnswerProto)
    case point(PodcastPointProto)

  }

  init() {}
}

struct GeneratePodcastRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: GeneratePodcastRequestProto.OneOf_Type? = nil

  var points: GeneratePodcastFromPointsProto {
    get {
      if case .points(let v)? = type {return v}
      return GeneratePodcastFromPointsProto()
    }
    set {type = .points(newValue)}
  }

  var suggestion: GeneratePodcastFromSuggestionProto {
    get {
      if case .suggestion(let v)? = type {return v}
      return GeneratePodcastFromSuggestionProto()
    }
    set {type = .suggestion(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case points(GeneratePodcastFromPointsProto)
    case suggestion(GeneratePodcastFromSuggestionProto)

  }

  init() {}
}

struct GeneratePodcastFromPointsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var pointIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GeneratePodcastFromSuggestionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var pointIds: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GeneratePodcastResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GeneratePodcastResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: GeneratePodcastResponseDeltaProto.OneOf_Type? = nil

  var card: PodcastCardProto {
    get {
      if case .card(let v)? = type {return v}
      return PodcastCardProto()
    }
    set {type = .card(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case card(PodcastCardProto)

  }

  init() {}
}

struct GetPodcastRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcast: PodcastProto {
    get {return _podcast ?? PodcastProto()}
    set {_podcast = newValue}
  }
  /// Returns true if `podcast` has been explicitly set.
  var hasPodcast: Bool {return self._podcast != nil}
  /// Clears the value of `podcast`. Subsequent reads from it will return its default value.
  mutating func clearPodcast() {self._podcast = nil}

  var cards: PodcastCardsProto {
    get {return _cards ?? PodcastCardsProto()}
    set {_cards = newValue}
  }
  /// Returns true if `cards` has been explicitly set.
  var hasCards: Bool {return self._cards != nil}
  /// Clears the value of `cards`. Subsequent reads from it will return its default value.
  mutating func clearCards() {self._cards = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _podcast: PodcastProto? = nil
  fileprivate var _cards: PodcastCardsProto? = nil
}

struct GetPodcastResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastStoryRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storyID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastStoryResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastStoryResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: GetPodcastStoryResponseDeltaProto.OneOf_Type? = nil

  var header: PodcastStoryHeaderProto {
    get {
      if case .header(let v)? = type {return v}
      return PodcastStoryHeaderProto()
    }
    set {type = .header(newValue)}
  }

  var slide: PodcastStorySlideProto {
    get {
      if case .slide(let v)? = type {return v}
      return PodcastStorySlideProto()
    }
    set {type = .slide(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case header(PodcastStoryHeaderProto)
    case slide(PodcastStorySlideProto)

  }

  init() {}
}

struct GetPodcastSuggestionPointsRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastSuggestionPointsResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastSuggestionPointsResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: GetPodcastSuggestionPointsResponseDeltaProto.OneOf_Type? = nil

  var point: PodcastPointProto {
    get {
      if case .point(let v)? = type {return v}
      return PodcastPointProto()
    }
    set {type = .point(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case point(PodcastPointProto)

  }

  init() {}
}

struct GetPodcastFollowupPointsRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sourcePodcastID: String = String()

  var followupPodcastID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastFollowupPointsResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastFollowupPointsResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: GetPodcastFollowupPointsResponseDeltaProto.OneOf_Type? = nil

  var point: PodcastPointProto {
    get {
      if case .point(let v)? = type {return v}
      return PodcastPointProto()
    }
    set {type = .point(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case point(PodcastPointProto)

  }

  init() {}
}

struct GetPodcastHomeRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var onboardingInput: PodcastOnboardingInputProto {
    get {return _onboardingInput ?? PodcastOnboardingInputProto()}
    set {_onboardingInput = newValue}
  }
  /// Returns true if `onboardingInput` has been explicitly set.
  var hasOnboardingInput: Bool {return self._onboardingInput != nil}
  /// Clears the value of `onboardingInput`. Subsequent reads from it will return its default value.
  mutating func clearOnboardingInput() {self._onboardingInput = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _onboardingInput: PodcastOnboardingInputProto? = nil
}

struct GetPodcastHomeResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subscriptionStatus: PodcastSubscriptionStatusProto {
    get {return _subscriptionStatus ?? PodcastSubscriptionStatusProto()}
    set {_subscriptionStatus = newValue}
  }
  /// Returns true if `subscriptionStatus` has been explicitly set.
  var hasSubscriptionStatus: Bool {return self._subscriptionStatus != nil}
  /// Clears the value of `subscriptionStatus`. Subsequent reads from it will return its default value.
  mutating func clearSubscriptionStatus() {self._subscriptionStatus = nil}

  var firestoreSuggestionsPath: String = String()

  var onboardingRequired: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subscriptionStatus: PodcastSubscriptionStatusProto? = nil
}

struct GetPodcastHomeResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeleteAccountRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeleteAccountResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DeleteAccountResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastOnboardingInputRequestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GetPodcastOnboardingInputResponseHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var onboardingInput: PodcastOnboardingInputProto {
    get {return _onboardingInput ?? PodcastOnboardingInputProto()}
    set {_onboardingInput = newValue}
  }
  /// Returns true if `onboardingInput` has been explicitly set.
  var hasOnboardingInput: Bool {return self._onboardingInput != nil}
  /// Clears the value of `onboardingInput`. Subsequent reads from it will return its default value.
  mutating func clearOnboardingInput() {self._onboardingInput = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _onboardingInput: PodcastOnboardingInputProto? = nil
}

struct GetPodcastOnboardingInputResponseDeltaProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _storage._updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_uniqueStorage()._updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return _storage._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {_uniqueStorage()._updatedAt = nil}

  var thumbnail: PodcastThumbnailProto {
    get {return _storage._thumbnail ?? PodcastThumbnailProto()}
    set {_uniqueStorage()._thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  var hasThumbnail: Bool {return _storage._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  mutating func clearThumbnail() {_uniqueStorage()._thumbnail = nil}

  var audio: PodcastAudioProto {
    get {return _storage._audio ?? PodcastAudioProto()}
    set {_uniqueStorage()._audio = newValue}
  }
  /// Returns true if `audio` has been explicitly set.
  var hasAudio: Bool {return _storage._audio != nil}
  /// Clears the value of `audio`. Subsequent reads from it will return its default value.
  mutating func clearAudio() {_uniqueStorage()._audio = nil}

  var visuals: PodcastVisualsProto {
    get {return _storage._visuals ?? PodcastVisualsProto()}
    set {_uniqueStorage()._visuals = newValue}
  }
  /// Returns true if `visuals` has been explicitly set.
  var hasVisuals: Bool {return _storage._visuals != nil}
  /// Clears the value of `visuals`. Subsequent reads from it will return its default value.
  mutating func clearVisuals() {_uniqueStorage()._visuals = nil}

  var transcript: PodcastTranscriptProto {
    get {return _storage._transcript ?? PodcastTranscriptProto()}
    set {_uniqueStorage()._transcript = newValue}
  }
  /// Returns true if `transcript` has been explicitly set.
  var hasTranscript: Bool {return _storage._transcript != nil}
  /// Clears the value of `transcript`. Subsequent reads from it will return its default value.
  mutating func clearTranscript() {_uniqueStorage()._transcript = nil}

  var cards: PodcastCardsProto {
    get {return _storage._cards ?? PodcastCardsProto()}
    set {_uniqueStorage()._cards = newValue}
  }
  /// Returns true if `cards` has been explicitly set.
  var hasCards: Bool {return _storage._cards != nil}
  /// Clears the value of `cards`. Subsequent reads from it will return its default value.
  mutating func clearCards() {_uniqueStorage()._cards = nil}

  var keyPoints: PodcastKeyPointsProto {
    get {return _storage._keyPoints ?? PodcastKeyPointsProto()}
    set {_uniqueStorage()._keyPoints = newValue}
  }
  /// Returns true if `keyPoints` has been explicitly set.
  var hasKeyPoints: Bool {return _storage._keyPoints != nil}
  /// Clears the value of `keyPoints`. Subsequent reads from it will return its default value.
  mutating func clearKeyPoints() {_uniqueStorage()._keyPoints = nil}

  var followups: PodcastFollowupsProto {
    get {return _storage._followups ?? PodcastFollowupsProto()}
    set {_uniqueStorage()._followups = newValue}
  }
  /// Returns true if `followups` has been explicitly set.
  var hasFollowups: Bool {return _storage._followups != nil}
  /// Clears the value of `followups`. Subsequent reads from it will return its default value.
  mutating func clearFollowups() {_uniqueStorage()._followups = nil}

  var completion: PodcastCompletionProto {
    get {return _storage._completion ?? PodcastCompletionProto()}
    set {_uniqueStorage()._completion = newValue}
  }
  /// Returns true if `completion` has been explicitly set.
  var hasCompletion: Bool {return _storage._completion != nil}
  /// Clears the value of `completion`. Subsequent reads from it will return its default value.
  mutating func clearCompletion() {_uniqueStorage()._completion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FirestorePodcastSuggestionsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var yourPodcastsShelf: YourPodcastsShelfProto {
    get {return _yourPodcastsShelf ?? YourPodcastsShelfProto()}
    set {_yourPodcastsShelf = newValue}
  }
  /// Returns true if `yourPodcastsShelf` has been explicitly set.
  var hasYourPodcastsShelf: Bool {return self._yourPodcastsShelf != nil}
  /// Clears the value of `yourPodcastsShelf`. Subsequent reads from it will return its default value.
  mutating func clearYourPodcastsShelf() {self._yourPodcastsShelf = nil}

  var suggestions: PodcastSuggestionsProto {
    get {return _suggestions ?? PodcastSuggestionsProto()}
    set {_suggestions = newValue}
  }
  /// Returns true if `suggestions` has been explicitly set.
  var hasSuggestions: Bool {return self._suggestions != nil}
  /// Clears the value of `suggestions`. Subsequent reads from it will return its default value.
  mutating func clearSuggestions() {self._suggestions = nil}

  var newSuggestionsGenerationState: PodcastSuggestionsGenerationStateProto {
    get {return _newSuggestionsGenerationState ?? PodcastSuggestionsGenerationStateProto()}
    set {_newSuggestionsGenerationState = newValue}
  }
  /// Returns true if `newSuggestionsGenerationState` has been explicitly set.
  var hasNewSuggestionsGenerationState: Bool {return self._newSuggestionsGenerationState != nil}
  /// Clears the value of `newSuggestionsGenerationState`. Subsequent reads from it will return its default value.
  mutating func clearNewSuggestionsGenerationState() {self._newSuggestionsGenerationState = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _yourPodcastsShelf: YourPodcastsShelfProto? = nil
  fileprivate var _suggestions: PodcastSuggestionsProto? = nil
  fileprivate var _newSuggestionsGenerationState: PodcastSuggestionsGenerationStateProto? = nil
}

struct YourPodcastsShelfProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var thumbnails: Dictionary<String,PodcastThumbnailProto> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastPointProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pointID: String = String()

  var title: String = String()

  var titleEmoji: String = String()

  var outline: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastThumbnailProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var podcastID: String = String()

  var status: PodcastStatusProto = .undefined

  var displayStatus: String = String()

  var title: String = String()

  /// used for large suggested thumbnails
  var longTitle: String = String()

  /// May be empty or Q&A, Debate, ...
  var badge: String = String()

  /// "breath", "stretch", "focus", ...
  var tags: [String] = []

  var type: PodcastTypeProto = .undefined

  var path: String = String()

  var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct PodcastAudioProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var duration: SwiftProtobuf.Google_Protobuf_Duration {
    get {return _duration ?? SwiftProtobuf.Google_Protobuf_Duration()}
    set {_duration = newValue}
  }
  /// Returns true if `duration` has been explicitly set.
  var hasDuration: Bool {return self._duration != nil}
  /// Clears the value of `duration`. Subsequent reads from it will return its default value.
  mutating func clearDuration() {self._duration = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _duration: SwiftProtobuf.Google_Protobuf_Duration? = nil
}

struct PodcastCardsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isReady: Bool = false

  var cards: [PodcastCardProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastCardProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var cardID: String = String()

  var isReady: Bool = false

  /// IDs start at 10
  var type: PodcastCardProto.OneOf_Type? = nil

  var knowledge: PodcastKnowledgeCardProto {
    get {
      if case .knowledge(let v)? = type {return v}
      return PodcastKnowledgeCardProto()
    }
    set {type = .knowledge(newValue)}
  }

  var multipleChoice: PodcastMultipleChoiceCardProto {
    get {
      if case .multipleChoice(let v)? = type {return v}
      return PodcastMultipleChoiceCardProto()
    }
    set {type = .multipleChoice(newValue)}
  }

  var poll: PodcastPollCardProto {
    get {
      if case .poll(let v)? = type {return v}
      return PodcastPollCardProto()
    }
    set {type = .poll(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// IDs start at 10
  enum OneOf_Type: Equatable, Sendable {
    case knowledge(PodcastKnowledgeCardProto)
    case multipleChoice(PodcastMultipleChoiceCardProto)
    case poll(PodcastPollCardProto)

  }

  init() {}
}

struct PodcastErrorProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastPromptAnswerProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastVisualsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var visuals: [PodcastVisualProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastVisualProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timestampMillis: Int32 = 0

  var imagePath: String = String()

  var animation: PodcastVisualAnimationProto {
    get {return _animation ?? PodcastVisualAnimationProto()}
    set {_animation = newValue}
  }
  /// Returns true if `animation` has been explicitly set.
  var hasAnimation: Bool {return self._animation != nil}
  /// Clears the value of `animation`. Subsequent reads from it will return its default value.
  mutating func clearAnimation() {self._animation = nil}

  var transition: PodcastVisualTransitionProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _animation: PodcastVisualAnimationProto? = nil
}

struct PodcastVisualAnimationProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var durationMillis: Int32 = 0

  var startScale: Float = 0

  var endScale: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastTranscriptProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [PodcastTranscriptEntryProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastTranscriptEntryProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var host: PodcastHostProto = .unknown

  var words: [PodcastWordProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastWordProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var word: String = String()

  var startMillis: Int32 = 0

  var endMillis: Int32 = 0

  var separator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// No user input assumed
struct PodcastKnowledgeCardProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var hero: PodcastCardHeroProto {
    get {return _hero ?? PodcastCardHeroProto()}
    set {_hero = newValue}
  }
  /// Returns true if `hero` has been explicitly set.
  var hasHero: Bool {return self._hero != nil}
  /// Clears the value of `hero`. Subsequent reads from it will return its default value.
  mutating func clearHero() {self._hero = nil}

  var text: String = String()

  var explanation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hero: PodcastCardHeroProto? = nil
}

/// 2: True/False, 3: A/B/C or 4: 1/2/3/4 user input
struct PodcastMultipleChoiceCardProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var hero: PodcastCardHeroProto {
    get {return _hero ?? PodcastCardHeroProto()}
    set {_hero = newValue}
  }
  /// Returns true if `hero` has been explicitly set.
  var hasHero: Bool {return self._hero != nil}
  /// Clears the value of `hero`. Subsequent reads from it will return its default value.
  mutating func clearHero() {self._hero = nil}

  var question: String = String()

  var options: [PodcastMultipleChoiceOptionProto] = []

  var correctAnswerNumber: Int32 = 0

  /// Number of hints is the number of possible wrong answers.
  var hints: [String] = []

  var explanation: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hero: PodcastCardHeroProto? = nil
}

/// 2, 3 or 4 options to vote for
struct PodcastPollCardProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var hero: PodcastCardHeroProto {
    get {return _hero ?? PodcastCardHeroProto()}
    set {_hero = newValue}
  }
  /// Returns true if `hero` has been explicitly set.
  var hasHero: Bool {return self._hero != nil}
  /// Clears the value of `hero`. Subsequent reads from it will return its default value.
  mutating func clearHero() {self._hero = nil}

  var question: String = String()

  /// commentary
  var options: [PodcastPollOptionProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hero: PodcastCardHeroProto? = nil
}

struct PodcastCardHeroProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var emoji: String = String()

  var lottieURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastMultipleChoiceOptionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Could be a label like True/False or a short sentence
  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastPollOptionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastKeyPointsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var keyPoints: [PodcastKeyPointProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastFollowupsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var label: String = String()

  var followups: [PodcastFollowupProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastFollowupProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var followupPodcastID: String = String()

  var emoji: String = String()

  var outline: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastKeyPointProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyPointID: String = String()

  var title: String = String()

  var titleEmoji: String = String()

  var outline: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastCompletionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// "Mark Complete"
  var action: String = String()

  /// "Excellent!"
  var encouragement: String = String()

  /// "⚡", "💎"
  var emoji: String = String()

  var lottieURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastSuggestionsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestionsID: String = String()

  var createdAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createdAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createdAt = newValue}
  }
  /// Returns true if `createdAt` has been explicitly set.
  var hasCreatedAt: Bool {return self._createdAt != nil}
  /// Clears the value of `createdAt`. Subsequent reads from it will return its default value.
  mutating func clearCreatedAt() {self._createdAt = nil}

  var sections: [PodcastSuggestionsSectionProto] = []

  var routine: PodcastRoutineProto {
    get {return _routine ?? PodcastRoutineProto()}
    set {_routine = newValue}
  }
  /// Returns true if `routine` has been explicitly set.
  var hasRoutine: Bool {return self._routine != nil}
  /// Clears the value of `routine`. Subsequent reads from it will return its default value.
  mutating func clearRoutine() {self._routine = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createdAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _routine: PodcastRoutineProto? = nil
}

struct PodcastSuggestionsGenerationStateProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var suggestionsID: String = String()

  var updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updatedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updatedAt = newValue}
  }
  /// Returns true if `updatedAt` has been explicitly set.
  var hasUpdatedAt: Bool {return self._updatedAt != nil}
  /// Clears the value of `updatedAt`. Subsequent reads from it will return its default value.
  mutating func clearUpdatedAt() {self._updatedAt = nil}

  var state: PodcastSuggestionsStateProto = .undefined

  var displayState: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct PodcastSuggestionsSectionProto: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sectionID: String {
    get {return _storage._sectionID}
    set {_uniqueStorage()._sectionID = newValue}
  }

  var sectionTitle: String {
    get {return _storage._sectionTitle}
    set {_uniqueStorage()._sectionTitle = newValue}
  }

  var bannerSuggestion: PodcastThumbnailProto {
    get {return _storage._bannerSuggestion ?? PodcastThumbnailProto()}
    set {_uniqueStorage()._bannerSuggestion = newValue}
  }
  /// Returns true if `bannerSuggestion` has been explicitly set.
  var hasBannerSuggestion: Bool {return _storage._bannerSuggestion != nil}
  /// Clears the value of `bannerSuggestion`. Subsequent reads from it will return its default value.
  mutating func clearBannerSuggestion() {_uniqueStorage()._bannerSuggestion = nil}

  var footerSuggestion: PodcastThumbnailProto {
    get {return _storage._footerSuggestion ?? PodcastThumbnailProto()}
    set {_uniqueStorage()._footerSuggestion = newValue}
  }
  /// Returns true if `footerSuggestion` has been explicitly set.
  var hasFooterSuggestion: Bool {return _storage._footerSuggestion != nil}
  /// Clears the value of `footerSuggestion`. Subsequent reads from it will return its default value.
  mutating func clearFooterSuggestion() {_uniqueStorage()._footerSuggestion = nil}

  var story1: PodcastStoryThumbnailProto {
    get {return _storage._story1 ?? PodcastStoryThumbnailProto()}
    set {_uniqueStorage()._story1 = newValue}
  }
  /// Returns true if `story1` has been explicitly set.
  var hasStory1: Bool {return _storage._story1 != nil}
  /// Clears the value of `story1`. Subsequent reads from it will return its default value.
  mutating func clearStory1() {_uniqueStorage()._story1 = nil}

  var story2: PodcastStoryThumbnailProto {
    get {return _storage._story2 ?? PodcastStoryThumbnailProto()}
    set {_uniqueStorage()._story2 = newValue}
  }
  /// Returns true if `story2` has been explicitly set.
  var hasStory2: Bool {return _storage._story2 != nil}
  /// Clears the value of `story2`. Subsequent reads from it will return its default value.
  mutating func clearStory2() {_uniqueStorage()._story2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct PodcastStoryThumbnailProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var storyID: String = String()

  var title: String = String()

  var thumbnailPath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastStoryHeaderProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var badge: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastStorySlideProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var slideID: String = String()

  var isTextReady: Bool = false

  var title: String = String()

  var imagePath: String = String()

  var text: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastRoutineProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routineID: String = String()

  var title: String = String()

  var segments: [PodcastRoutineSegmentProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastRoutineSegmentProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var segmentID: String = String()

  var title: String = String()

  var steps: [PodcastRoutineStepProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastRoutineStepProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var thumbnail: PodcastThumbnailProto {
    get {return _thumbnail ?? PodcastThumbnailProto()}
    set {_thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  var hasThumbnail: Bool {return self._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  mutating func clearThumbnail() {self._thumbnail = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _thumbnail: PodcastThumbnailProto? = nil
}

struct PodcastAppStoreTransactionProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionJws: String = String()

  var renewalInfoJws: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastUserProgressProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var routineProgress: Dictionary<String,PodcastRoutineProgressProto> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastRoutineProgressProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var stepProgress: Dictionary<String,PodcastRoutineStepProgressProto> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastRoutineStepProgressProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var completedAt: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _completedAt ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_completedAt = newValue}
  }
  /// Returns true if `completedAt` has been explicitly set.
  var hasCompletedAt: Bool {return self._completedAt != nil}
  /// Clears the value of `completedAt`. Subsequent reads from it will return its default value.
  mutating func clearCompletedAt() {self._completedAt = nil}

  var completed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _completedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

struct PodcastOnboardingInputProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var goalIds: [String] = []

  var learningStyleIds: [String] = []

  var interestIds: [String] = []

  var voiceID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct OnDeviceStoredUserDetailsProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userID: String = String()

  var subscriptionSource: PodcastSubscriptionSourceProto = .undefined

  var firestoreSuggestionsPath: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingConfigProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var goalsConfig: PodcastOnboardingGoalsConfigProto {
    get {return _goalsConfig ?? PodcastOnboardingGoalsConfigProto()}
    set {_goalsConfig = newValue}
  }
  /// Returns true if `goalsConfig` has been explicitly set.
  var hasGoalsConfig: Bool {return self._goalsConfig != nil}
  /// Clears the value of `goalsConfig`. Subsequent reads from it will return its default value.
  mutating func clearGoalsConfig() {self._goalsConfig = nil}

  var learningStylesConfig: PodcastOnboardingLearningStylesConfigProto {
    get {return _learningStylesConfig ?? PodcastOnboardingLearningStylesConfigProto()}
    set {_learningStylesConfig = newValue}
  }
  /// Returns true if `learningStylesConfig` has been explicitly set.
  var hasLearningStylesConfig: Bool {return self._learningStylesConfig != nil}
  /// Clears the value of `learningStylesConfig`. Subsequent reads from it will return its default value.
  mutating func clearLearningStylesConfig() {self._learningStylesConfig = nil}

  var interestsConfig: PodcastOnboardingInterestsConfigProto {
    get {return _interestsConfig ?? PodcastOnboardingInterestsConfigProto()}
    set {_interestsConfig = newValue}
  }
  /// Returns true if `interestsConfig` has been explicitly set.
  var hasInterestsConfig: Bool {return self._interestsConfig != nil}
  /// Clears the value of `interestsConfig`. Subsequent reads from it will return its default value.
  mutating func clearInterestsConfig() {self._interestsConfig = nil}

  var voicesConfig: PodcastOnboardingVoicesConfigProto {
    get {return _voicesConfig ?? PodcastOnboardingVoicesConfigProto()}
    set {_voicesConfig = newValue}
  }
  /// Returns true if `voicesConfig` has been explicitly set.
  var hasVoicesConfig: Bool {return self._voicesConfig != nil}
  /// Clears the value of `voicesConfig`. Subsequent reads from it will return its default value.
  mutating func clearVoicesConfig() {self._voicesConfig = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _goalsConfig: PodcastOnboardingGoalsConfigProto? = nil
  fileprivate var _learningStylesConfig: PodcastOnboardingLearningStylesConfigProto? = nil
  fileprivate var _interestsConfig: PodcastOnboardingInterestsConfigProto? = nil
  fileprivate var _voicesConfig: PodcastOnboardingVoicesConfigProto? = nil
}

struct PodcastOnboardingGoalsConfigProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pageTitle: String = String()

  var title: String = String()

  var subtitle: String = String()

  var goals: [PodcastOnboardingGoalProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingLearningStylesConfigProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pageTitle: String = String()

  var title: String = String()

  var subtitle: String = String()

  var learningStyles: [PodcastOnboardingLearningStyleProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingInterestsConfigProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pageTitle: String = String()

  var title: String = String()

  var subtitle: String = String()

  var interestGroups: [PodcastOnboardingInterestGroupProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingVoicesConfigProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pageTitle: String = String()

  var title: String = String()

  var subtitle: String = String()

  var voices: [PodcastOnboardingVoiceProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingInterestGroupProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interestGroupID: String = String()

  var interests: [PodcastOnboardingInterestProto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingGoalProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var goalID: String = String()

  var label: String = String()

  var emoji: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingLearningStyleProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var learningStyleID: String = String()

  var label: String = String()

  var subtitle: String = String()

  var emoji: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingInterestProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var interestID: String = String()

  var label: String = String()

  var emoji: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastOnboardingVoiceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var voiceID: String = String()

  var title: String = String()

  var subtitle: String = String()

  var samplePaths: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastUserAgentProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var device: PodcastDeviceProto {
    get {return _device ?? PodcastDeviceProto()}
    set {_device = newValue}
  }
  /// Returns true if `device` has been explicitly set.
  var hasDevice: Bool {return self._device != nil}
  /// Clears the value of `device`. Subsequent reads from it will return its default value.
  mutating func clearDevice() {self._device = nil}

  var locale: PodcastLocaleProto {
    get {return _locale ?? PodcastLocaleProto()}
    set {_locale = newValue}
  }
  /// Returns true if `locale` has been explicitly set.
  var hasLocale: Bool {return self._locale != nil}
  /// Clears the value of `locale`. Subsequent reads from it will return its default value.
  mutating func clearLocale() {self._locale = nil}

  var userInterfaceStyle: PodcastUserInterfaceStyleProto = .undefined

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _device: PodcastDeviceProto? = nil
  fileprivate var _locale: PodcastLocaleProto? = nil
}

struct PodcastLocaleProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var language: String = String()

  var country: String = String()

  var timeZone: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct PodcastDeviceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: PodcastDeviceProto.OneOf_Type? = nil

  var ios: PodcastIOSDeviceProto {
    get {
      if case .ios(let v)? = type {return v}
      return PodcastIOSDeviceProto()
    }
    set {type = .ios(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Type: Equatable, Sendable {
    case ios(PodcastIOSDeviceProto)

  }

  init() {}
}

struct PodcastIOSDeviceProto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceModel: String = String()

  var deviceIdentifier: String = String()

  var isSimulator: Bool = false

  var osName: String = String()

  var osVersion: String = String()

  var appBundleName: String = String()

  var appBundleVersion: String = String()

  var appBuildNumber: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PodcastSubscriptionSourceProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_SUBSCRIPTION_SOURCE_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_SUBSCRIPTION_SOURCE_PROTO_PLATFORM_SUBSCRIPTION"),
    2: .same(proto: "PODCAST_SUBSCRIPTION_SOURCE_PROTO_EXTERNAL_SUBSCRIPTION"),
  ]
}

extension PodcastStatusProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_STATUS_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_STATUS_PROTO_GENERATING"),
    2: .same(proto: "PODCAST_STATUS_PROTO_READY"),
    3: .same(proto: "PODCAST_STATUS_PROTO_FAILED"),
  ]
}

extension PodcastTypeProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_TYPE_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_TYPE_PROTO_EXPLAINER"),
    2: .same(proto: "PODCAST_TYPE_PROTO_EXERCISE"),
    3: .same(proto: "PODCAST_TYPE_PROTO_MEDITATION"),
  ]
}

extension PodcastVisualTransitionProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_DISSOLVE"),
    2: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_SWIPE"),
    3: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_BAR_SWIPE"),
    4: .same(proto: "PODCAST_VISUAL_TRANSITION_PROTO_PAGE_CURL"),
  ]
}

extension PodcastHostProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_HOST_PROTO_UNKNOWN"),
    1: .same(proto: "PODCAST_HOST_PROTO_MALE"),
    2: .same(proto: "PODCAST_HOST_PROTO_FEMALE"),
  ]
}

extension PodcastSuggestionsStateProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_SUGGESTIONS_STATE_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_SUGGESTIONS_STATE_PROTO_GENERATING"),
    2: .same(proto: "PODCAST_SUGGESTIONS_STATE_PROTO_READY"),
    3: .same(proto: "PODCAST_SUGGESTIONS_STATE_PROTO_FAILED"),
  ]
}

extension PodcastUserInterfaceStyleProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PODCAST_USER_INTERFACE_STYLE_PROTO_UNDEFINED"),
    1: .same(proto: "PODCAST_USER_INTERFACE_STYLE_PROTO_LIGHT"),
    2: .same(proto: "PODCAST_USER_INTERFACE_STYLE_PROTO_DARK"),
  ]
}

extension PodcastRequestAuthProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastRequestAuthProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "firebase_id_token"),
    2: .standard(proto: "appcheck_token"),
    3: .standard(proto: "is_anonomous"),
    4: .standard(proto: "appstore_current_entitlements"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.firebaseIDToken) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.appcheckToken) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isAnonomous) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.appstoreCurrentEntitlements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.firebaseIDToken.isEmpty {
      try visitor.visitSingularStringField(value: self.firebaseIDToken, fieldNumber: 1)
    }
    if !self.appcheckToken.isEmpty {
      try visitor.visitSingularStringField(value: self.appcheckToken, fieldNumber: 2)
    }
    if self.isAnonomous != false {
      try visitor.visitSingularBoolField(value: self.isAnonomous, fieldNumber: 3)
    }
    if !self.appstoreCurrentEntitlements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.appstoreCurrentEntitlements, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastRequestAuthProto, rhs: PodcastRequestAuthProto) -> Bool {
    if lhs.firebaseIDToken != rhs.firebaseIDToken {return false}
    if lhs.appcheckToken != rhs.appcheckToken {return false}
    if lhs.isAnonomous != rhs.isAnonomous {return false}
    if lhs.appstoreCurrentEntitlements != rhs.appstoreCurrentEntitlements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastSubscriptionStatusProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastSubscriptionStatusProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_subscriber"),
    2: .same(proto: "source"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isSubscriber) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.source) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSubscriber != false {
      try visitor.visitSingularBoolField(value: self.isSubscriber, fieldNumber: 1)
    }
    if self.source != .undefined {
      try visitor.visitSingularEnumField(value: self.source, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastSubscriptionStatusProto, rhs: PodcastSubscriptionStatusProto) -> Bool {
    if lhs.isSubscriber != rhs.isSubscriber {return false}
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStreamApiRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_auth"),
    10: .same(proto: "create"),
    11: .same(proto: "generate"),
    12: .same(proto: "podcast"),
    13: .same(proto: "story"),
    14: .standard(proto: "suggestion_points"),
    17: .standard(proto: "followup_points"),
    15: .same(proto: "home"),
    16: .standard(proto: "delete_account"),
    18: .standard(proto: "onboarding_input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._requestAuth) }()
      case 10: try {
        var v: CreatePodcastRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .create(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .create(v)
        }
      }()
      case 11: try {
        var v: GeneratePodcastRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .generate(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .generate(v)
        }
      }()
      case 12: try {
        var v: GetPodcastRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .podcast(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .podcast(v)
        }
      }()
      case 13: try {
        var v: GetPodcastStoryRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .story(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .story(v)
        }
      }()
      case 14: try {
        var v: GetPodcastSuggestionPointsRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .suggestionPoints(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .suggestionPoints(v)
        }
      }()
      case 15: try {
        var v: GetPodcastHomeRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .home(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .home(v)
        }
      }()
      case 16: try {
        var v: DeleteAccountRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .deleteAccount(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .deleteAccount(v)
        }
      }()
      case 17: try {
        var v: GetPodcastFollowupPointsRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .followupPoints(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .followupPoints(v)
        }
      }()
      case 18: try {
        var v: GetPodcastOnboardingInputRequestProto?
        var hadOneofValue = false
        if let current = self.request {
          hadOneofValue = true
          if case .onboardingInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.request = .onboardingInput(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._requestAuth {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    switch self.request {
    case .create?: try {
      guard case .create(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .generate?: try {
      guard case .generate(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .podcast?: try {
      guard case .podcast(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .story?: try {
      guard case .story(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .suggestionPoints?: try {
      guard case .suggestionPoints(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .home?: try {
      guard case .home(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .deleteAccount?: try {
      guard case .deleteAccount(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .followupPoints?: try {
      guard case .followupPoints(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .onboardingInput?: try {
      guard case .onboardingInput(let v)? = self.request else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiRequestProto, rhs: PodcastStreamApiRequestProto) -> Bool {
    if lhs._requestAuth != rhs._requestAuth {return false}
    if lhs.request != rhs.request {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStreamApiResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .standard(proto: "create_header"),
    11: .standard(proto: "generate_header"),
    12: .standard(proto: "podcast_header"),
    13: .standard(proto: "story_header"),
    14: .standard(proto: "suggestion_points_header"),
    17: .standard(proto: "followup_points_header"),
    15: .standard(proto: "home_header"),
    16: .standard(proto: "delete_account_header"),
    18: .standard(proto: "onboarding_input"),
    100: .same(proto: "latencies"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try {
        var v: CreatePodcastResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .createHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .createHeader(v)
        }
      }()
      case 11: try {
        var v: GeneratePodcastResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .generateHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .generateHeader(v)
        }
      }()
      case 12: try {
        var v: GetPodcastResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .podcastHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .podcastHeader(v)
        }
      }()
      case 13: try {
        var v: GetPodcastStoryResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .storyHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .storyHeader(v)
        }
      }()
      case 14: try {
        var v: GetPodcastSuggestionPointsResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .suggestionPointsHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .suggestionPointsHeader(v)
        }
      }()
      case 15: try {
        var v: GetPodcastHomeResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .homeHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .homeHeader(v)
        }
      }()
      case 16: try {
        var v: DeleteAccountResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .deleteAccountHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .deleteAccountHeader(v)
        }
      }()
      case 17: try {
        var v: GetPodcastFollowupPointsResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .followupPointsHeader(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .followupPointsHeader(v)
        }
      }()
      case 18: try {
        var v: GetPodcastOnboardingInputResponseHeaderProto?
        var hadOneofValue = false
        if let current = self.header {
          hadOneofValue = true
          if case .onboardingInput(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.header = .onboardingInput(v)
        }
      }()
      case 100: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: &self.latencies) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.header {
    case .createHeader?: try {
      guard case .createHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .generateHeader?: try {
      guard case .generateHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .podcastHeader?: try {
      guard case .podcastHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .storyHeader?: try {
      guard case .storyHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .suggestionPointsHeader?: try {
      guard case .suggestionPointsHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .homeHeader?: try {
      guard case .homeHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .deleteAccountHeader?: try {
      guard case .deleteAccountHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .followupPointsHeader?: try {
      guard case .followupPointsHeader(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .onboardingInput?: try {
      guard case .onboardingInput(let v)? = self.header else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    if !self.latencies.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.Google_Protobuf_Duration>.self, value: self.latencies, fieldNumber: 100)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiResponseHeaderProto, rhs: PodcastStreamApiResponseHeaderProto) -> Bool {
    if lhs.header != rhs.header {return false}
    if lhs.latencies != rhs.latencies {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStreamApiResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStreamApiResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    10: .standard(proto: "create_delta"),
    11: .standard(proto: "generate_delta"),
    12: .standard(proto: "podcast_delta"),
    13: .standard(proto: "story_delta"),
    14: .standard(proto: "suggestion_points_delta"),
    17: .standard(proto: "followup_points_delta"),
    15: .standard(proto: "home_delta"),
    16: .standard(proto: "delete_account_delta"),
    18: .standard(proto: "onboarding_input_delta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 10: try {
        var v: CreatePodcastResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .createDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .createDelta(v)
        }
      }()
      case 11: try {
        var v: GeneratePodcastResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .generateDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .generateDelta(v)
        }
      }()
      case 12: try {
        var v: GetPodcastResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .podcastDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .podcastDelta(v)
        }
      }()
      case 13: try {
        var v: GetPodcastStoryResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .storyDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .storyDelta(v)
        }
      }()
      case 14: try {
        var v: GetPodcastSuggestionPointsResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .suggestionPointsDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .suggestionPointsDelta(v)
        }
      }()
      case 15: try {
        var v: GetPodcastHomeResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .homeDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .homeDelta(v)
        }
      }()
      case 16: try {
        var v: DeleteAccountResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .deleteAccountDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .deleteAccountDelta(v)
        }
      }()
      case 17: try {
        var v: GetPodcastFollowupPointsResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .followupPointsDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .followupPointsDelta(v)
        }
      }()
      case 18: try {
        var v: GetPodcastOnboardingInputResponseDeltaProto?
        var hadOneofValue = false
        if let current = self.responseDelta {
          hadOneofValue = true
          if case .onboardingInputDelta(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.responseDelta = .onboardingInputDelta(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.responseDelta {
    case .createDelta?: try {
      guard case .createDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .generateDelta?: try {
      guard case .generateDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .podcastDelta?: try {
      guard case .podcastDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .storyDelta?: try {
      guard case .storyDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .suggestionPointsDelta?: try {
      guard case .suggestionPointsDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .homeDelta?: try {
      guard case .homeDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case .deleteAccountDelta?: try {
      guard case .deleteAccountDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
    }()
    case .followupPointsDelta?: try {
      guard case .followupPointsDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
    }()
    case .onboardingInputDelta?: try {
      guard case .onboardingInputDelta(let v)? = self.responseDelta else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStreamApiResponseDeltaProto, rhs: PodcastStreamApiResponseDeltaProto) -> Bool {
    if lhs.responseDelta != rhs.responseDelta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "prompt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.prompt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.prompt.isEmpty {
      try visitor.visitSingularStringField(value: self.prompt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastRequestProto, rhs: CreatePodcastRequestProto) -> Bool {
    if lhs.prompt != rhs.prompt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastResponseHeaderProto, rhs: CreatePodcastResponseHeaderProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreatePodcastResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreatePodcastResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "error"),
    2: .same(proto: "answer"),
    3: .same(proto: "point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastErrorProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .error(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .error(v)
        }
      }()
      case 2: try {
        var v: PodcastPromptAnswerProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .answer(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .answer(v)
        }
      }()
      case 3: try {
        var v: PodcastPointProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .point(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .point(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .error?: try {
      guard case .error(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .answer?: try {
      guard case .answer(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .point?: try {
      guard case .point(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreatePodcastResponseDeltaProto, rhs: CreatePodcastResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "points"),
    2: .same(proto: "suggestion"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: GeneratePodcastFromPointsProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .points(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .points(v)
        }
      }()
      case 2: try {
        var v: GeneratePodcastFromSuggestionProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .suggestion(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .suggestion(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .points?: try {
      guard case .points(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .suggestion?: try {
      guard case .suggestion(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastRequestProto, rhs: GeneratePodcastRequestProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastFromPointsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastFromPointsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "point_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pointIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    if !self.pointIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pointIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastFromPointsProto, rhs: GeneratePodcastFromPointsProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.pointIds != rhs.pointIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastFromSuggestionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastFromSuggestionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .standard(proto: "point_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.pointIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    if !self.pointIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.pointIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastFromSuggestionProto, rhs: GeneratePodcastFromSuggestionProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.pointIds != rhs.pointIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastResponseHeaderProto, rhs: GeneratePodcastResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GeneratePodcastResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GeneratePodcastResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "card"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastCardProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .card(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .card(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .card(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GeneratePodcastResponseDeltaProto, rhs: GeneratePodcastResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastRequestProto, rhs: GetPodcastRequestProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "podcast"),
    2: .same(proto: "cards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._podcast) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._cards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._podcast {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._cards {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastResponseHeaderProto, rhs: GetPodcastResponseHeaderProto) -> Bool {
    if lhs._podcast != rhs._podcast {return false}
    if lhs._cards != rhs._cards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastResponseDeltaProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastResponseDeltaProto, rhs: GetPodcastResponseDeltaProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastStoryRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastStoryRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastStoryRequestProto, rhs: GetPodcastStoryRequestProto) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastStoryResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastStoryResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastStoryResponseHeaderProto, rhs: GetPodcastStoryResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastStoryResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastStoryResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "header"),
    2: .same(proto: "slide"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastStoryHeaderProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .header(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .header(v)
        }
      }()
      case 2: try {
        var v: PodcastStorySlideProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .slide(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .slide(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.type {
    case .header?: try {
      guard case .header(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .slide?: try {
      guard case .slide(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastStoryResponseDeltaProto, rhs: GetPodcastStoryResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastSuggestionPointsRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastSuggestionPointsRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastSuggestionPointsRequestProto, rhs: GetPodcastSuggestionPointsRequestProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastSuggestionPointsResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastSuggestionPointsResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastSuggestionPointsResponseHeaderProto, rhs: GetPodcastSuggestionPointsResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastSuggestionPointsResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastSuggestionPointsResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastPointProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .point(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .point(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .point(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastSuggestionPointsResponseDeltaProto, rhs: GetPodcastSuggestionPointsResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastFollowupPointsRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastFollowupPointsRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "source_podcast_id"),
    2: .standard(proto: "followup_podcast_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sourcePodcastID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.followupPodcastID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sourcePodcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.sourcePodcastID, fieldNumber: 1)
    }
    if !self.followupPodcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.followupPodcastID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastFollowupPointsRequestProto, rhs: GetPodcastFollowupPointsRequestProto) -> Bool {
    if lhs.sourcePodcastID != rhs.sourcePodcastID {return false}
    if lhs.followupPodcastID != rhs.followupPodcastID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastFollowupPointsResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastFollowupPointsResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastFollowupPointsResponseHeaderProto, rhs: GetPodcastFollowupPointsResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastFollowupPointsResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastFollowupPointsResponseDeltaProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "point"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastPointProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .point(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .point(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .point(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastFollowupPointsResponseDeltaProto, rhs: GetPodcastFollowupPointsResponseDeltaProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastHomeRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastHomeRequestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "onboarding_input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._onboardingInput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._onboardingInput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastHomeRequestProto, rhs: GetPodcastHomeRequestProto) -> Bool {
    if lhs._onboardingInput != rhs._onboardingInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastHomeResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastHomeResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "subscription_status"),
    2: .standard(proto: "firestore_suggestions_path"),
    3: .standard(proto: "onboarding_required"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._subscriptionStatus) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.firestoreSuggestionsPath) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.onboardingRequired) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._subscriptionStatus {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.firestoreSuggestionsPath.isEmpty {
      try visitor.visitSingularStringField(value: self.firestoreSuggestionsPath, fieldNumber: 2)
    }
    if self.onboardingRequired != false {
      try visitor.visitSingularBoolField(value: self.onboardingRequired, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastHomeResponseHeaderProto, rhs: GetPodcastHomeResponseHeaderProto) -> Bool {
    if lhs._subscriptionStatus != rhs._subscriptionStatus {return false}
    if lhs.firestoreSuggestionsPath != rhs.firestoreSuggestionsPath {return false}
    if lhs.onboardingRequired != rhs.onboardingRequired {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastHomeResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastHomeResponseDeltaProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastHomeResponseDeltaProto, rhs: GetPodcastHomeResponseDeltaProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteAccountRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteAccountRequestProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteAccountRequestProto, rhs: DeleteAccountRequestProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteAccountResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteAccountResponseHeaderProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteAccountResponseHeaderProto, rhs: DeleteAccountResponseHeaderProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeleteAccountResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeleteAccountResponseDeltaProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeleteAccountResponseDeltaProto, rhs: DeleteAccountResponseDeltaProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastOnboardingInputRequestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastOnboardingInputRequestProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastOnboardingInputRequestProto, rhs: GetPodcastOnboardingInputRequestProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastOnboardingInputResponseHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastOnboardingInputResponseHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "onboarding_input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._onboardingInput) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._onboardingInput {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastOnboardingInputResponseHeaderProto, rhs: GetPodcastOnboardingInputResponseHeaderProto) -> Bool {
    if lhs._onboardingInput != rhs._onboardingInput {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GetPodcastOnboardingInputResponseDeltaProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GetPodcastOnboardingInputResponseDeltaProto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    // Load everything into unknown fields
    while try decoder.nextFieldNumber() != nil {}
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GetPodcastOnboardingInputResponseDeltaProto, rhs: GetPodcastOnboardingInputResponseDeltaProto) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "updated_at"),
    2: .same(proto: "thumbnail"),
    3: .same(proto: "audio"),
    4: .same(proto: "visuals"),
    5: .same(proto: "transcript"),
    6: .same(proto: "cards"),
    7: .standard(proto: "key_points"),
    8: .same(proto: "followups"),
    9: .same(proto: "completion"),
  ]

  fileprivate class _StorageClass {
    var _updatedAt: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
    var _thumbnail: PodcastThumbnailProto? = nil
    var _audio: PodcastAudioProto? = nil
    var _visuals: PodcastVisualsProto? = nil
    var _transcript: PodcastTranscriptProto? = nil
    var _cards: PodcastCardsProto? = nil
    var _keyPoints: PodcastKeyPointsProto? = nil
    var _followups: PodcastFollowupsProto? = nil
    var _completion: PodcastCompletionProto? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _updatedAt = source._updatedAt
      _thumbnail = source._thumbnail
      _audio = source._audio
      _visuals = source._visuals
      _transcript = source._transcript
      _cards = source._cards
      _keyPoints = source._keyPoints
      _followups = source._followups
      _completion = source._completion
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._updatedAt) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._thumbnail) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._audio) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._visuals) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._transcript) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._cards) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._keyPoints) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._followups) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._completion) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._updatedAt {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._thumbnail {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._audio {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._visuals {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._transcript {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._cards {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._keyPoints {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._followups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._completion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastProto, rhs: PodcastProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._updatedAt != rhs_storage._updatedAt {return false}
        if _storage._thumbnail != rhs_storage._thumbnail {return false}
        if _storage._audio != rhs_storage._audio {return false}
        if _storage._visuals != rhs_storage._visuals {return false}
        if _storage._transcript != rhs_storage._transcript {return false}
        if _storage._cards != rhs_storage._cards {return false}
        if _storage._keyPoints != rhs_storage._keyPoints {return false}
        if _storage._followups != rhs_storage._followups {return false}
        if _storage._completion != rhs_storage._completion {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FirestorePodcastSuggestionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FirestorePodcastSuggestionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "updated_at"),
    2: .standard(proto: "your_podcasts_shelf"),
    3: .same(proto: "suggestions"),
    4: .standard(proto: "new_suggestions_generation_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._yourPodcastsShelf) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._suggestions) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._newSuggestionsGenerationState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._yourPodcastsShelf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._suggestions {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._newSuggestionsGenerationState {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FirestorePodcastSuggestionsProto, rhs: FirestorePodcastSuggestionsProto) -> Bool {
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs._yourPodcastsShelf != rhs._yourPodcastsShelf {return false}
    if lhs._suggestions != rhs._suggestions {return false}
    if lhs._newSuggestionsGenerationState != rhs._newSuggestionsGenerationState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension YourPodcastsShelfProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "YourPodcastsShelfProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "thumbnails"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PodcastThumbnailProto>.self, value: &self.thumbnails) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.thumbnails.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PodcastThumbnailProto>.self, value: self.thumbnails, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: YourPodcastsShelfProto, rhs: YourPodcastsShelfProto) -> Bool {
    if lhs.thumbnails != rhs.thumbnails {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPointProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPointProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "point_id"),
    2: .same(proto: "title"),
    3: .standard(proto: "title_emoji"),
    4: .same(proto: "outline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.titleEmoji) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pointID.isEmpty {
      try visitor.visitSingularStringField(value: self.pointID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.titleEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.titleEmoji, fieldNumber: 3)
    }
    if !self.outline.isEmpty {
      try visitor.visitSingularStringField(value: self.outline, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPointProto, rhs: PodcastPointProto) -> Bool {
    if lhs.pointID != rhs.pointID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.titleEmoji != rhs.titleEmoji {return false}
    if lhs.outline != rhs.outline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastThumbnailProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastThumbnailProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "podcast_id"),
    2: .same(proto: "status"),
    3: .standard(proto: "display_status"),
    4: .same(proto: "title"),
    9: .standard(proto: "long_title"),
    5: .same(proto: "badge"),
    10: .same(proto: "tags"),
    11: .same(proto: "type"),
    6: .same(proto: "path"),
    7: .same(proto: "duration"),
    8: .standard(proto: "updated_at"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.podcastID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.displayStatus) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.badge) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.longTitle) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.tags) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.podcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.podcastID, fieldNumber: 1)
    }
    if self.status != .undefined {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.displayStatus.isEmpty {
      try visitor.visitSingularStringField(value: self.displayStatus, fieldNumber: 3)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 4)
    }
    if !self.badge.isEmpty {
      try visitor.visitSingularStringField(value: self.badge, fieldNumber: 5)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 6)
    }
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    if !self.longTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.longTitle, fieldNumber: 9)
    }
    if !self.tags.isEmpty {
      try visitor.visitRepeatedStringField(value: self.tags, fieldNumber: 10)
    }
    if self.type != .undefined {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastThumbnailProto, rhs: PodcastThumbnailProto) -> Bool {
    if lhs.podcastID != rhs.podcastID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.displayStatus != rhs.displayStatus {return false}
    if lhs.title != rhs.title {return false}
    if lhs.longTitle != rhs.longTitle {return false}
    if lhs.badge != rhs.badge {return false}
    if lhs.tags != rhs.tags {return false}
    if lhs.type != rhs.type {return false}
    if lhs.path != rhs.path {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastAudioProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastAudioProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "duration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.path) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._duration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try { if let v = self._duration {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastAudioProto, rhs: PodcastAudioProto) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs._duration != rhs._duration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastCardsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastCardsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_ready"),
    2: .same(proto: "cards"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isReady) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.cards) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isReady != false {
      try visitor.visitSingularBoolField(value: self.isReady, fieldNumber: 1)
    }
    if !self.cards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.cards, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastCardsProto, rhs: PodcastCardsProto) -> Bool {
    if lhs.isReady != rhs.isReady {return false}
    if lhs.cards != rhs.cards {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "card_id"),
    2: .standard(proto: "is_ready"),
    10: .same(proto: "knowledge"),
    11: .standard(proto: "multiple_choice"),
    12: .same(proto: "poll"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.cardID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isReady) }()
      case 10: try {
        var v: PodcastKnowledgeCardProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .knowledge(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .knowledge(v)
        }
      }()
      case 11: try {
        var v: PodcastMultipleChoiceCardProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .multipleChoice(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .multipleChoice(v)
        }
      }()
      case 12: try {
        var v: PodcastPollCardProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .poll(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .poll(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.cardID.isEmpty {
      try visitor.visitSingularStringField(value: self.cardID, fieldNumber: 1)
    }
    if self.isReady != false {
      try visitor.visitSingularBoolField(value: self.isReady, fieldNumber: 2)
    }
    switch self.type {
    case .knowledge?: try {
      guard case .knowledge(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .multipleChoice?: try {
      guard case .multipleChoice(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .poll?: try {
      guard case .poll(let v)? = self.type else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastCardProto, rhs: PodcastCardProto) -> Bool {
    if lhs.cardID != rhs.cardID {return false}
    if lhs.isReady != rhs.isReady {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastErrorProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastErrorProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastErrorProto, rhs: PodcastErrorProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPromptAnswerProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPromptAnswerProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPromptAnswerProto, rhs: PodcastPromptAnswerProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastVisualsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastVisualsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "visuals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.visuals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.visuals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.visuals, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastVisualsProto, rhs: PodcastVisualsProto) -> Bool {
    if lhs.visuals != rhs.visuals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastVisualProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastVisualProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "timestamp_millis"),
    2: .standard(proto: "image_path"),
    4: .same(proto: "animation"),
    3: .same(proto: "transition"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.timestampMillis) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.imagePath) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.transition) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._animation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.timestampMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.timestampMillis, fieldNumber: 1)
    }
    if !self.imagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePath, fieldNumber: 2)
    }
    if self.transition != .undefined {
      try visitor.visitSingularEnumField(value: self.transition, fieldNumber: 3)
    }
    try { if let v = self._animation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastVisualProto, rhs: PodcastVisualProto) -> Bool {
    if lhs.timestampMillis != rhs.timestampMillis {return false}
    if lhs.imagePath != rhs.imagePath {return false}
    if lhs._animation != rhs._animation {return false}
    if lhs.transition != rhs.transition {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastVisualAnimationProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastVisualAnimationProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "duration_millis"),
    2: .standard(proto: "start_scale"),
    3: .standard(proto: "end_scale"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.durationMillis) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.startScale) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self.endScale) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.durationMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.durationMillis, fieldNumber: 1)
    }
    if self.startScale.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.startScale, fieldNumber: 2)
    }
    if self.endScale.bitPattern != 0 {
      try visitor.visitSingularFloatField(value: self.endScale, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastVisualAnimationProto, rhs: PodcastVisualAnimationProto) -> Bool {
    if lhs.durationMillis != rhs.durationMillis {return false}
    if lhs.startScale != rhs.startScale {return false}
    if lhs.endScale != rhs.endScale {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastTranscriptProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastTranscriptProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.entries) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastTranscriptProto, rhs: PodcastTranscriptProto) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastTranscriptEntryProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastTranscriptEntryProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "host"),
    2: .same(proto: "words"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.host) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.words) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.host != .unknown {
      try visitor.visitSingularEnumField(value: self.host, fieldNumber: 1)
    }
    if !self.words.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.words, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastTranscriptEntryProto, rhs: PodcastTranscriptEntryProto) -> Bool {
    if lhs.host != rhs.host {return false}
    if lhs.words != rhs.words {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastWordProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastWordProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "word"),
    2: .standard(proto: "start_millis"),
    3: .standard(proto: "end_millis"),
    4: .same(proto: "separator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.word) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.startMillis) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.endMillis) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.separator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.word.isEmpty {
      try visitor.visitSingularStringField(value: self.word, fieldNumber: 1)
    }
    if self.startMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.startMillis, fieldNumber: 2)
    }
    if self.endMillis != 0 {
      try visitor.visitSingularInt32Field(value: self.endMillis, fieldNumber: 3)
    }
    if !self.separator.isEmpty {
      try visitor.visitSingularStringField(value: self.separator, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastWordProto, rhs: PodcastWordProto) -> Bool {
    if lhs.word != rhs.word {return false}
    if lhs.startMillis != rhs.startMillis {return false}
    if lhs.endMillis != rhs.endMillis {return false}
    if lhs.separator != rhs.separator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastKnowledgeCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastKnowledgeCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "hero"),
    3: .same(proto: "text"),
    4: .same(proto: "explanation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hero) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.text) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._hero {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 3)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastKnowledgeCardProto, rhs: PodcastKnowledgeCardProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._hero != rhs._hero {return false}
    if lhs.text != rhs.text {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastMultipleChoiceCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastMultipleChoiceCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "hero"),
    3: .same(proto: "question"),
    4: .same(proto: "options"),
    5: .standard(proto: "correct_answer_number"),
    6: .same(proto: "hints"),
    7: .same(proto: "explanation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hero) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.question) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.correctAnswerNumber) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.hints) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.explanation) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._hero {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.question.isEmpty {
      try visitor.visitSingularStringField(value: self.question, fieldNumber: 3)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 4)
    }
    if self.correctAnswerNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.correctAnswerNumber, fieldNumber: 5)
    }
    if !self.hints.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hints, fieldNumber: 6)
    }
    if !self.explanation.isEmpty {
      try visitor.visitSingularStringField(value: self.explanation, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastMultipleChoiceCardProto, rhs: PodcastMultipleChoiceCardProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._hero != rhs._hero {return false}
    if lhs.question != rhs.question {return false}
    if lhs.options != rhs.options {return false}
    if lhs.correctAnswerNumber != rhs.correctAnswerNumber {return false}
    if lhs.hints != rhs.hints {return false}
    if lhs.explanation != rhs.explanation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPollCardProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPollCardProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "hero"),
    3: .same(proto: "question"),
    4: .same(proto: "options"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._hero) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.question) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.options) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    try { if let v = self._hero {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.question.isEmpty {
      try visitor.visitSingularStringField(value: self.question, fieldNumber: 3)
    }
    if !self.options.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.options, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPollCardProto, rhs: PodcastPollCardProto) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs._hero != rhs._hero {return false}
    if lhs.question != rhs.question {return false}
    if lhs.options != rhs.options {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastCardHeroProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastCardHeroProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "emoji"),
    2: .standard(proto: "lottie_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.lottieURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 1)
    }
    if !self.lottieURL.isEmpty {
      try visitor.visitSingularStringField(value: self.lottieURL, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastCardHeroProto, rhs: PodcastCardHeroProto) -> Bool {
    if lhs.emoji != rhs.emoji {return false}
    if lhs.lottieURL != rhs.lottieURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastMultipleChoiceOptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastMultipleChoiceOptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastMultipleChoiceOptionProto, rhs: PodcastMultipleChoiceOptionProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastPollOptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastPollOptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastPollOptionProto, rhs: PodcastPollOptionProto) -> Bool {
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastKeyPointsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastKeyPointsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .standard(proto: "key_points"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.keyPoints) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.keyPoints.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.keyPoints, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastKeyPointsProto, rhs: PodcastKeyPointsProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.keyPoints != rhs.keyPoints {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastFollowupsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastFollowupsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "label"),
    2: .same(proto: "followups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.followups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 1)
    }
    if !self.followups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.followups, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastFollowupsProto, rhs: PodcastFollowupsProto) -> Bool {
    if lhs.label != rhs.label {return false}
    if lhs.followups != rhs.followups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastFollowupProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastFollowupProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "followup_podcast_id"),
    2: .same(proto: "emoji"),
    3: .same(proto: "outline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.followupPodcastID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.outline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.followupPodcastID.isEmpty {
      try visitor.visitSingularStringField(value: self.followupPodcastID, fieldNumber: 1)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 2)
    }
    if !self.outline.isEmpty {
      try visitor.visitSingularStringField(value: self.outline, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastFollowupProto, rhs: PodcastFollowupProto) -> Bool {
    if lhs.followupPodcastID != rhs.followupPodcastID {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.outline != rhs.outline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastKeyPointProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastKeyPointProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_point_id"),
    2: .same(proto: "title"),
    3: .standard(proto: "title_emoji"),
    4: .same(proto: "outline"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.keyPointID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.titleEmoji) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.outline) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyPointID.isEmpty {
      try visitor.visitSingularStringField(value: self.keyPointID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.titleEmoji.isEmpty {
      try visitor.visitSingularStringField(value: self.titleEmoji, fieldNumber: 3)
    }
    if !self.outline.isEmpty {
      try visitor.visitSingularStringField(value: self.outline, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastKeyPointProto, rhs: PodcastKeyPointProto) -> Bool {
    if lhs.keyPointID != rhs.keyPointID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.titleEmoji != rhs.titleEmoji {return false}
    if lhs.outline != rhs.outline {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastCompletionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastCompletionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "action"),
    2: .same(proto: "encouragement"),
    3: .same(proto: "emoji"),
    4: .standard(proto: "lottie_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.action) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.encouragement) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.lottieURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.action.isEmpty {
      try visitor.visitSingularStringField(value: self.action, fieldNumber: 1)
    }
    if !self.encouragement.isEmpty {
      try visitor.visitSingularStringField(value: self.encouragement, fieldNumber: 2)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 3)
    }
    if !self.lottieURL.isEmpty {
      try visitor.visitSingularStringField(value: self.lottieURL, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastCompletionProto, rhs: PodcastCompletionProto) -> Bool {
    if lhs.action != rhs.action {return false}
    if lhs.encouragement != rhs.encouragement {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.lottieURL != rhs.lottieURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastSuggestionsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastSuggestionsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suggestions_id"),
    2: .standard(proto: "created_at"),
    3: .same(proto: "sections"),
    4: .same(proto: "routine"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suggestionsID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._createdAt) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.sections) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._routine) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.suggestionsID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionsID, fieldNumber: 1)
    }
    try { if let v = self._createdAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.sections.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sections, fieldNumber: 3)
    }
    try { if let v = self._routine {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastSuggestionsProto, rhs: PodcastSuggestionsProto) -> Bool {
    if lhs.suggestionsID != rhs.suggestionsID {return false}
    if lhs._createdAt != rhs._createdAt {return false}
    if lhs.sections != rhs.sections {return false}
    if lhs._routine != rhs._routine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastSuggestionsGenerationStateProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastSuggestionsGenerationStateProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "suggestions_id"),
    2: .standard(proto: "updated_at"),
    3: .same(proto: "state"),
    4: .standard(proto: "display_state"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.suggestionsID) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._updatedAt) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.displayState) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.suggestionsID.isEmpty {
      try visitor.visitSingularStringField(value: self.suggestionsID, fieldNumber: 1)
    }
    try { if let v = self._updatedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.state != .undefined {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 3)
    }
    if !self.displayState.isEmpty {
      try visitor.visitSingularStringField(value: self.displayState, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastSuggestionsGenerationStateProto, rhs: PodcastSuggestionsGenerationStateProto) -> Bool {
    if lhs.suggestionsID != rhs.suggestionsID {return false}
    if lhs._updatedAt != rhs._updatedAt {return false}
    if lhs.state != rhs.state {return false}
    if lhs.displayState != rhs.displayState {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastSuggestionsSectionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastSuggestionsSectionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "section_id"),
    2: .standard(proto: "section_title"),
    3: .standard(proto: "banner_suggestion"),
    4: .standard(proto: "footer_suggestion"),
    5: .same(proto: "story1"),
    6: .same(proto: "story2"),
  ]

  fileprivate class _StorageClass {
    var _sectionID: String = String()
    var _sectionTitle: String = String()
    var _bannerSuggestion: PodcastThumbnailProto? = nil
    var _footerSuggestion: PodcastThumbnailProto? = nil
    var _story1: PodcastStoryThumbnailProto? = nil
    var _story2: PodcastStoryThumbnailProto? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _sectionID = source._sectionID
      _sectionTitle = source._sectionTitle
      _bannerSuggestion = source._bannerSuggestion
      _footerSuggestion = source._footerSuggestion
      _story1 = source._story1
      _story2 = source._story2
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._sectionID) }()
        case 2: try { try decoder.decodeSingularStringField(value: &_storage._sectionTitle) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._bannerSuggestion) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._footerSuggestion) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._story1) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._story2) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._sectionID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sectionID, fieldNumber: 1)
      }
      if !_storage._sectionTitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._sectionTitle, fieldNumber: 2)
      }
      try { if let v = _storage._bannerSuggestion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._footerSuggestion {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._story1 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._story2 {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastSuggestionsSectionProto, rhs: PodcastSuggestionsSectionProto) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._sectionID != rhs_storage._sectionID {return false}
        if _storage._sectionTitle != rhs_storage._sectionTitle {return false}
        if _storage._bannerSuggestion != rhs_storage._bannerSuggestion {return false}
        if _storage._footerSuggestion != rhs_storage._footerSuggestion {return false}
        if _storage._story1 != rhs_storage._story1 {return false}
        if _storage._story2 != rhs_storage._story2 {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStoryThumbnailProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStoryThumbnailProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "story_id"),
    2: .same(proto: "title"),
    3: .standard(proto: "thumbnail_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.storyID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.thumbnailPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.storyID.isEmpty {
      try visitor.visitSingularStringField(value: self.storyID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.thumbnailPath.isEmpty {
      try visitor.visitSingularStringField(value: self.thumbnailPath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStoryThumbnailProto, rhs: PodcastStoryThumbnailProto) -> Bool {
    if lhs.storyID != rhs.storyID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.thumbnailPath != rhs.thumbnailPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStoryHeaderProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStoryHeaderProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "badge"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.badge) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.badge.isEmpty {
      try visitor.visitSingularStringField(value: self.badge, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStoryHeaderProto, rhs: PodcastStoryHeaderProto) -> Bool {
    if lhs.badge != rhs.badge {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastStorySlideProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastStorySlideProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "slide_id"),
    2: .standard(proto: "is_text_ready"),
    3: .same(proto: "title"),
    4: .standard(proto: "image_path"),
    5: .same(proto: "text"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.slideID) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isTextReady) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.imagePath) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.slideID.isEmpty {
      try visitor.visitSingularStringField(value: self.slideID, fieldNumber: 1)
    }
    if self.isTextReady != false {
      try visitor.visitSingularBoolField(value: self.isTextReady, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    if !self.imagePath.isEmpty {
      try visitor.visitSingularStringField(value: self.imagePath, fieldNumber: 4)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastStorySlideProto, rhs: PodcastStorySlideProto) -> Bool {
    if lhs.slideID != rhs.slideID {return false}
    if lhs.isTextReady != rhs.isTextReady {return false}
    if lhs.title != rhs.title {return false}
    if lhs.imagePath != rhs.imagePath {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastRoutineProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastRoutineProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "routine_id"),
    3: .same(proto: "title"),
    1: .same(proto: "segments"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.segments) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.routineID) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.title) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.segments, fieldNumber: 1)
    }
    if !self.routineID.isEmpty {
      try visitor.visitSingularStringField(value: self.routineID, fieldNumber: 2)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastRoutineProto, rhs: PodcastRoutineProto) -> Bool {
    if lhs.routineID != rhs.routineID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.segments != rhs.segments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastRoutineSegmentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastRoutineSegmentProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "segment_id"),
    2: .same(proto: "title"),
    3: .same(proto: "steps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.segmentID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.steps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.segmentID.isEmpty {
      try visitor.visitSingularStringField(value: self.segmentID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.steps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.steps, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastRoutineSegmentProto, rhs: PodcastRoutineSegmentProto) -> Bool {
    if lhs.segmentID != rhs.segmentID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.steps != rhs.steps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastRoutineStepProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastRoutineStepProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    5: .same(proto: "thumbnail"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 5: try { try decoder.decodeSingularMessageField(value: &self._thumbnail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._thumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastRoutineStepProto, rhs: PodcastRoutineStepProto) -> Bool {
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastAppStoreTransactionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastAppStoreTransactionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_jws"),
    2: .standard(proto: "renewal_info_jws"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.transactionJws) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.renewalInfoJws) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionJws.isEmpty {
      try visitor.visitSingularStringField(value: self.transactionJws, fieldNumber: 1)
    }
    if !self.renewalInfoJws.isEmpty {
      try visitor.visitSingularStringField(value: self.renewalInfoJws, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastAppStoreTransactionProto, rhs: PodcastAppStoreTransactionProto) -> Bool {
    if lhs.transactionJws != rhs.transactionJws {return false}
    if lhs.renewalInfoJws != rhs.renewalInfoJws {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastUserProgressProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastUserProgressProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "routine_progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PodcastRoutineProgressProto>.self, value: &self.routineProgress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.routineProgress.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PodcastRoutineProgressProto>.self, value: self.routineProgress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastUserProgressProto, rhs: PodcastUserProgressProto) -> Bool {
    if lhs.routineProgress != rhs.routineProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastRoutineProgressProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastRoutineProgressProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "step_progress"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PodcastRoutineStepProgressProto>.self, value: &self.stepProgress) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.stepProgress.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,PodcastRoutineStepProgressProto>.self, value: self.stepProgress, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastRoutineProgressProto, rhs: PodcastRoutineProgressProto) -> Bool {
    if lhs.stepProgress != rhs.stepProgress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastRoutineStepProgressProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastRoutineStepProgressProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "completed_at"),
    2: .same(proto: "completed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._completedAt) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.completed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._completedAt {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if self.completed != false {
      try visitor.visitSingularBoolField(value: self.completed, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastRoutineStepProgressProto, rhs: PodcastRoutineStepProgressProto) -> Bool {
    if lhs._completedAt != rhs._completedAt {return false}
    if lhs.completed != rhs.completed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingInputProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingInputProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "goal_ids"),
    3: .standard(proto: "learning_style_ids"),
    4: .standard(proto: "interest_ids"),
    5: .standard(proto: "voice_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.goalIds) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.learningStyleIds) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.interestIds) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.voiceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.goalIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.goalIds, fieldNumber: 2)
    }
    if !self.learningStyleIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.learningStyleIds, fieldNumber: 3)
    }
    if !self.interestIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.interestIds, fieldNumber: 4)
    }
    if !self.voiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.voiceID, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingInputProto, rhs: PodcastOnboardingInputProto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.goalIds != rhs.goalIds {return false}
    if lhs.learningStyleIds != rhs.learningStyleIds {return false}
    if lhs.interestIds != rhs.interestIds {return false}
    if lhs.voiceID != rhs.voiceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension OnDeviceStoredUserDetailsProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "OnDeviceStoredUserDetailsProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_id"),
    2: .standard(proto: "subscription_source"),
    3: .standard(proto: "firestore_suggestions_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.userID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.subscriptionSource) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.firestoreSuggestionsPath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.userID.isEmpty {
      try visitor.visitSingularStringField(value: self.userID, fieldNumber: 1)
    }
    if self.subscriptionSource != .undefined {
      try visitor.visitSingularEnumField(value: self.subscriptionSource, fieldNumber: 2)
    }
    if !self.firestoreSuggestionsPath.isEmpty {
      try visitor.visitSingularStringField(value: self.firestoreSuggestionsPath, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: OnDeviceStoredUserDetailsProto, rhs: OnDeviceStoredUserDetailsProto) -> Bool {
    if lhs.userID != rhs.userID {return false}
    if lhs.subscriptionSource != rhs.subscriptionSource {return false}
    if lhs.firestoreSuggestionsPath != rhs.firestoreSuggestionsPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingConfigProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingConfigProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "goals_config"),
    2: .standard(proto: "learning_styles_config"),
    3: .standard(proto: "interests_config"),
    4: .standard(proto: "voices_config"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._goalsConfig) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._learningStylesConfig) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._interestsConfig) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._voicesConfig) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._goalsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._learningStylesConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._interestsConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._voicesConfig {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingConfigProto, rhs: PodcastOnboardingConfigProto) -> Bool {
    if lhs._goalsConfig != rhs._goalsConfig {return false}
    if lhs._learningStylesConfig != rhs._learningStylesConfig {return false}
    if lhs._interestsConfig != rhs._interestsConfig {return false}
    if lhs._voicesConfig != rhs._voicesConfig {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingGoalsConfigProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingGoalsConfigProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_title"),
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .same(proto: "goals"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageTitle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subtitle) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.goals) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.pageTitle, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.subtitle.isEmpty {
      try visitor.visitSingularStringField(value: self.subtitle, fieldNumber: 3)
    }
    if !self.goals.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.goals, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingGoalsConfigProto, rhs: PodcastOnboardingGoalsConfigProto) -> Bool {
    if lhs.pageTitle != rhs.pageTitle {return false}
    if lhs.title != rhs.title {return false}
    if lhs.subtitle != rhs.subtitle {return false}
    if lhs.goals != rhs.goals {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingLearningStylesConfigProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingLearningStylesConfigProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_title"),
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .standard(proto: "learning_styles"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageTitle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subtitle) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.learningStyles) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.pageTitle, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.subtitle.isEmpty {
      try visitor.visitSingularStringField(value: self.subtitle, fieldNumber: 3)
    }
    if !self.learningStyles.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.learningStyles, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingLearningStylesConfigProto, rhs: PodcastOnboardingLearningStylesConfigProto) -> Bool {
    if lhs.pageTitle != rhs.pageTitle {return false}
    if lhs.title != rhs.title {return false}
    if lhs.subtitle != rhs.subtitle {return false}
    if lhs.learningStyles != rhs.learningStyles {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingInterestsConfigProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingInterestsConfigProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_title"),
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .standard(proto: "interest_groups"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageTitle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subtitle) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.interestGroups) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.pageTitle, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.subtitle.isEmpty {
      try visitor.visitSingularStringField(value: self.subtitle, fieldNumber: 3)
    }
    if !self.interestGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interestGroups, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingInterestsConfigProto, rhs: PodcastOnboardingInterestsConfigProto) -> Bool {
    if lhs.pageTitle != rhs.pageTitle {return false}
    if lhs.title != rhs.title {return false}
    if lhs.subtitle != rhs.subtitle {return false}
    if lhs.interestGroups != rhs.interestGroups {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingVoicesConfigProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingVoicesConfigProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "page_title"),
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .same(proto: "voices"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.pageTitle) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subtitle) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.voices) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pageTitle.isEmpty {
      try visitor.visitSingularStringField(value: self.pageTitle, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.subtitle.isEmpty {
      try visitor.visitSingularStringField(value: self.subtitle, fieldNumber: 3)
    }
    if !self.voices.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.voices, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingVoicesConfigProto, rhs: PodcastOnboardingVoicesConfigProto) -> Bool {
    if lhs.pageTitle != rhs.pageTitle {return false}
    if lhs.title != rhs.title {return false}
    if lhs.subtitle != rhs.subtitle {return false}
    if lhs.voices != rhs.voices {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingInterestGroupProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingInterestGroupProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "interest_group_id"),
    2: .same(proto: "interests"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.interestGroupID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.interests) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interestGroupID.isEmpty {
      try visitor.visitSingularStringField(value: self.interestGroupID, fieldNumber: 1)
    }
    if !self.interests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.interests, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingInterestGroupProto, rhs: PodcastOnboardingInterestGroupProto) -> Bool {
    if lhs.interestGroupID != rhs.interestGroupID {return false}
    if lhs.interests != rhs.interests {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingGoalProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingGoalProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "goal_id"),
    2: .same(proto: "label"),
    3: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.goalID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.goalID.isEmpty {
      try visitor.visitSingularStringField(value: self.goalID, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingGoalProto, rhs: PodcastOnboardingGoalProto) -> Bool {
    if lhs.goalID != rhs.goalID {return false}
    if lhs.label != rhs.label {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingLearningStyleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingLearningStyleProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "learning_style_id"),
    2: .same(proto: "label"),
    3: .same(proto: "subtitle"),
    4: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.learningStyleID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subtitle) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.learningStyleID.isEmpty {
      try visitor.visitSingularStringField(value: self.learningStyleID, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.subtitle.isEmpty {
      try visitor.visitSingularStringField(value: self.subtitle, fieldNumber: 3)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingLearningStyleProto, rhs: PodcastOnboardingLearningStyleProto) -> Bool {
    if lhs.learningStyleID != rhs.learningStyleID {return false}
    if lhs.label != rhs.label {return false}
    if lhs.subtitle != rhs.subtitle {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingInterestProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingInterestProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "interest_id"),
    2: .same(proto: "label"),
    3: .same(proto: "emoji"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.interestID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.emoji) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.interestID.isEmpty {
      try visitor.visitSingularStringField(value: self.interestID, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if !self.emoji.isEmpty {
      try visitor.visitSingularStringField(value: self.emoji, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingInterestProto, rhs: PodcastOnboardingInterestProto) -> Bool {
    if lhs.interestID != rhs.interestID {return false}
    if lhs.label != rhs.label {return false}
    if lhs.emoji != rhs.emoji {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastOnboardingVoiceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastOnboardingVoiceProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "voice_id"),
    2: .same(proto: "title"),
    3: .same(proto: "subtitle"),
    4: .standard(proto: "sample_paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.voiceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.subtitle) }()
      case 4: try { try decoder.decodeRepeatedStringField(value: &self.samplePaths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.voiceID.isEmpty {
      try visitor.visitSingularStringField(value: self.voiceID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if !self.subtitle.isEmpty {
      try visitor.visitSingularStringField(value: self.subtitle, fieldNumber: 3)
    }
    if !self.samplePaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.samplePaths, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastOnboardingVoiceProto, rhs: PodcastOnboardingVoiceProto) -> Bool {
    if lhs.voiceID != rhs.voiceID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.subtitle != rhs.subtitle {return false}
    if lhs.samplePaths != rhs.samplePaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastUserAgentProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastUserAgentProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "device"),
    2: .same(proto: "locale"),
    3: .standard(proto: "user_interface_style"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._device) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._locale) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.userInterfaceStyle) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._device {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._locale {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if self.userInterfaceStyle != .undefined {
      try visitor.visitSingularEnumField(value: self.userInterfaceStyle, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastUserAgentProto, rhs: PodcastUserAgentProto) -> Bool {
    if lhs._device != rhs._device {return false}
    if lhs._locale != rhs._locale {return false}
    if lhs.userInterfaceStyle != rhs.userInterfaceStyle {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastLocaleProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastLocaleProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "language"),
    2: .same(proto: "country"),
    3: .standard(proto: "time_zone"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.timeZone) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 1)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 2)
    }
    if !self.timeZone.isEmpty {
      try visitor.visitSingularStringField(value: self.timeZone, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastLocaleProto, rhs: PodcastLocaleProto) -> Bool {
    if lhs.language != rhs.language {return false}
    if lhs.country != rhs.country {return false}
    if lhs.timeZone != rhs.timeZone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastDeviceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastDeviceProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ios"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: PodcastIOSDeviceProto?
        var hadOneofValue = false
        if let current = self.type {
          hadOneofValue = true
          if case .ios(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.type = .ios(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if case .ios(let v)? = self.type {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastDeviceProto, rhs: PodcastDeviceProto) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PodcastIOSDeviceProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PodcastIOSDeviceProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_model"),
    2: .standard(proto: "device_identifier"),
    3: .standard(proto: "is_simulator"),
    4: .standard(proto: "os_name"),
    5: .standard(proto: "os_version"),
    6: .standard(proto: "app_bundle_name"),
    7: .standard(proto: "app_bundle_version"),
    8: .standard(proto: "app_build_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceModel) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.deviceIdentifier) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isSimulator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.osName) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.osVersion) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.appBundleName) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.appBundleVersion) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.appBuildNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceModel.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceModel, fieldNumber: 1)
    }
    if !self.deviceIdentifier.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceIdentifier, fieldNumber: 2)
    }
    if self.isSimulator != false {
      try visitor.visitSingularBoolField(value: self.isSimulator, fieldNumber: 3)
    }
    if !self.osName.isEmpty {
      try visitor.visitSingularStringField(value: self.osName, fieldNumber: 4)
    }
    if !self.osVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.osVersion, fieldNumber: 5)
    }
    if !self.appBundleName.isEmpty {
      try visitor.visitSingularStringField(value: self.appBundleName, fieldNumber: 6)
    }
    if !self.appBundleVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.appBundleVersion, fieldNumber: 7)
    }
    if !self.appBuildNumber.isEmpty {
      try visitor.visitSingularStringField(value: self.appBuildNumber, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PodcastIOSDeviceProto, rhs: PodcastIOSDeviceProto) -> Bool {
    if lhs.deviceModel != rhs.deviceModel {return false}
    if lhs.deviceIdentifier != rhs.deviceIdentifier {return false}
    if lhs.isSimulator != rhs.isSimulator {return false}
    if lhs.osName != rhs.osName {return false}
    if lhs.osVersion != rhs.osVersion {return false}
    if lhs.appBundleName != rhs.appBundleName {return false}
    if lhs.appBundleVersion != rhs.appBundleVersion {return false}
    if lhs.appBuildNumber != rhs.appBuildNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
