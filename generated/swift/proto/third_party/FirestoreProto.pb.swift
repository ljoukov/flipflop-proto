// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: third_party/FirestoreProto.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Google_Firestore_V1_StatusCode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case ok // = 0
  case cancelled // = 1
  case unknown // = 2
  case invalidArgument // = 3
  case deadlineExceeded // = 4
  case notFound // = 5
  case alreadyExists // = 6
  case permissionDenied // = 7
  case unauthenticated // = 16
  case resourceExhausted // = 8
  case failedPrecondition // = 9
  case aborted // = 10
  case outOfRange // = 11
  case unimplemented // = 12
  case `internal` // = 13
  case unavailable // = 14
  case dataLoss // = 15
  case UNRECOGNIZED(Int)

  init() {
    self = .ok
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .cancelled
    case 2: self = .unknown
    case 3: self = .invalidArgument
    case 4: self = .deadlineExceeded
    case 5: self = .notFound
    case 6: self = .alreadyExists
    case 7: self = .permissionDenied
    case 8: self = .resourceExhausted
    case 9: self = .failedPrecondition
    case 10: self = .aborted
    case 11: self = .outOfRange
    case 12: self = .unimplemented
    case 13: self = .internal
    case 14: self = .unavailable
    case 15: self = .dataLoss
    case 16: self = .unauthenticated
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .ok: return 0
    case .cancelled: return 1
    case .unknown: return 2
    case .invalidArgument: return 3
    case .deadlineExceeded: return 4
    case .notFound: return 5
    case .alreadyExists: return 6
    case .permissionDenied: return 7
    case .resourceExhausted: return 8
    case .failedPrecondition: return 9
    case .aborted: return 10
    case .outOfRange: return 11
    case .unimplemented: return 12
    case .internal: return 13
    case .unavailable: return 14
    case .dataLoss: return 15
    case .unauthenticated: return 16
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Google_Firestore_V1_StatusCode: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Google_Firestore_V1_StatusCode] = [
    .ok,
    .cancelled,
    .unknown,
    .invalidArgument,
    .deadlineExceeded,
    .notFound,
    .alreadyExists,
    .permissionDenied,
    .unauthenticated,
    .resourceExhausted,
    .failedPrecondition,
    .aborted,
    .outOfRange,
    .unimplemented,
    .internal,
    .unavailable,
    .dataLoss,
  ]
}

#endif  // swift(>=4.2)

struct Google_Firestore_V1_RpcError {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var code: Int32 = 0

  var message: String = String()

  var status: Google_Firestore_V1_StatusCode = .ok

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A Firestore document.
///
/// Must not exceed 1 MiB - 4 bytes.
struct Google_Firestore_V1_Document {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The resource name of the document, for example
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  var name: String = String()

  /// The document's fields.
  ///
  /// The map keys represent field names.
  ///
  /// A simple field name contains only characters `a` to `z`, `A` to `Z`,
  /// `0` to `9`, or `_`, and must not start with `0` to `9`. For example,
  /// `foo_bar_17`.
  ///
  /// Field names matching the regular expression `__.*__` are reserved. Reserved
  /// field names are forbidden except in certain documented contexts. The map
  /// keys, represented as UTF-8, must not exceed 1,500 bytes and cannot be
  /// empty.
  ///
  /// Field paths may be used in other contexts to refer to structured fields
  /// defined here. For `map_value`, the field path is represented by the simple
  /// or quoted field names of the containing fields, delimited by `.`. For
  /// example, the structured field
  /// `"foo" : { map_value: { "x&y" : { string_value: "hello" }}}` would be
  /// represented by the field path `foo.x&y`.
  ///
  /// Within a field path, a quoted field name starts and ends with `` ` `` and
  /// may contain any character. Some characters, including `` ` ``, must be
  /// escaped using a `\`. For example, `` `x&y` `` represents `x&y` and
  /// `` `bak\`tik` `` represents `` bak`tik ``.
  var fields: Dictionary<String,Google_Firestore_V1_Value> = [:]

  /// Output only. The time at which the document was created.
  ///
  /// This value increases monotonically when a document is deleted then
  /// recreated. It can also be compared to values from other documents and
  /// the `read_time` of a query.
  var createTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _createTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_createTime = newValue}
  }
  /// Returns true if `createTime` has been explicitly set.
  var hasCreateTime: Bool {return self._createTime != nil}
  /// Clears the value of `createTime`. Subsequent reads from it will return its default value.
  mutating func clearCreateTime() {self._createTime = nil}

  /// Output only. The time at which the document was last changed.
  ///
  /// This value is initially set to the `create_time` then increases
  /// monotonically with each change to the document. It can also be
  /// compared to values from other documents and the `read_time` of a query.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A message that can hold any of the supported value types.
struct Google_Firestore_V1_Value {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Must have a value set.
  var valueType: Google_Firestore_V1_Value.OneOf_ValueType? = nil

  /// A null value.
  var nullValue: SwiftProtobuf.Google_Protobuf_NullValue {
    get {
      if case .nullValue(let v)? = valueType {return v}
      return .nullValue
    }
    set {valueType = .nullValue(newValue)}
  }

  /// A boolean value.
  var booleanValue: Bool {
    get {
      if case .booleanValue(let v)? = valueType {return v}
      return false
    }
    set {valueType = .booleanValue(newValue)}
  }

  /// An integer value.
  var integerValue: Int64 {
    get {
      if case .integerValue(let v)? = valueType {return v}
      return 0
    }
    set {valueType = .integerValue(newValue)}
  }

  /// A double value.
  var doubleValue: Double {
    get {
      if case .doubleValue(let v)? = valueType {return v}
      return 0
    }
    set {valueType = .doubleValue(newValue)}
  }

  /// A timestamp value.
  ///
  /// Precise only to microseconds. When stored, any additional precision is
  /// rounded down.
  var timestampValue: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .timestampValue(let v)? = valueType {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {valueType = .timestampValue(newValue)}
  }

  /// A string value.
  ///
  /// The string, represented as UTF-8, must not exceed 1 MiB - 89 bytes.
  /// Only the first 1,500 bytes of the UTF-8 representation are considered by
  /// queries.
  var stringValue: String {
    get {
      if case .stringValue(let v)? = valueType {return v}
      return String()
    }
    set {valueType = .stringValue(newValue)}
  }

  /// A bytes value.
  ///
  /// Must not exceed 1 MiB - 89 bytes.
  /// Only the first 1,500 bytes are considered by queries.
  var bytesValue: Data {
    get {
      if case .bytesValue(let v)? = valueType {return v}
      return Data()
    }
    set {valueType = .bytesValue(newValue)}
  }

  /// A reference to a document. For example:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  var referenceValue: String {
    get {
      if case .referenceValue(let v)? = valueType {return v}
      return String()
    }
    set {valueType = .referenceValue(newValue)}
  }

  /// A geo point value representing a point on the surface of Earth.
  var geoPointValue: Google_Firestore_V1_LatLng {
    get {
      if case .geoPointValue(let v)? = valueType {return v}
      return Google_Firestore_V1_LatLng()
    }
    set {valueType = .geoPointValue(newValue)}
  }

  /// An array value.
  ///
  /// Cannot directly contain another array value, though can contain an
  /// map which contains another array.
  var arrayValue: Google_Firestore_V1_ArrayValue {
    get {
      if case .arrayValue(let v)? = valueType {return v}
      return Google_Firestore_V1_ArrayValue()
    }
    set {valueType = .arrayValue(newValue)}
  }

  /// A map value.
  var mapValue: Google_Firestore_V1_MapValue {
    get {
      if case .mapValue(let v)? = valueType {return v}
      return Google_Firestore_V1_MapValue()
    }
    set {valueType = .mapValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Must have a value set.
  enum OneOf_ValueType: Equatable {
    /// A null value.
    case nullValue(SwiftProtobuf.Google_Protobuf_NullValue)
    /// A boolean value.
    case booleanValue(Bool)
    /// An integer value.
    case integerValue(Int64)
    /// A double value.
    case doubleValue(Double)
    /// A timestamp value.
    ///
    /// Precise only to microseconds. When stored, any additional precision is
    /// rounded down.
    case timestampValue(SwiftProtobuf.Google_Protobuf_Timestamp)
    /// A string value.
    ///
    /// The string, represented as UTF-8, must not exceed 1 MiB - 89 bytes.
    /// Only the first 1,500 bytes of the UTF-8 representation are considered by
    /// queries.
    case stringValue(String)
    /// A bytes value.
    ///
    /// Must not exceed 1 MiB - 89 bytes.
    /// Only the first 1,500 bytes are considered by queries.
    case bytesValue(Data)
    /// A reference to a document. For example:
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    case referenceValue(String)
    /// A geo point value representing a point on the surface of Earth.
    case geoPointValue(Google_Firestore_V1_LatLng)
    /// An array value.
    ///
    /// Cannot directly contain another array value, though can contain an
    /// map which contains another array.
    case arrayValue(Google_Firestore_V1_ArrayValue)
    /// A map value.
    case mapValue(Google_Firestore_V1_MapValue)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Firestore_V1_Value.OneOf_ValueType, rhs: Google_Firestore_V1_Value.OneOf_ValueType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.nullValue, .nullValue): return {
        guard case .nullValue(let l) = lhs, case .nullValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.booleanValue, .booleanValue): return {
        guard case .booleanValue(let l) = lhs, case .booleanValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.integerValue, .integerValue): return {
        guard case .integerValue(let l) = lhs, case .integerValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.doubleValue, .doubleValue): return {
        guard case .doubleValue(let l) = lhs, case .doubleValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timestampValue, .timestampValue): return {
        guard case .timestampValue(let l) = lhs, case .timestampValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stringValue, .stringValue): return {
        guard case .stringValue(let l) = lhs, case .stringValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bytesValue, .bytesValue): return {
        guard case .bytesValue(let l) = lhs, case .bytesValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.referenceValue, .referenceValue): return {
        guard case .referenceValue(let l) = lhs, case .referenceValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.geoPointValue, .geoPointValue): return {
        guard case .geoPointValue(let l) = lhs, case .geoPointValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.arrayValue, .arrayValue): return {
        guard case .arrayValue(let l) = lhs, case .arrayValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.mapValue, .mapValue): return {
        guard case .mapValue(let l) = lhs, case .mapValue(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// An array value.
struct Google_Firestore_V1_ArrayValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Values in the array.
  var values: [Google_Firestore_V1_Value] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A map value.
struct Google_Firestore_V1_MapValue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The map's fields.
  ///
  /// The map keys represent field names. Field names matching the regular
  /// expression `__.*__` are reserved. Reserved field names are forbidden except
  /// in certain documented contexts. The map keys, represented as UTF-8, must
  /// not exceed 1,500 bytes and cannot be empty.
  var fields: Dictionary<String,Google_Firestore_V1_Value> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An object that represents a latitude/longitude pair. This is expressed as a
/// pair of doubles to represent degrees latitude and degrees longitude. Unless
/// specified otherwise, this must conform to the
/// <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
/// standard</a>. Values must be within normalized ranges.
struct Google_Firestore_V1_LatLng {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The latitude in degrees. It must be in the range [-90.0, +90.0].
  var latitude: Double = 0

  /// The longitude in degrees. It must be in the range [-180.0, +180.0].
  var longitude: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Google_Firestore_V1_ListDocumentsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The Documents found.
  var documents: [Google_Firestore_V1_Document] = []

  /// The next page token.
  var nextPageToken: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The request for [Firestore.Write][google.firestore.v1.Firestore.Write].
///
/// The first request creates a stream, or resumes an existing one from a token.
///
/// When creating a new stream, the server replies with a response containing
/// only an ID and a token, to use in the next request.
///
/// When resuming a stream, the server first streams any responses later than the
/// given token, then a response containing only an up-to-date token, to use in
/// the next request.
struct Google_Firestore_V1_WriteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the write stream to resume.
  /// This may only be set in the first message. When left empty, a new write
  /// stream will be created.
  var streamID: String {
    get {return _streamID ?? String()}
    set {_streamID = newValue}
  }
  /// Returns true if `streamID` has been explicitly set.
  var hasStreamID: Bool {return self._streamID != nil}
  /// Clears the value of `streamID`. Subsequent reads from it will return its default value.
  mutating func clearStreamID() {self._streamID = nil}

  /// The writes to apply.
  ///
  /// Always executed atomically and in order.
  /// This must be empty on the first request.
  /// This may be empty on the last request.
  /// This must not be empty on all other requests.
  var writes: [Google_Firestore_V1_Write] = []

  /// A stream token that was previously sent by the server.
  ///
  /// The client should set this field to the token from the most recent
  /// [WriteResponse][google.firestore.v1.WriteResponse] it has received. This
  /// acknowledges that the client has received responses up to this token. After
  /// sending this token, earlier tokens may not be used anymore.
  ///
  /// The server may close the stream if there are too many unacknowledged
  /// responses.
  ///
  /// Leave this field unset when creating a new stream. To resume a stream at
  /// a specific point, set this field and the `stream_id` field.
  ///
  /// Leave this field unset when creating a new stream.
  var streamToken: Data {
    get {return _streamToken ?? Data()}
    set {_streamToken = newValue}
  }
  /// Returns true if `streamToken` has been explicitly set.
  var hasStreamToken: Bool {return self._streamToken != nil}
  /// Clears the value of `streamToken`. Subsequent reads from it will return its default value.
  mutating func clearStreamToken() {self._streamToken = nil}

  /// Labels associated with this write request.
  var labels: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _streamID: String? = nil
  fileprivate var _streamToken: Data? = nil
}

/// The response for [Firestore.Write][google.firestore.v1.Firestore.Write].
struct Google_Firestore_V1_WriteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ID of the stream.
  /// Only set on the first message, when a new stream was created.
  var streamID: String = String()

  /// A token that represents the position of this response in the stream.
  /// This can be used by a client to resume the stream at this point.
  ///
  /// This field is always set.
  var streamToken: Data = Data()

  /// The result of applying the writes.
  ///
  /// This i-th write result corresponds to the i-th write in the
  /// request.
  var writeResults: [Google_Firestore_V1_WriteResult] = []

  /// The time at which the commit occurred. Any read with an equal or greater
  /// `read_time` is guaranteed to see the effects of the write.
  var commitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTime = newValue}
  }
  /// Returns true if `commitTime` has been explicitly set.
  var hasCommitTime: Bool {return self._commitTime != nil}
  /// Clears the value of `commitTime`. Subsequent reads from it will return its default value.
  mutating func clearCommitTime() {self._commitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// The result of applying a write.
struct Google_Firestore_V1_WriteResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The last update time of the document after applying the write. Not set
  /// after a `delete`.
  ///
  /// If the write did not actually change the document, this will be the
  /// previous update_time.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _updateTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_updateTime = newValue}
  }
  /// Returns true if `updateTime` has been explicitly set.
  var hasUpdateTime: Bool {return self._updateTime != nil}
  /// Clears the value of `updateTime`. Subsequent reads from it will return its default value.
  mutating func clearUpdateTime() {self._updateTime = nil}

  /// The results of applying each
  /// [DocumentTransform.FieldTransform][google.firestore.v1.DocumentTransform.FieldTransform],
  /// in the same order.
  var transformResults: [Google_Firestore_V1_Value] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updateTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// Required. The database name. In the format:
/// `projects/{project_id}/databases/{database_id}`.
/// [SUPPLIED VIA URL PATH] string database = 1 [(google.api.field_behavior) =
/// REQUIRED];
struct Google_Firestore_V1_CommitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The writes to apply.
  ///
  /// Always executed atomically and in order.
  var writes: [Google_Firestore_V1_Write] = []

  /// If set, applies all writes in this transaction, and commits it.
  var transaction: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// The response for [Firestore.Commit][google.firestore.v1.Firestore.Commit].
struct Google_Firestore_V1_CommitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The result of applying the writes.
  ///
  /// This i-th write result corresponds to the i-th write in the
  /// request.
  var writeResults: [Google_Firestore_V1_WriteResult] = []

  /// The time at which the commit occurred. Any read with an equal or greater
  /// `read_time` is guaranteed to see the effects of the commit.
  var commitTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _commitTime ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_commitTime = newValue}
  }
  /// Returns true if `commitTime` has been explicitly set.
  var hasCommitTime: Bool {return self._commitTime != nil}
  /// Clears the value of `commitTime`. Subsequent reads from it will return its default value.
  mutating func clearCommitTime() {self._commitTime = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _commitTime: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// A write on a document.
struct Google_Firestore_V1_Write {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The operation to execute.
  var operation: Google_Firestore_V1_Write.OneOf_Operation? = nil

  /// A document to write.
  var update: Google_Firestore_V1_Document {
    get {
      if case .update(let v)? = operation {return v}
      return Google_Firestore_V1_Document()
    }
    set {operation = .update(newValue)}
  }

  /// A document name to delete. In the format:
  /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
  var delete: String {
    get {
      if case .delete(let v)? = operation {return v}
      return String()
    }
    set {operation = .delete(newValue)}
  }

  var updateMask: Google_Firestore_V1_DocumentMask {
    get {return _updateMask ?? Google_Firestore_V1_DocumentMask()}
    set {_updateMask = newValue}
  }
  /// Returns true if `updateMask` has been explicitly set.
  var hasUpdateMask: Bool {return self._updateMask != nil}
  /// Clears the value of `updateMask`. Subsequent reads from it will return its default value.
  mutating func clearUpdateMask() {self._updateMask = nil}

  /// An optional precondition on the document.
  ///
  /// The write will fail if this is set and not met by the target document.
  var currentDocument: Google_Firestore_V1_Precondition {
    get {return _currentDocument ?? Google_Firestore_V1_Precondition()}
    set {_currentDocument = newValue}
  }
  /// Returns true if `currentDocument` has been explicitly set.
  var hasCurrentDocument: Bool {return self._currentDocument != nil}
  /// Clears the value of `currentDocument`. Subsequent reads from it will return its default value.
  mutating func clearCurrentDocument() {self._currentDocument = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The operation to execute.
  enum OneOf_Operation: Equatable {
    /// A document to write.
    case update(Google_Firestore_V1_Document)
    /// A document name to delete. In the format:
    /// `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
    case delete(String)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Firestore_V1_Write.OneOf_Operation, rhs: Google_Firestore_V1_Write.OneOf_Operation) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.update, .update): return {
        guard case .update(let l) = lhs, case .update(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.delete, .delete): return {
        guard case .delete(let l) = lhs, case .delete(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _updateMask: Google_Firestore_V1_DocumentMask? = nil
  fileprivate var _currentDocument: Google_Firestore_V1_Precondition? = nil
}

struct Google_Firestore_V1_DocumentMask {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of field paths in the mask. See
  /// [Document.fields][google.firestore.v1.Document.fields] for a field path
  /// syntax reference.
  var fieldPaths: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Google_Firestore_V1_Precondition {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The type of precondition.
  var conditionType: Google_Firestore_V1_Precondition.OneOf_ConditionType? = nil

  /// When set to `true`, the target document must exist.
  /// When set to `false`, the target document must not exist.
  var exists: Bool {
    get {
      if case .exists(let v)? = conditionType {return v}
      return false
    }
    set {conditionType = .exists(newValue)}
  }

  /// When set, the target document must exist and have been last updated at
  /// that time. Timestamp must be microsecond aligned.
  var updateTime: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {
      if case .updateTime(let v)? = conditionType {return v}
      return SwiftProtobuf.Google_Protobuf_Timestamp()
    }
    set {conditionType = .updateTime(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// The type of precondition.
  enum OneOf_ConditionType: Equatable {
    /// When set to `true`, the target document must exist.
    /// When set to `false`, the target document must not exist.
    case exists(Bool)
    /// When set, the target document must exist and have been last updated at
    /// that time. Timestamp must be microsecond aligned.
    case updateTime(SwiftProtobuf.Google_Protobuf_Timestamp)

  #if !swift(>=4.1)
    static func ==(lhs: Google_Firestore_V1_Precondition.OneOf_ConditionType, rhs: Google_Firestore_V1_Precondition.OneOf_ConditionType) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.exists, .exists): return {
        guard case .exists(let l) = lhs, case .exists(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.updateTime, .updateTime): return {
        guard case .updateTime(let l) = lhs, case .updateTime(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Google_Firestore_V1_StatusCode: @unchecked Sendable {}
extension Google_Firestore_V1_RpcError: @unchecked Sendable {}
extension Google_Firestore_V1_Document: @unchecked Sendable {}
extension Google_Firestore_V1_Value: @unchecked Sendable {}
extension Google_Firestore_V1_Value.OneOf_ValueType: @unchecked Sendable {}
extension Google_Firestore_V1_ArrayValue: @unchecked Sendable {}
extension Google_Firestore_V1_MapValue: @unchecked Sendable {}
extension Google_Firestore_V1_LatLng: @unchecked Sendable {}
extension Google_Firestore_V1_ListDocumentsResponse: @unchecked Sendable {}
extension Google_Firestore_V1_WriteRequest: @unchecked Sendable {}
extension Google_Firestore_V1_WriteResponse: @unchecked Sendable {}
extension Google_Firestore_V1_WriteResult: @unchecked Sendable {}
extension Google_Firestore_V1_CommitRequest: @unchecked Sendable {}
extension Google_Firestore_V1_CommitResponse: @unchecked Sendable {}
extension Google_Firestore_V1_Write: @unchecked Sendable {}
extension Google_Firestore_V1_Write.OneOf_Operation: @unchecked Sendable {}
extension Google_Firestore_V1_DocumentMask: @unchecked Sendable {}
extension Google_Firestore_V1_Precondition: @unchecked Sendable {}
extension Google_Firestore_V1_Precondition.OneOf_ConditionType: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "google.firestore.v1"

extension Google_Firestore_V1_StatusCode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "CANCELLED"),
    2: .same(proto: "UNKNOWN"),
    3: .same(proto: "INVALID_ARGUMENT"),
    4: .same(proto: "DEADLINE_EXCEEDED"),
    5: .same(proto: "NOT_FOUND"),
    6: .same(proto: "ALREADY_EXISTS"),
    7: .same(proto: "PERMISSION_DENIED"),
    8: .same(proto: "RESOURCE_EXHAUSTED"),
    9: .same(proto: "FAILED_PRECONDITION"),
    10: .same(proto: "ABORTED"),
    11: .same(proto: "OUT_OF_RANGE"),
    12: .same(proto: "UNIMPLEMENTED"),
    13: .same(proto: "INTERNAL"),
    14: .same(proto: "UNAVAILABLE"),
    15: .same(proto: "DATA_LOSS"),
    16: .same(proto: "UNAUTHENTICATED"),
  ]
}

extension Google_Firestore_V1_RpcError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RpcError"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "message"),
    3: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 2)
    }
    if self.status != .ok {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_RpcError, rhs: Google_Firestore_V1_RpcError) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.message != rhs.message {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Document: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Document"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "fields"),
    3: .standard(proto: "create_time"),
    4: .standard(proto: "update_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Firestore_V1_Value>.self, value: &self.fields) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._createTime) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Firestore_V1_Value>.self, value: self.fields, fieldNumber: 2)
    }
    try { if let v = self._createTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_Document, rhs: Google_Firestore_V1_Document) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.fields != rhs.fields {return false}
    if lhs._createTime != rhs._createTime {return false}
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Value"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    11: .standard(proto: "null_value"),
    1: .standard(proto: "boolean_value"),
    2: .standard(proto: "integer_value"),
    3: .standard(proto: "double_value"),
    10: .standard(proto: "timestamp_value"),
    17: .standard(proto: "string_value"),
    18: .standard(proto: "bytes_value"),
    5: .standard(proto: "reference_value"),
    8: .standard(proto: "geo_point_value"),
    9: .standard(proto: "array_value"),
    6: .standard(proto: "map_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .booleanValue(v)
        }
      }()
      case 2: try {
        var v: Int64?
        try decoder.decodeSingularInt64Field(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .integerValue(v)
        }
      }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .doubleValue(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .referenceValue(v)
        }
      }()
      case 6: try {
        var v: Google_Firestore_V1_MapValue?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .mapValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .mapValue(v)
        }
      }()
      case 8: try {
        var v: Google_Firestore_V1_LatLng?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .geoPointValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .geoPointValue(v)
        }
      }()
      case 9: try {
        var v: Google_Firestore_V1_ArrayValue?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .arrayValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .arrayValue(v)
        }
      }()
      case 10: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.valueType {
          hadOneofValue = true
          if case .timestampValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.valueType = .timestampValue(v)
        }
      }()
      case 11: try {
        var v: SwiftProtobuf.Google_Protobuf_NullValue?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .nullValue(v)
        }
      }()
      case 17: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .stringValue(v)
        }
      }()
      case 18: try {
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {
          if self.valueType != nil {try decoder.handleConflictingOneOf()}
          self.valueType = .bytesValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.valueType {
    case .booleanValue?: try {
      guard case .booleanValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .integerValue?: try {
      guard case .integerValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 2)
    }()
    case .doubleValue?: try {
      guard case .doubleValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .referenceValue?: try {
      guard case .referenceValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .mapValue?: try {
      guard case .mapValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .geoPointValue?: try {
      guard case .geoPointValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .arrayValue?: try {
      guard case .arrayValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .timestampValue?: try {
      guard case .timestampValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .nullValue?: try {
      guard case .nullValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 11)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 17)
    }()
    case .bytesValue?: try {
      guard case .bytesValue(let v)? = self.valueType else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 18)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_Value, rhs: Google_Firestore_V1_Value) -> Bool {
    if lhs.valueType != rhs.valueType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ArrayValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ArrayValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "values"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_ArrayValue, rhs: Google_Firestore_V1_ArrayValue) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_MapValue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MapValue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Firestore_V1_Value>.self, value: &self.fields) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fields.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Google_Firestore_V1_Value>.self, value: self.fields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_MapValue, rhs: Google_Firestore_V1_MapValue) -> Bool {
    if lhs.fields != rhs.fields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_LatLng: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LatLng"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_LatLng, rhs: Google_Firestore_V1_LatLng) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_ListDocumentsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListDocumentsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "documents"),
    2: .standard(proto: "next_page_token"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.documents) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.nextPageToken) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.documents.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.documents, fieldNumber: 1)
    }
    if !self.nextPageToken.isEmpty {
      try visitor.visitSingularStringField(value: self.nextPageToken, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_ListDocumentsResponse, rhs: Google_Firestore_V1_ListDocumentsResponse) -> Bool {
    if lhs.documents != rhs.documents {return false}
    if lhs.nextPageToken != rhs.nextPageToken {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_WriteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "stream_id"),
    3: .same(proto: "writes"),
    4: .standard(proto: "stream_token"),
    5: .same(proto: "labels"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularStringField(value: &self._streamID) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.writes) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._streamToken) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.labels) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._streamID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.writes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writes, fieldNumber: 3)
    }
    try { if let v = self._streamToken {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    if !self.labels.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.labels, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_WriteRequest, rhs: Google_Firestore_V1_WriteRequest) -> Bool {
    if lhs._streamID != rhs._streamID {return false}
    if lhs.writes != rhs.writes {return false}
    if lhs._streamToken != rhs._streamToken {return false}
    if lhs.labels != rhs.labels {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_WriteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "stream_id"),
    2: .standard(proto: "stream_token"),
    3: .standard(proto: "write_results"),
    4: .standard(proto: "commit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.streamID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.streamToken) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.writeResults) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._commitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.streamID.isEmpty {
      try visitor.visitSingularStringField(value: self.streamID, fieldNumber: 1)
    }
    if !self.streamToken.isEmpty {
      try visitor.visitSingularBytesField(value: self.streamToken, fieldNumber: 2)
    }
    if !self.writeResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeResults, fieldNumber: 3)
    }
    try { if let v = self._commitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_WriteResponse, rhs: Google_Firestore_V1_WriteResponse) -> Bool {
    if lhs.streamID != rhs.streamID {return false}
    if lhs.streamToken != rhs.streamToken {return false}
    if lhs.writeResults != rhs.writeResults {return false}
    if lhs._commitTime != rhs._commitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_WriteResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".WriteResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_time"),
    2: .standard(proto: "transform_results"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._updateTime) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.transformResults) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    if !self.transformResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.transformResults, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_WriteResult, rhs: Google_Firestore_V1_WriteResult) -> Bool {
    if lhs._updateTime != rhs._updateTime {return false}
    if lhs.transformResults != rhs.transformResults {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CommitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "writes"),
    3: .same(proto: "transaction"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.writes) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.transaction) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.writes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writes, fieldNumber: 2)
    }
    if !self.transaction.isEmpty {
      try visitor.visitSingularBytesField(value: self.transaction, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_CommitRequest, rhs: Google_Firestore_V1_CommitRequest) -> Bool {
    if lhs.writes != rhs.writes {return false}
    if lhs.transaction != rhs.transaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_CommitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "write_results"),
    2: .standard(proto: "commit_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.writeResults) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._commitTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.writeResults.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.writeResults, fieldNumber: 1)
    }
    try { if let v = self._commitTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_CommitResponse, rhs: Google_Firestore_V1_CommitResponse) -> Bool {
    if lhs.writeResults != rhs.writeResults {return false}
    if lhs._commitTime != rhs._commitTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Write: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Write"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "update"),
    2: .same(proto: "delete"),
    3: .standard(proto: "update_mask"),
    4: .standard(proto: "current_document"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Google_Firestore_V1_Document?
        var hadOneofValue = false
        if let current = self.operation {
          hadOneofValue = true
          if case .update(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.operation = .update(v)
        }
      }()
      case 2: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.operation != nil {try decoder.handleConflictingOneOf()}
          self.operation = .delete(v)
        }
      }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._updateMask) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._currentDocument) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.operation {
    case .update?: try {
      guard case .update(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .delete?: try {
      guard case .delete(let v)? = self.operation else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try { if let v = self._updateMask {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._currentDocument {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_Write, rhs: Google_Firestore_V1_Write) -> Bool {
    if lhs.operation != rhs.operation {return false}
    if lhs._updateMask != rhs._updateMask {return false}
    if lhs._currentDocument != rhs._currentDocument {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_DocumentMask: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DocumentMask"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "field_paths"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.fieldPaths) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fieldPaths.isEmpty {
      try visitor.visitRepeatedStringField(value: self.fieldPaths, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_DocumentMask, rhs: Google_Firestore_V1_DocumentMask) -> Bool {
    if lhs.fieldPaths != rhs.fieldPaths {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Google_Firestore_V1_Precondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Precondition"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exists"),
    2: .standard(proto: "update_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.conditionType != nil {try decoder.handleConflictingOneOf()}
          self.conditionType = .exists(v)
        }
      }()
      case 2: try {
        var v: SwiftProtobuf.Google_Protobuf_Timestamp?
        var hadOneofValue = false
        if let current = self.conditionType {
          hadOneofValue = true
          if case .updateTime(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.conditionType = .updateTime(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.conditionType {
    case .exists?: try {
      guard case .exists(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .updateTime?: try {
      guard case .updateTime(let v)? = self.conditionType else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Google_Firestore_V1_Precondition, rhs: Google_Firestore_V1_Precondition) -> Bool {
    if lhs.conditionType != rhs.conditionType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
