/* eslint-disable */
// @generated by protobuf-ts 2.8.1 with parameter eslint_disable,long_type_string,ts_nocheck
// @generated from protobuf file "third_party/FirestoreProto.proto" (package "google.firestore.v1", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { NullValue } from "../google/protobuf/struct";
import { Timestamp } from "../google/protobuf/timestamp";
/**
 * A Firestore document.
 *
 * Must not exceed 1 MiB - 4 bytes.
 *
 * @generated from protobuf message google.firestore.v1.Document
 */
export interface Document {
    /**
     * The resource name of the document, for example
     * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * The document's fields.
     *
     * The map keys represent field names.
     *
     * A simple field name contains only characters `a` to `z`, `A` to `Z`,
     * `0` to `9`, or `_`, and must not start with `0` to `9`. For example,
     * `foo_bar_17`.
     *
     * Field names matching the regular expression `__.*__` are reserved. Reserved
     * field names are forbidden except in certain documented contexts. The map
     * keys, represented as UTF-8, must not exceed 1,500 bytes and cannot be
     * empty.
     *
     * Field paths may be used in other contexts to refer to structured fields
     * defined here. For `map_value`, the field path is represented by the simple
     * or quoted field names of the containing fields, delimited by `.`. For
     * example, the structured field
     * `"foo" : { map_value: { "x&y" : { string_value: "hello" }}}` would be
     * represented by the field path `foo.x&y`.
     *
     * Within a field path, a quoted field name starts and ends with `` ` `` and
     * may contain any character. Some characters, including `` ` ``, must be
     * escaped using a `\`. For example, `` `x&y` `` represents `x&y` and
     * `` `bak\`tik` `` represents `` bak`tik ``.
     *
     * @generated from protobuf field: map<string, google.firestore.v1.Value> fields = 2;
     */
    fields: {
        [key: string]: Value;
    };
    /**
     * Output only. The time at which the document was created.
     *
     * This value increases monotonically when a document is deleted then
     * recreated. It can also be compared to values from other documents and
     * the `read_time` of a query.
     *
     * @generated from protobuf field: google.protobuf.Timestamp create_time = 3;
     */
    createTime?: Timestamp;
    /**
     * Output only. The time at which the document was last changed.
     *
     * This value is initially set to the `create_time` then increases
     * monotonically with each change to the document. It can also be
     * compared to values from other documents and the `read_time` of a query.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 4;
     */
    updateTime?: Timestamp;
}
/**
 * A message that can hold any of the supported value types.
 *
 * @generated from protobuf message google.firestore.v1.Value
 */
export interface Value {
    /**
     * @generated from protobuf oneof: value_type
     */
    valueType: {
        oneofKind: "nullValue";
        /**
         * A null value.
         *
         * @generated from protobuf field: google.protobuf.NullValue null_value = 11;
         */
        nullValue: NullValue;
    } | {
        oneofKind: "booleanValue";
        /**
         * A boolean value.
         *
         * @generated from protobuf field: bool boolean_value = 1;
         */
        booleanValue: boolean;
    } | {
        oneofKind: "integerValue";
        /**
         * An integer value.
         *
         * @generated from protobuf field: int64 integer_value = 2;
         */
        integerValue: string;
    } | {
        oneofKind: "doubleValue";
        /**
         * A double value.
         *
         * @generated from protobuf field: double double_value = 3;
         */
        doubleValue: number;
    } | {
        oneofKind: "timestampValue";
        /**
         * A timestamp value.
         *
         * Precise only to microseconds. When stored, any additional precision is
         * rounded down.
         *
         * @generated from protobuf field: google.protobuf.Timestamp timestamp_value = 10;
         */
        timestampValue: Timestamp;
    } | {
        oneofKind: "stringValue";
        /**
         * A string value.
         *
         * The string, represented as UTF-8, must not exceed 1 MiB - 89 bytes.
         * Only the first 1,500 bytes of the UTF-8 representation are considered by
         * queries.
         *
         * @generated from protobuf field: string string_value = 17;
         */
        stringValue: string;
    } | {
        oneofKind: "bytesValue";
        /**
         * A bytes value.
         *
         * Must not exceed 1 MiB - 89 bytes.
         * Only the first 1,500 bytes are considered by queries.
         *
         * @generated from protobuf field: bytes bytes_value = 18;
         */
        bytesValue: Uint8Array;
    } | {
        oneofKind: "referenceValue";
        /**
         * A reference to a document. For example:
         * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
         *
         * @generated from protobuf field: string reference_value = 5;
         */
        referenceValue: string;
    } | {
        oneofKind: "geoPointValue";
        /**
         * A geo point value representing a point on the surface of Earth.
         *
         * @generated from protobuf field: google.firestore.v1.LatLng geo_point_value = 8;
         */
        geoPointValue: LatLng;
    } | {
        oneofKind: "arrayValue";
        /**
         * An array value.
         *
         * Cannot directly contain another array value, though can contain an
         * map which contains another array.
         *
         * @generated from protobuf field: google.firestore.v1.ArrayValue array_value = 9;
         */
        arrayValue: ArrayValue;
    } | {
        oneofKind: "mapValue";
        /**
         * A map value.
         *
         * @generated from protobuf field: google.firestore.v1.MapValue map_value = 6;
         */
        mapValue: MapValue;
    } | {
        oneofKind: undefined;
    };
}
/**
 * An array value.
 *
 * @generated from protobuf message google.firestore.v1.ArrayValue
 */
export interface ArrayValue {
    /**
     * Values in the array.
     *
     * @generated from protobuf field: repeated google.firestore.v1.Value values = 1;
     */
    values: Value[];
}
/**
 * A map value.
 *
 * @generated from protobuf message google.firestore.v1.MapValue
 */
export interface MapValue {
    /**
     * The map's fields.
     *
     * The map keys represent field names. Field names matching the regular
     * expression `__.*__` are reserved. Reserved field names are forbidden except
     * in certain documented contexts. The map keys, represented as UTF-8, must
     * not exceed 1,500 bytes and cannot be empty.
     *
     * @generated from protobuf field: map<string, google.firestore.v1.Value> fields = 1;
     */
    fields: {
        [key: string]: Value;
    };
}
/**
 * An object that represents a latitude/longitude pair. This is expressed as a
 * pair of doubles to represent degrees latitude and degrees longitude. Unless
 * specified otherwise, this must conform to the
 * <a href="http://www.unoosa.org/pdf/icg/2012/template/WGS_84.pdf">WGS84
 * standard</a>. Values must be within normalized ranges.
 *
 * @generated from protobuf message google.firestore.v1.LatLng
 */
export interface LatLng {
    /**
     * The latitude in degrees. It must be in the range [-90.0, +90.0].
     *
     * @generated from protobuf field: double latitude = 1;
     */
    latitude: number;
    /**
     * The longitude in degrees. It must be in the range [-180.0, +180.0].
     *
     * @generated from protobuf field: double longitude = 2;
     */
    longitude: number;
}
/**
 * @generated from protobuf message google.firestore.v1.ListDocumentsResponse
 */
export interface ListDocumentsResponse {
    /**
     * The Documents found.
     *
     * @generated from protobuf field: repeated google.firestore.v1.Document documents = 1;
     */
    documents: Document[];
    /**
     * The next page token.
     *
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * The request for [Firestore.Write][google.firestore.v1.Firestore.Write].
 *
 * The first request creates a stream, or resumes an existing one from a token.
 *
 * When creating a new stream, the server replies with a response containing
 * only an ID and a token, to use in the next request.
 *
 * When resuming a stream, the server first streams any responses later than the
 * given token, then a response containing only an up-to-date token, to use in
 * the next request.
 *
 * Required. The database name. In the format:
 * `projects/{project_id}/databases/{database_id}`.
 * This is only required in the first message.
 * [SUPPLIED VIA URL PATH] string database = 1; // [(google.api.field_behavior) = REQUIRED];
 *
 * @generated from protobuf message google.firestore.v1.WriteRequest
 */
export interface WriteRequest {
    /**
     * The ID of the write stream to resume.
     * This may only be set in the first message. When left empty, a new write
     * stream will be created.
     *
     * @generated from protobuf field: optional string stream_id = 2;
     */
    streamId?: string;
    /**
     * The writes to apply.
     *
     * Always executed atomically and in order.
     * This must be empty on the first request.
     * This may be empty on the last request.
     * This must not be empty on all other requests.
     *
     * @generated from protobuf field: repeated google.firestore.v1.Write writes = 3;
     */
    writes: Write[];
    /**
     * A stream token that was previously sent by the server.
     *
     * The client should set this field to the token from the most recent
     * [WriteResponse][google.firestore.v1.WriteResponse] it has received. This acknowledges that the client has
     * received responses up to this token. After sending this token, earlier
     * tokens may not be used anymore.
     *
     * The server may close the stream if there are too many unacknowledged
     * responses.
     *
     * Leave this field unset when creating a new stream. To resume a stream at
     * a specific point, set this field and the `stream_id` field.
     *
     * Leave this field unset when creating a new stream.
     *
     * @generated from protobuf field: optional bytes stream_token = 4;
     */
    streamToken?: Uint8Array;
    /**
     * Labels associated with this write request.
     *
     * @generated from protobuf field: map<string, string> labels = 5;
     */
    labels: {
        [key: string]: string;
    };
}
/**
 * The response for [Firestore.Write][google.firestore.v1.Firestore.Write].
 *
 * @generated from protobuf message google.firestore.v1.WriteResponse
 */
export interface WriteResponse {
    /**
     * The ID of the stream.
     * Only set on the first message, when a new stream was created.
     *
     * @generated from protobuf field: string stream_id = 1;
     */
    streamId: string;
    /**
     * A token that represents the position of this response in the stream.
     * This can be used by a client to resume the stream at this point.
     *
     * This field is always set.
     *
     * @generated from protobuf field: bytes stream_token = 2;
     */
    streamToken: Uint8Array;
    /**
     * The result of applying the writes.
     *
     * This i-th write result corresponds to the i-th write in the
     * request.
     *
     * @generated from protobuf field: repeated google.firestore.v1.WriteResult write_results = 3;
     */
    writeResults: WriteResult[];
    /**
     * The time at which the commit occurred. Any read with an equal or greater
     * `read_time` is guaranteed to see the effects of the write.
     *
     * @generated from protobuf field: google.protobuf.Timestamp commit_time = 4;
     */
    commitTime?: Timestamp;
}
/**
 * The result of applying a write.
 *
 * @generated from protobuf message google.firestore.v1.WriteResult
 */
export interface WriteResult {
    /**
     * The last update time of the document after applying the write. Not set
     * after a `delete`.
     *
     * If the write did not actually change the document, this will be the
     * previous update_time.
     *
     * @generated from protobuf field: google.protobuf.Timestamp update_time = 1;
     */
    updateTime?: Timestamp;
    /**
     * The results of applying each [DocumentTransform.FieldTransform][google.firestore.v1.DocumentTransform.FieldTransform], in the
     * same order.
     *
     * @generated from protobuf field: repeated google.firestore.v1.Value transform_results = 2;
     */
    transformResults: Value[];
}
/**
 * A write on a document.
 *
 * @generated from protobuf message google.firestore.v1.Write
 */
export interface Write {
    /**
     * @generated from protobuf oneof: operation
     */
    operation: {
        oneofKind: "update";
        /**
         * A document to write.
         *
         * @generated from protobuf field: google.firestore.v1.Document update = 1;
         */
        update: Document;
    } | {
        oneofKind: "delete";
        /**
         * A document name to delete. In the format:
         * `projects/{project_id}/databases/{database_id}/documents/{document_path}`.
         *
         * @generated from protobuf field: string delete = 2;
         */
        delete: string;
    } | {
        oneofKind: undefined;
    };
}
// @generated message type with reflection information, may provide speed optimized methods
class Document$Type extends MessageType<Document> {
    constructor() {
        super("google.firestore.v1.Document", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "fields", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } },
            { no: 3, name: "create_time", kind: "message", T: () => Timestamp },
            { no: 4, name: "update_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<Document>): Document {
        const message = { name: "", fields: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Document>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Document): Document {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* map<string, google.firestore.v1.Value> fields */ 2:
                    this.binaryReadMap2(message.fields, reader, options);
                    break;
                case /* google.protobuf.Timestamp create_time */ 3:
                    message.createTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createTime);
                    break;
                case /* google.protobuf.Timestamp update_time */ 4:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap2(map: Document["fields"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Document["fields"] | undefined, val: Document["fields"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.firestore.v1.Document.fields");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: Document, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* map<string, google.firestore.v1.Value> fields = 2; */
        for (let k of Object.keys(message.fields)) {
            writer.tag(2, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.fields[k], writer, options);
            writer.join().join();
        }
        /* google.protobuf.Timestamp create_time = 3; */
        if (message.createTime)
            Timestamp.internalBinaryWrite(message.createTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp update_time = 4; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.Document
 */
export const Document = new Document$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Value$Type extends MessageType<Value> {
    constructor() {
        super("google.firestore.v1.Value", [
            { no: 11, name: "null_value", kind: "enum", oneof: "valueType", T: () => ["google.protobuf.NullValue", NullValue] },
            { no: 1, name: "boolean_value", kind: "scalar", oneof: "valueType", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "integer_value", kind: "scalar", oneof: "valueType", T: 3 /*ScalarType.INT64*/ },
            { no: 3, name: "double_value", kind: "scalar", oneof: "valueType", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 10, name: "timestamp_value", kind: "message", oneof: "valueType", T: () => Timestamp },
            { no: 17, name: "string_value", kind: "scalar", oneof: "valueType", T: 9 /*ScalarType.STRING*/ },
            { no: 18, name: "bytes_value", kind: "scalar", oneof: "valueType", T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "reference_value", kind: "scalar", oneof: "valueType", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "geo_point_value", kind: "message", oneof: "valueType", T: () => LatLng },
            { no: 9, name: "array_value", kind: "message", oneof: "valueType", T: () => ArrayValue },
            { no: 6, name: "map_value", kind: "message", oneof: "valueType", T: () => MapValue }
        ]);
    }
    create(value?: PartialMessage<Value>): Value {
        const message = { valueType: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Value>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Value): Value {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.NullValue null_value */ 11:
                    message.valueType = {
                        oneofKind: "nullValue",
                        nullValue: reader.int32()
                    };
                    break;
                case /* bool boolean_value */ 1:
                    message.valueType = {
                        oneofKind: "booleanValue",
                        booleanValue: reader.bool()
                    };
                    break;
                case /* int64 integer_value */ 2:
                    message.valueType = {
                        oneofKind: "integerValue",
                        integerValue: reader.int64().toString()
                    };
                    break;
                case /* double double_value */ 3:
                    message.valueType = {
                        oneofKind: "doubleValue",
                        doubleValue: reader.double()
                    };
                    break;
                case /* google.protobuf.Timestamp timestamp_value */ 10:
                    message.valueType = {
                        oneofKind: "timestampValue",
                        timestampValue: Timestamp.internalBinaryRead(reader, reader.uint32(), options, (message.valueType as any).timestampValue)
                    };
                    break;
                case /* string string_value */ 17:
                    message.valueType = {
                        oneofKind: "stringValue",
                        stringValue: reader.string()
                    };
                    break;
                case /* bytes bytes_value */ 18:
                    message.valueType = {
                        oneofKind: "bytesValue",
                        bytesValue: reader.bytes()
                    };
                    break;
                case /* string reference_value */ 5:
                    message.valueType = {
                        oneofKind: "referenceValue",
                        referenceValue: reader.string()
                    };
                    break;
                case /* google.firestore.v1.LatLng geo_point_value */ 8:
                    message.valueType = {
                        oneofKind: "geoPointValue",
                        geoPointValue: LatLng.internalBinaryRead(reader, reader.uint32(), options, (message.valueType as any).geoPointValue)
                    };
                    break;
                case /* google.firestore.v1.ArrayValue array_value */ 9:
                    message.valueType = {
                        oneofKind: "arrayValue",
                        arrayValue: ArrayValue.internalBinaryRead(reader, reader.uint32(), options, (message.valueType as any).arrayValue)
                    };
                    break;
                case /* google.firestore.v1.MapValue map_value */ 6:
                    message.valueType = {
                        oneofKind: "mapValue",
                        mapValue: MapValue.internalBinaryRead(reader, reader.uint32(), options, (message.valueType as any).mapValue)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Value, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.NullValue null_value = 11; */
        if (message.valueType.oneofKind === "nullValue")
            writer.tag(11, WireType.Varint).int32(message.valueType.nullValue);
        /* bool boolean_value = 1; */
        if (message.valueType.oneofKind === "booleanValue")
            writer.tag(1, WireType.Varint).bool(message.valueType.booleanValue);
        /* int64 integer_value = 2; */
        if (message.valueType.oneofKind === "integerValue")
            writer.tag(2, WireType.Varint).int64(message.valueType.integerValue);
        /* double double_value = 3; */
        if (message.valueType.oneofKind === "doubleValue")
            writer.tag(3, WireType.Bit64).double(message.valueType.doubleValue);
        /* google.protobuf.Timestamp timestamp_value = 10; */
        if (message.valueType.oneofKind === "timestampValue")
            Timestamp.internalBinaryWrite(message.valueType.timestampValue, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* string string_value = 17; */
        if (message.valueType.oneofKind === "stringValue")
            writer.tag(17, WireType.LengthDelimited).string(message.valueType.stringValue);
        /* bytes bytes_value = 18; */
        if (message.valueType.oneofKind === "bytesValue")
            writer.tag(18, WireType.LengthDelimited).bytes(message.valueType.bytesValue);
        /* string reference_value = 5; */
        if (message.valueType.oneofKind === "referenceValue")
            writer.tag(5, WireType.LengthDelimited).string(message.valueType.referenceValue);
        /* google.firestore.v1.LatLng geo_point_value = 8; */
        if (message.valueType.oneofKind === "geoPointValue")
            LatLng.internalBinaryWrite(message.valueType.geoPointValue, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* google.firestore.v1.ArrayValue array_value = 9; */
        if (message.valueType.oneofKind === "arrayValue")
            ArrayValue.internalBinaryWrite(message.valueType.arrayValue, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* google.firestore.v1.MapValue map_value = 6; */
        if (message.valueType.oneofKind === "mapValue")
            MapValue.internalBinaryWrite(message.valueType.mapValue, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.Value
 */
export const Value = new Value$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArrayValue$Type extends MessageType<ArrayValue> {
    constructor() {
        super("google.firestore.v1.ArrayValue", [
            { no: 1, name: "values", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Value }
        ]);
    }
    create(value?: PartialMessage<ArrayValue>): ArrayValue {
        const message = { values: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ArrayValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArrayValue): ArrayValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.firestore.v1.Value values */ 1:
                    message.values.push(Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArrayValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.firestore.v1.Value values = 1; */
        for (let i = 0; i < message.values.length; i++)
            Value.internalBinaryWrite(message.values[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.ArrayValue
 */
export const ArrayValue = new ArrayValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapValue$Type extends MessageType<MapValue> {
    constructor() {
        super("google.firestore.v1.MapValue", [
            { no: 1, name: "fields", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "message", T: () => Value } }
        ]);
    }
    create(value?: PartialMessage<MapValue>): MapValue {
        const message = { fields: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MapValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapValue): MapValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, google.firestore.v1.Value> fields */ 1:
                    this.binaryReadMap1(message.fields, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: MapValue["fields"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof MapValue["fields"] | undefined, val: MapValue["fields"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = Value.internalBinaryRead(reader, reader.uint32(), options);
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.firestore.v1.MapValue.fields");
            }
        }
        map[key ?? ""] = val ?? Value.create();
    }
    internalBinaryWrite(message: MapValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, google.firestore.v1.Value> fields = 1; */
        for (let k of Object.keys(message.fields)) {
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k);
            writer.tag(2, WireType.LengthDelimited).fork();
            Value.internalBinaryWrite(message.fields[k], writer, options);
            writer.join().join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.MapValue
 */
export const MapValue = new MapValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LatLng$Type extends MessageType<LatLng> {
    constructor() {
        super("google.firestore.v1.LatLng", [
            { no: 1, name: "latitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "longitude", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<LatLng>): LatLng {
        const message = { latitude: 0, longitude: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LatLng>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LatLng): LatLng {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double latitude */ 1:
                    message.latitude = reader.double();
                    break;
                case /* double longitude */ 2:
                    message.longitude = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LatLng, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double latitude = 1; */
        if (message.latitude !== 0)
            writer.tag(1, WireType.Bit64).double(message.latitude);
        /* double longitude = 2; */
        if (message.longitude !== 0)
            writer.tag(2, WireType.Bit64).double(message.longitude);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.LatLng
 */
export const LatLng = new LatLng$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListDocumentsResponse$Type extends MessageType<ListDocumentsResponse> {
    constructor() {
        super("google.firestore.v1.ListDocumentsResponse", [
            { no: 1, name: "documents", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Document },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ListDocumentsResponse>): ListDocumentsResponse {
        const message = { documents: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ListDocumentsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListDocumentsResponse): ListDocumentsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated google.firestore.v1.Document documents */ 1:
                    message.documents.push(Document.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListDocumentsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated google.firestore.v1.Document documents = 1; */
        for (let i = 0; i < message.documents.length; i++)
            Document.internalBinaryWrite(message.documents[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.ListDocumentsResponse
 */
export const ListDocumentsResponse = new ListDocumentsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteRequest$Type extends MessageType<WriteRequest> {
    constructor() {
        super("google.firestore.v1.WriteRequest", [
            { no: 2, name: "stream_id", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "writes", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Write },
            { no: 4, name: "stream_token", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 5, name: "labels", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<WriteRequest>): WriteRequest {
        const message = { writes: [], labels: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteRequest): WriteRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string stream_id */ 2:
                    message.streamId = reader.string();
                    break;
                case /* repeated google.firestore.v1.Write writes */ 3:
                    message.writes.push(Write.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bytes stream_token */ 4:
                    message.streamToken = reader.bytes();
                    break;
                case /* map<string, string> labels */ 5:
                    this.binaryReadMap5(message.labels, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap5(map: WriteRequest["labels"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof WriteRequest["labels"] | undefined, val: WriteRequest["labels"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field google.firestore.v1.WriteRequest.labels");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: WriteRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string stream_id = 2; */
        if (message.streamId !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.streamId);
        /* repeated google.firestore.v1.Write writes = 3; */
        for (let i = 0; i < message.writes.length; i++)
            Write.internalBinaryWrite(message.writes[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bytes stream_token = 4; */
        if (message.streamToken !== undefined)
            writer.tag(4, WireType.LengthDelimited).bytes(message.streamToken);
        /* map<string, string> labels = 5; */
        for (let k of Object.keys(message.labels))
            writer.tag(5, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.labels[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.WriteRequest
 */
export const WriteRequest = new WriteRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteResponse$Type extends MessageType<WriteResponse> {
    constructor() {
        super("google.firestore.v1.WriteResponse", [
            { no: 1, name: "stream_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "stream_token", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "write_results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => WriteResult },
            { no: 4, name: "commit_time", kind: "message", T: () => Timestamp }
        ]);
    }
    create(value?: PartialMessage<WriteResponse>): WriteResponse {
        const message = { streamId: "", streamToken: new Uint8Array(0), writeResults: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteResponse): WriteResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string stream_id */ 1:
                    message.streamId = reader.string();
                    break;
                case /* bytes stream_token */ 2:
                    message.streamToken = reader.bytes();
                    break;
                case /* repeated google.firestore.v1.WriteResult write_results */ 3:
                    message.writeResults.push(WriteResult.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* google.protobuf.Timestamp commit_time */ 4:
                    message.commitTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.commitTime);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string stream_id = 1; */
        if (message.streamId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.streamId);
        /* bytes stream_token = 2; */
        if (message.streamToken.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.streamToken);
        /* repeated google.firestore.v1.WriteResult write_results = 3; */
        for (let i = 0; i < message.writeResults.length; i++)
            WriteResult.internalBinaryWrite(message.writeResults[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp commit_time = 4; */
        if (message.commitTime)
            Timestamp.internalBinaryWrite(message.commitTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.WriteResponse
 */
export const WriteResponse = new WriteResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WriteResult$Type extends MessageType<WriteResult> {
    constructor() {
        super("google.firestore.v1.WriteResult", [
            { no: 1, name: "update_time", kind: "message", T: () => Timestamp },
            { no: 2, name: "transform_results", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Value }
        ]);
    }
    create(value?: PartialMessage<WriteResult>): WriteResult {
        const message = { transformResults: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WriteResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WriteResult): WriteResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.protobuf.Timestamp update_time */ 1:
                    message.updateTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.updateTime);
                    break;
                case /* repeated google.firestore.v1.Value transform_results */ 2:
                    message.transformResults.push(Value.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WriteResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.protobuf.Timestamp update_time = 1; */
        if (message.updateTime)
            Timestamp.internalBinaryWrite(message.updateTime, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated google.firestore.v1.Value transform_results = 2; */
        for (let i = 0; i < message.transformResults.length; i++)
            Value.internalBinaryWrite(message.transformResults[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.WriteResult
 */
export const WriteResult = new WriteResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Write$Type extends MessageType<Write> {
    constructor() {
        super("google.firestore.v1.Write", [
            { no: 1, name: "update", kind: "message", oneof: "operation", T: () => Document },
            { no: 2, name: "delete", kind: "scalar", oneof: "operation", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Write>): Write {
        const message = { operation: { oneofKind: undefined } };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Write>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Write): Write {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* google.firestore.v1.Document update */ 1:
                    message.operation = {
                        oneofKind: "update",
                        update: Document.internalBinaryRead(reader, reader.uint32(), options, (message.operation as any).update)
                    };
                    break;
                case /* string delete */ 2:
                    message.operation = {
                        oneofKind: "delete",
                        delete: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Write, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* google.firestore.v1.Document update = 1; */
        if (message.operation.oneofKind === "update")
            Document.internalBinaryWrite(message.operation.update, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string delete = 2; */
        if (message.operation.oneofKind === "delete")
            writer.tag(2, WireType.LengthDelimited).string(message.operation.delete);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message google.firestore.v1.Write
 */
export const Write = new Write$Type();
